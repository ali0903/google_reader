<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>位运算简介及实用技巧（四）：实战篇</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>位运算简介及实用技巧（四）：实战篇</h2>
<p class="meta">2007-07-26 09:47</p>

<div class="post">
<h2>位运算简介及实用技巧（四）：实战篇</h2>

<h3>by matrix67@tom.com(matrix67)</h3>

<h3>at 2007-07-26 01:47:44</h3>

<h3>original <a href="http://www.matrix67.com/blog/default.asp?id=316">http://www.matrix67.com/blog/default.asp?id=316</a></h3>

<p>    下面分享的是我自己写的三个代码，里面有些题目也是我自己出的。这些代码都是在我的Pascal时代写的，恕不提供C语言了。代码写得并不好，我只是想告诉大家位运算在实战中的应用，包括了搜索和状态压缩DP方面的题目。其实大家可以在网上找到更多用位运算优化的题目，这里整理出一些自己写的代码，只是为了原创系列文章的完整性。这一系列文章到这里就结束了，希望大家能有所收获。<br>    Matrix67原创，转贴请注明出处。<br><br><div><div><img src="http://www.matrix67.com/blog/images/quote.gif" alt="引用内容"> 引用内容</div><div>Problem : 费解的开关<br><br><a href="http://www.vijos.cn/Problem_Show.asp?id=1197">题目来源</a><br>    06年NOIp模拟赛（一） by Matrix67 第四题<br><br>问题描述<br>    你玩过“拉灯”游戏吗？25盏灯排成一个5x5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。<br>    我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。下面这种状态<br><br>10111<br>01101<br>10111<br>10000<br>11011<br><br>    在改变了最左上角的灯的状态后将变成：<br><br>01111<br>11101<br>10111<br>10000<br>11011<br><br>    再改变它正中间的灯后状态将变成：<br><br>01111<br>11001<br>11001<br>10100<br>11011<br><br>    给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。<br><br>输入格式<br>    第一行有一个正整数n，代表数据中共有n个待解决的游戏初始状态。<br>    以下若干行数据分为n组，每组数据有5行，每行5个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。<br>    对于30%的数据，n&lt;=5；<br>    对于100%的数据，n&lt;=500。<br><br>输出格式<br>    输出数据一共有n行，每行有一个小于等于6的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。<br>    对于某一个游戏初始状态，若6步以内无法使所有灯变亮，请输出“-1”。<br><br>样例输入<br>3<br>00111<br>01011<br>10001<br>11010<br>11100<br><br>11101<br>11101<br>11110<br>11111<br>11111<br><br>01111<br>11111<br>11111<br>11111<br>11111<br><br>样例输出<br>3<br>2<br>-1</div></div><br><br>程序代码<br><div><div><img src="http://www.matrix67.com/blog/images/quote.gif" alt="程序代码"> 程序代码</div><div><pre><code>const<br>   BigPrime=3214567;<br>   MaxStep=6;<br>type<br>   pointer=^rec;<br>   rec=record<br>         v:longint;<br>         step:integer;<br>         next:pointer;<br>       end;<br><br>var<br>   total:longint;<br>   hash:array[0..BigPrime-1]of pointer;<br>   q:array[1..400000]of rec;<br><br>function update(a:longint;p:integer):longint;<br>begin<br>   a:=a xor (1 shl p);<br>   if p mod 5&lt;&gt;0 then a:=a xor (1 shl (p-1));<br>   if (p+1) mod 5&lt;&gt;0 then a:=a xor (1 shl (p+1));<br>   if p&lt;20 then a:=a xor (1 shl (p+5));<br>   if p&gt;4 then a:=a xor (1 shl (p-5));<br>   exit(a);<br>end;<br><br>function find(a:longint;step:integer):boolean;<br>var<br>   now:pointer;<br>begin<br>   now:=hash[a mod BigPrime];<br>   while now&lt;&gt;nil do<br>   begin<br>      if now^.v=a then exit(true);<br>      now:=now^.next;<br>   end;<br><br>   new(now);<br>   now^.v:=a;<br>   now^.step:=step;<br>   now^.next:=hash[a mod BigPrime];<br>   hash[a mod BigPrime]:=now;<br>   total:=total+1;<br>   exit(false);<br>end;<br><br>procedure solve;<br>var<br>   p:integer;<br>   close:longint=0;<br>   open:longint=1;<br>begin<br>   find(1 shl 25-1,0);<br>   q[1].v:=1 shl 25-1;<br>   q[1].step:=0;<br>   repeat<br>      inc(close);<br>      for p:=0 to 24 do<br>         if not find(update(q[close].v,p),q[close].step+1) and (q[close].step+1&lt;MaxStep) then<br>         begin<br>            open:=open+1;<br>            q[open].v:=update(q[close].v,p);<br>            q[open].step:=q[close].step+1;<br>         end;<br>   until close&gt;=open;<br>end;<br><br>procedure print(a:longint);<br>var<br>   now:pointer;<br>begin<br>   now:=hash[a mod BigPrime];<br>   while now&lt;&gt;nil do<br>   begin<br>      if now^.v=a then<br>      begin<br>         writeln(now^.step);<br>         exit;<br>      end;<br>      now:=now^.next;<br>   end;<br>   writeln(-1);<br>end;<br><br>procedure main;<br>var<br>   ch:char;<br>   i,j,n:integer;<br>   t:longint;<br>begin<br>   readln(n);<br>   for i:=1 to n do<br>   begin<br>      t:=0;<br>      for j:=1 to 25 do<br>      begin<br>         read(ch);<br>         t:=t<em>2+ord(ch)-48;<br>         if j mod 5=0 then readln;<br>      end;<br>      print(t);<br>      if i&lt;n then readln;<br>   end;<br>end;<br><br>begin<br>   solve;<br>   main;<br>end.</code></pre></div></div><br><br><strong>=======================  性感的分割线  =======================</strong><br><br><div><div><img src="http://www.matrix67.com/blog/images/quote.gif" alt="引用内容"> 引用内容</div><div>Problem : garden / 和MM逛花园<br><br>题目来源<br>    <a href="http://www.matrix67.com/blog/article.asp?id=241">07年Matrix67生日邀请赛</a>第四题<br><br>问题描述<br>    花园设计强调，简单就是美。Matrix67常去的花园有着非常简单的布局：花园的所有景点的位置都是“对齐”了的，这些景点可以看作是平面坐标上的格点。相邻的景点之间有小路相连，这些小路全部平行于坐标轴。景点和小路组成了一个“不完整的网格”。<br>    一个典型的花园布局如左图所示。花园布局在6行4列的网格上，花园的16个景点的位置用红色标注在了图中。黑色线条表示景点间的小路，其余灰色部分实际并不存在。<br>        <img src="http://www.matrix67.com/data/prob4.gif" border="0" alt=""><br><br>    Matrix67 的生日那天，他要带着他的MM在花园里游玩。Matrix67不会带MM两次经过同一个景点，因此每个景点最多被游览一次。他和他的MM边走边聊，他们是如此的投入以致于他们从不会“主动地拐弯”。也就是说，除非前方已没有景点或是前方的景点已经访问过，否则他们会一直往前走下去。当前方景点不存在或已游览过时，Matrix67会带MM另选一个方向继续前进。由于景点个数有限，访问过的景点将越来越多，迟早会出现不能再走的情况（即四个方向上的相邻景点都访问过了），此时他们将结束花园的游览。Matrix67希望知道以这种方式游览花园是否有可能遍历所有的景点。Matrix67可以选择从任意一个景点开始游览，以任意一个景点结束。<br>    在上图所示的花园布局中，一种可能的游览方式如右图所示。这种浏览方式从(1,2)出发，以(2,4)结束，经过每个景点恰好一次。<br><br>输入格式<br>    第一行输入两个用空格隔开的正整数m和n，表示花园被布局在m行n列的网格上。<br>    以下m行每行n个字符，字符“0”表示该位置没有景点，字符“1”表示对应位置有景点。这些数字之间没有空格。<br><br>输出格式<br>    你的程序需要寻找满足“不主动拐弯”性质且遍历所有景点的游览路线。<br>    如果没有这样的游览路线，请输出一行“Impossible”（不带引号，注意大小写）。<br>    如果存在游览路线，请依次输出你的方案中访问的景点的坐标，每行输出一个。坐标的表示格式为“(x,y)”，代表第x行第y列。<br>    如果有多种方案，你只需要输出其中一种即可。评测系统可以判断你的方案的正确性。<br><br>样例输入<br>6 4<br>1100<br>1001<br>1111<br>1100<br>1110<br>1110<br><br>样例输出<br>(1,2)<br>(1,1)<br>(2,1)<br>(3,1)<br>(4,1)<br>(5,1)<br>(6,1)<br>(6,2)<br>(6,3)<br>(5,3)<br>(5,2)<br>(4,2)<br>(3,2)<br>(3,3)<br>(3,4)<br>(2,4)<br><br>数据规模<br>    对于30%的数据，n,m&lt;=5；<br>    对于100%的数据，n,m&lt;=10。</div></div><br><br>程序代码：<br><div><div><img src="http://www.matrix67.com/blog/images/quote.gif" alt="程序代码"> 程序代码</div><div><pre><code>program garden;<br><br>const<br>   dir:array[1..4,1..2]of integer=<br>     ((1,0),(0,1),(-1,0),(0,-1));<br><br>type<br>   arr=array[1..10]of integer;<br>   rec=record x,y:integer;end;<br><br>var<br>   map:array[0..11,0..11]of boolean;<br>   ans:array[1..100]of rec;<br>   n,m,max:integer;<br>   step:integer=1;<br>   state:arr;<br><br>procedure readp;<br>var<br>   i,j:integer;<br>   ch:char;<br>begin<br>   readln(m,n);<br>   for i:=1 to n do<br>   begin<br>      for j:=1 to m do<br>      begin<br>         read(ch);<br>         map[i,j]:=(ch=&#39;1&#39;);<br>         inc(max,ord( map[i,j] ))<br>      end;<br>   readln;<br>   end;<br>end;<br><br>procedure writep;<br>var<br>   i:integer;<br>begin<br>   for i:=1 to step do<br>      writeln( &#39;(&#39; , ans[i].x , &#39;,&#39; , ans[i].y , &#39;)&#39; );<br>end;<br><br>procedure solve(x,y:integer);<br>var<br>   tx,ty,d:integer;<br>   step_cache:integer;<br>   state_cache:arr;<br>begin<br>   step_cache:=step;<br>   state_cache:=state;<br>   if step=max then<br>   begin<br>      writep;<br>      exit;<br>   end;<br><br>   for d:=1 to 4 do<br>   begin<br>      tx:=x+dir[d,1];<br>      ty:=y+dir[d,2];<br>      while map[tx,ty] and ( not state[tx] and(1 shl (ty-1) )&gt;0) do<br>      begin<br>         inc(step);<br>         ans[step].x:=tx;<br>         ans[step].y:=ty;<br>         state[tx]:=state[tx] or ( 1 shl (ty-1) );<br>         tx:=tx+dir[d,1];<br>         ty:=ty+dir[d,2];<br>      end;<br><br>      tx:=tx-dir[d,1];<br>      ty:=ty-dir[d,2];<br>      if (tx&lt;&gt;x) or (ty&lt;&gt;y) then solve(tx,ty);<br>      state:=state_cache;<br>      step:=step_cache;<br>   end;<br>end;<br><br>{====main====}<br>var<br>   i,j:integer;<br>begin<br>   assign(input,&#39;garden.in&#39;);<br>   reset(input);<br>   assign(output,&#39;garden.out&#39;);<br>   rewrite(output);<br><br>   readp;<br>   for i:=1 to n do<br>   for j:=1 to m do<br>     if map[i,j] then<br>     begin<br>        ans[1].x:=i;<br>        ans[1].y:=j;<br>        state[i]:=1 shl (j-1);<br>        solve(i,j);<br>        state[i]:=0;<br>     end;<br><br>   close(input);<br>   close(output);<br>end.</code></pre></div></div><br><br><strong>=======================  性感的分割线  =======================</strong><br><br><div><div><img src="http://www.matrix67.com/blog/images/quote.gif" alt="引用内容"> 引用内容</div><div>Problem : cowfood / 玉米地<br><br>题目来源<br>    USACO月赛<br><br>问题描述<br>    农夫约翰购买了一处肥沃的矩形牧场，分成M</em>N(1&lt;=M&lt;=12; 1&lt;=N&lt;=12)个格子。他想在那里的一些格子中种植美味的玉米。遗憾的是，有些格子区域的土地是贫瘠的，不能耕种。<br>    精明的约翰知道奶牛们进食时不喜欢和别的牛相邻，所以一旦在一个格子中种植玉米，那么他就不会在相邻的格子中种植，即没有两个被选中的格子拥有公共边。他还没有最终确定哪些格子要选择种植玉米。<br>    作为一个思想开明的人，农夫约翰希望考虑所有可行的选择格子种植方案。由于太开明，他还考虑一个格子都不选择的种植方案！请帮助农夫约翰确定种植方案总数。<br><br>输入格式:<br>    第一行：两个用空格分隔的整数M和N<br>    第二行到第M+1行：第i+1行描述牧场第i行每个格子的情况，N个用空格分隔的整数，表示这个格子是否可以种植（1表示肥沃的、适合种植，0表示贫瘠的、不可种植）<br><br>输出格式<br>    一个整数，农夫约翰可选择的方案总数除以 100,000,000 的余数<br><br>样例输入<br>2 3<br>1 1 1<br>0 1 0<br><br>样例输出<br>9<br><br>样例说明<br><br>    给可以种植玉米的格子编号：<br><span style="font-family:宋体">      1 2 3<br>        4</span><br><br>    只种一个格子的方案有四种(1,2,3或4)，种植两个格子的方案有三种(13,14或34)，种植三个格子的方案有一种(134)，还有一种什么格子都不种。<br>    4+3+1+1=9。<br><br>数据规模<br>    对于30%的数据，N,M&lt;=4；<br>    对于100%的数据，N,M&lt;=12。</div></div><br><br>程序代码：<br><div><div><img src="http://www.matrix67.com/blog/images/quote.gif" alt="程序代码"> 程序代码</div><div><pre><code>program cowfood;<br><br>const<br>   d=100000000;<br>   MaxN=12;<br><br>var<br>   f:array[0..MaxN,1..2000]of longint;<br>   w:array[1..2000,1..2000]of boolean;<br>   st:array[0..2000]of integer;<br>   map:array[0..MaxN]of integer;<br>   m,n:integer;<br><br>function Impossible(a:integer):boolean;<br>var<br>   i:integer;<br>   flag:boolean=false;<br>begin<br>   for i:=1 to MaxN do<br>   begin<br>      if flag and (a and 1=1) then exit(true);<br>      flag:=(a and 1=1);<br>      a:=a shr 1;<br>   end;<br>   exit(false);<br>end;<br><br>function Conflict(a,b:integer):boolean;<br>var<br>   i:integer;<br>begin<br>   for i:=1 to MaxN do<br>   begin<br>      if (a and 1=1) and (b and 1=1) then exit(true);<br>      a:=a shr 1;<br>      b:=b shr 1;<br>   end;<br>   exit(false);<br>end;<br><br>function CanPlace(a,b:integer):boolean;<br>begin<br>   exit(a or b=b);<br>end;<br><br>procedure FindSt;<br>var<br>   i:integer;<br>begin<br>   for i:=0 to 1 shl MaxN-1 do<br>      if not Impossible(i) then<br>      begin<br>         inc(st[0]);<br>         st[st[0]]:=i;<br>      end;<br>end;<br><br>procedure Init;<br>var<br>   i,j:integer; <br>begin<br>   for i:=1 to st[0] do<br>   for j:=i to st[0] do<br>      if not Conflict(st[i],st[j]) then<br>      begin<br>         w[i,j]:=true;<br>         w[j,i]:=true;<br>      end;<br>end;<br><br>procedure Readp;<br>var<br>   i,j,t,v:integer;<br>begin<br>   readln(m,n);<br>   for i:=1 to m do<br>   begin<br>      v:=0;<br>      for j:=1 to n do<br>      begin<br>         read(t);<br>         v:=v*2+t;<br>      end;<br>      map[i]:=v;<br>      readln;<br>   end;<br>end;<br><br>procedure Solve;<br>var<br>   i,j,k:integer;<br>begin<br>   f[0,1]:=1;<br>   map[0]:=1 shl n-1;<br>   for i:=1 to m do<br>   for j:=1 to st[0] do<br>      if not CanPlace(st[j],map[i]) then f[i,j]:=-1 else<br>        for k:=1 to st[0] do if (f[i-1,k]&lt;&gt;-1) and w[j,k] then<br>           f[i,j]:=(f[i,j]+f[i-1,k]) mod d;<br>end;<br><br>procedure Writep;<br>var<br>   j:integer;<br>   ans:longint=0;<br>begin<br>   for j:=1 to st[0] do<br>      if f[m,j]&lt;&gt;-1 then ans:=(ans+f[m,j]) mod d;<br>   writeln(ans);<br>end;<br><br>begin<br>   assign(input,&#39;cowfood.in&#39;);<br>   reset(input);<br>   assign(output,&#39;cowfood.out&#39;);<br>   rewrite(output);<br><br>   FindSt;<br>   Init;<br>   Readp;<br>   Solve;<br>   Writep;<br><br>   close(input);<br>   close(output);<br>end.</code></pre></div></div></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
