<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>使用memc-nginx和srcache-nginx模块构建高效透明的缓存机制</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>使用memc-nginx和srcache-nginx模块构建高效透明的缓存机制</h2>
<p class="meta">03 Oct 2011</p>

<div class="post">
<h2>使用memc-nginx和srcache-nginx模块构建高效透明的缓存机制</h2>

<h3>by T2噬菌体</h3>

<h3>at 2011-10-02 23:10:00</h3>

<h3>original <a href="http://www.cnblogs.com/leoo2sk/archive/2011/10/02/nginx-memc-and-srcache.html">http://www.cnblogs.com/leoo2sk/archive/2011/10/02/nginx-memc-and-srcache.html</a></h3>

<p>为了提高性能，几乎所有互联网应用都有缓存机制，其中<a href="http://memcached.org">Memcache</a>是使用非常广泛的一个分布式缓存系统。众所周知，LAMP是非常经典的Web架构方式，但是随着<a href="http://wiki.nginx.org/">Nginx</a>的成熟，越来越多的系统开始转型为LNMP（Linux+Nginx+MySQL+PHP with fpm），这是因为Nginx采用基于事件机制的I/O多路复用思想设计，在高并发情况下其性能远远优于默认采用prefork模式的Apache，另外，相对于Apache，Nginx更轻量，同时拥有大量优秀的扩展模块，使得在Nginx上可以实现一些美妙的功能。</p>


<p><br><p>传统上，PHP中使用memcache的方法是使用<a href="http://pecl.php.net/package/memcache">php-memcache</a>或<a href="http://pecl.php.net/package/memcached">php-memached</a>扩展操作memcache，然而在Nginx上有构建更高效缓存机制的方法，本文将首先介绍这种机制，然后介绍具体的操作步骤方法，最后将对这种机制和传统的PHP操作memcache的性能进行一个benchmark。</p><br><h1>Nginx的Memc和SR Cache模块</h1><br><h2>缓存策略的改进</h2><br><p>我们知道，Nginx的核心设计思想是事件驱动的非阻塞I/O。Nginx被设计为可以配置I/O多路复用策略，在Unix系统中传统的多路复用是采用select或poll，但是这两个方法的问题是随着监听socket的增加，性能会下降，因为在linux内核中是采用轮询的方式判断是否可以触发事件，换句话说算法的复杂度为O(N)，而在较新的linux内核中引入了复杂度为O(1)的epoll，因此Nginx在Linux下默认采用epoll，而在FreeBSD下默认采用kqueue作为I/O策略。</p><br><p>即便是这样，传统的缓存策略仍可能造成效率低下，因为传统上是通过PHP操作memcache的，要执行PHP代码，Nginx就必然要和FastCGI通信，同时也要进入PHP的生命周期，因此SAPI、PHP Core和Zend Engine的一系列逻辑会被执行。更糟糕的是，fpm和PHP可能会阻塞，因此破坏了Nginx的非阻塞性。下图展示了<span style="color:#ff0000">在memcache命中时</span>整个处理过程。<a href="http://images.cnblogs.com/cnblogs_com/leoo2sk/201110/201110021513265641.png"><img style="background-image:none;padding-left:0px;padding-right:0px;display:block;float:none;margin-left:auto;margin-right:auto;padding-top:0px;border-width:0px" title="image" src="http://images.cnblogs.com/cnblogs_com/leoo2sk/201110/201110021513272968.png" alt="image" width="644" height="265" border="0"></a></p><br><p>可以看到，即使memcache命中，还是要进入PHP的生命周期。我们知道，目前很多互联网应用都使用RESTful规范进行设计，在RESTful应用下，普遍使用uri和查询参数作为缓存的key，因此一种更高效的缓存策略是Nginx直接访问memcache，并用$uri和$args等Nginx内置变量设定缓存key规则，这样，当缓存命中时，Nginx可以跳过通过fastcgi和PHP通信的过程，直接从memcache中获取数据并返回。memc-nginx和srcache-nginx正是利用这种策略提高了缓存的效率。下图是这种高效缓存策略的示意图（当memcache命中时）。</p><br><p><a href="http://images.cnblogs.com/cnblogs_com/leoo2sk/201110/201110021513283949.png"><img style="background-image:none;padding-left:0px;padding-right:0px;display:block;float:none;margin-left:auto;margin-right:auto;padding-top:0px;border-width:0px" title="image" src="http://images.cnblogs.com/cnblogs_com/leoo2sk/201110/201110021513303817.png" alt="image" width="590" height="265" border="0"></a></p><br><p style="font-size:16px;border:1px solid #ff6600;padding:6px;color:#ff0000;background-color:ffeedd">个人博客已迁移至<a href="http://www.codinglabs.org">www.codinglabs.org</a>，本文全文最新地址为<a href="http://www.codinglabs.org/html/nginx-memc-and-srcache.html">http://www.codinglabs.org/html/nginx-memc-and-srcache.html</a></p><br><div><br><h2>模块介绍</h2><br><p><a href="http://wiki.nginx.org/HttpMemcModule">memc-nginx</a>和<a href="http://wiki.nginx.org/HttpSRCacheModule">srcache-nginx</a>模块均为前淘宝工程师agentzh（章亦春）开发。其中memc模块扩展了Nginx标准的memcache模块，增加了set、add、delete等memcache命令，而srcache则是为location增加了透明的基于subrequest的缓存层。两者配合使用，可以实现上一节提到的高效缓存机制。关于两个模块的详细信息可以参考它们Nginx官网的wiki（<a href="http://wiki.nginx.org/HttpMemcModule">memc wiki</a>，<a href="http://wiki.nginx.org/HttpSRCacheModule">srcache wiki</a>）页。</p><br><h2>安装及配置</h2><br><p>下面以LNMP环境介绍如何使用这两个模块构建缓存层。</p><br><p>因为Nginx并不支持模块动态加载，所以要安装新的模块，必须重新编译Nginx。首先下载两个模块（<a href="https://github.com/agentzh/memc-nginx-module/downloads">memc下载地址</a>，<a href="https://github.com/agentzh/srcache-nginx-module/downloads">srcache下载地址</a>），另外，为了发挥出缓存的最大性能，建议将memcache的upstream配置为keep-alive，为了支持upstream的keep-alive需要同时安装<a href="http://wiki.nginx.org/HttpUpstreamKeepaliveModule">http-upstream-keepalive-module</a>。</p><br><p>将模块下载并解压到合适的目录，这里我Nginx使用的版本是1.0.4，与相关模块一起解压到了/home/zhangyang/downloads，如下图所示。</p><br><p><a href="http://images.cnblogs.com/cnblogs_com/leoo2sk/201110/201110021619214800.png"><img style="background-image:none;padding-left:0px;padding-right:0px;display:inline;padding-top:0px;border-width:0px" title="image" src="http://images.cnblogs.com/cnblogs_com/leoo2sk/201110/201110021619236063.png" alt="image" width="764" height="382" border="0"></a></p><br><p>其中红框框起来的是我们需要用到的模块。进入nginx目录，执行下列命令：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>./configure --prefix=/usr/local/nginx --add-module=../memc-nginx-module --add-module=../srcache-nginx-module --add-module=../ngx_http_upstream_keepalive<br>make<br>make install</pre><br></div><br><p>这里我将nginx安装到/usr/local/nginx下，你可以根据自己的需要更改安装路径，另外，我只列出了本文必要的configure命令，你也可以增加需要的configure选项。</p><br><p>然后需要对nginx进行配置，nginx默认主配置文件放在安装目录的conf下，例如我的主配置文件为/usr/local/nginx/conf/nginx.conf。</p><br><p>这里我只贴出相关的配置：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>#Memcache服务upstream<br>upstream memcache {<br>    server localhost:11211;<br>    keepalive 512 single;<br>}<br><br>server {<br>    listen       80;<br>    server_name  localhost;<br><br>    #memc-nginx-module<br>    location /memc {<br>        internal;<br><br>        memc_connect_timeout 100ms;<br>        memc_send_timeout 100ms;<br>        memc_read_timeout 100ms;<br><br>        set $memc_key $query_string;<br>        set $memc_exptime 300;<br>                                           <br>        memc_pass memcache;<br>    }<br><br>    location / {<br>        root   /var/www;<br>        index  index.html index.htm index.php;<br>    }<br><br>    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000<br>    #<br>    location ~ .php$ {<br>        charset        utf-8;<br>        default_type   text/html;<br><br>        #srcache-nginx-module<br>        set $key $uri$args;<br>        srcache_fetch GET /memc $key;<br>        srcache_store PUT /memc $key;<br><br>        root           /var/www;<br>        fastcgi_pass   127.0.0.1:9000;<br>        fastcgi_index  index.php;<br>        include        fastcgi_params;<br>        fastcgi_param  SCRIPT_FILENAME $document_root$fastcgi_script_name;<br>    }<br>}</pre><br></div><br><p>下面解释一下其中几个点。</p><br><p>上文说过，memc-nginx是一个标准的upstream模块，因此首先需要定义memcache的upstream。这里我在本机上启动了一个memcache服务，端口为默认的11211，keepalive指令是http-upsteram-keepalive-module提供的功能，这里我们最大保持512个不立即关闭的连接用于提升性能。</p><br><p>下面是为memc-nginx-module配置location，我们配置为/memc，所有请求都通过请求这个location来操作memcache，memc-nginx-module存取memcache是基于http method语义的，使用http的GET方法表示get、PUT方法表示set、DELETE方法表示delete。这里我们将/memc设为<a href="http://wiki.nginx.org/NginxHttpCoreModule#internal">internal</a>表示只接受内部访问，不接收外部http请求，这是为了安全考虑，当然如果需要通过http协议开放外部访问，可以去掉internal然后使用<a href="http://wiki.nginx.org/NginxHttpAccessModule#deny">deny</a>和<a href="http://wiki.nginx.org/NginxHttpAccessModule#allow">allow</a>指令控制权限。比较重要的是$memc_key这个变量，它表示以什么作为key，这里我们直接使用Nginx内置的$query_string来作为key，$memc_exptime表示缓存失效时间，以秒记。这里统一设为300（5分钟），在实际应用中可以根据具体情况为不同的内容设置不同的过期时间。</p><br><p>最后我们为“~ .php$”这个location配置了缓存，这表示所有以“.php”结尾的请求都会结果被缓存，当然这里只是示例需要，实际中一般不会这么配，而是为特定需要缓存的location配置缓存。</p><br><p>srcache_fetch表示注册一个输入拦截处理器到location，这个配置将在location进入时被执行；而srcache_store表示注册一个输出拦截器到location，当location执行完成并输出时会被执行。注意srcache模块实际可以与任何缓存模块进行配合使用，而不必一定是memc。这里我们以$uri$args作为缓存的key。</p><br><p>经过上述配置后，相当于对Nginx增加了如下逻辑：当所请求的uri以“.php”结尾时，首先到memcache中查询有没有以$uri$args为key的数据，如果有则直接返回；否则，执行location的逻辑，如果返回的http状态码为200，则在输出前以$uri$args为key，将输入结果存入memcache。</p><br><h2>更多配置</h2><br><p>上一节给出了使用memc和srcache构建缓存层的最基本方法，实际应用中可能需要更多灵活的配置，例如为不同的location配置不同的缓存参数，根据返回内容而不是返回的http状态码确定是否缓存等等。可以有很多的方法实现这些需求，例如，srcache还支持两个指令：srcache_fetch_skip和srcache_fetch_skip，这两个指令接受一个参数，当参数已定义且非0时，则进行相应操作，否则不进行。例如，如果配置了srcache_fetch_skip $skip，这条指令，那么只有当$skip的值为非0时，才将结果缓存，如果配合<a href="http://wiki.nginx.org/HttpLuaModule">ngx_lua</a>模块的<a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua">set_by_lua</a>指令，则可以实现复杂的缓存控制。如：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>location /xxxx {<br>    set $key ...;<br>    set_by_lua $skip '<br>        if ngx.var.cookie_foo == "bar" then<br>            return 1<br>        end<br>        return 0<br>    ';<br> <br>    srcache_fetch_skip $skip;<br>    srcache_store_skip $skip;<br> <br>    srcache_fetch GET /memc $key;<br>    srcache_store GET /memc $key;<br><br>    # proxy_pass/fastcgi_pass/...<br>}</pre><br></div><br><p>这表示对/xxxx这个location的访问，只有存在cookie “foo”且值为“bar”时缓存机制才起作用。关于ngx_lua的更多内容请参考其<a href="http://wiki.nginx.org/HttpLuaModule">主页</a>。</p><br><p>另外，我最近在春哥（章亦春在淘宝的昵称）的微博上看到他目前正在完善srcache的功能，为其实现更多<a href="http://tools.ietf.org/pdf/rfc2616.pdf">RFC2616</a>的缓存行为标准。关于这个模块的最新动态可以关注其<a href="https://github.com/agentzh/srcache-nginx-module">github</a>主页。</p><br><h1>Benchmark</h1><br><p>下面对使用memc和srcache构建的缓存机制进行一个简单的benchmark，并与使用PHP操作memcache的策略进行一个对比。为了简单起见，我们的测试PHP脚本不去访问I/O，而仅仅是调用phpinfo函数输出PHP相关信息。</p><br><p>测试一共分三组进行：第一组在Nginx和PHP中均不开启缓存，第二组仅使用PHP memcache缓存，第三组仅使用Nginx memcache缓存。三组都用<a href="http://httpd.apache.org/docs/2.0/programs/ab.html">ab</a>程序去压，并发数为20，请求次数为10000。</p><br><p>这里的测试环境是我的一个虚拟机，操作系统为Ubuntu10，内存512M。Nginx采用epoll，单worker进程，memcache最大并发数为1024，最大使用内存64m。</p><br><h2>不开启缓存</h2><br><p>这一组我们不开启缓存，PHP程序非常简单：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>&lt;?php<br><br>phpinfo();<br><br>?&gt;</pre><br></div><br><p>测试结果如下：</p><br><p><a href="http://images.cnblogs.com/cnblogs_com/leoo2sk/201110/201110022307189103.png"><img style="background-image:none;padding-left:0px;padding-right:0px;display:inline;padding-top:0px;border:0px" title="image" src="http://images.cnblogs.com/cnblogs_com/leoo2sk/201110/201110022307197019.png" alt="image" width="661" height="558" border="0"></a></p><br><h2>PHP memcache缓存策略</h2><br><p>第二组我们用PHP操作缓存，测试脚本为：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>&lt;?php<br><br>$memc = new Memcached;<br>$memc-&gt;addServer(&#39;localhost&#39;, 11211) or die(&#39;Connect to memcache server failed!&#39;);<br><br>$output = $memc-&gt;get(&#39;my_key&#39;);<br>if(empty($output))<br>{<br>    ob_start();<br>    phpinfo();<br>    $output = ob_get_contents();<br>    ob_end_clean();<br><br>    $memc-&gt;set(&#39;my_key&#39;, $output, 300);<br>}<br><br>echo $output;*/<br><br>?&gt;</pre><br></div><br><p>测试结果如下：</p><br><p><a href="http://images.cnblogs.com/cnblogs_com/leoo2sk/201110/201110022307208839.png"><img style="background-image:none;padding-left:0px;padding-right:0px;display:inline;padding-top:0px;border:0px" title="image" src="http://images.cnblogs.com/cnblogs_com/leoo2sk/201110/201110022307213167.png" alt="image" width="659" height="558" border="0"></a></p><br><h2>Nginx memcache缓存策略</h2><br><p>最后，我们将PHP脚本回归到不使用缓存的版本，并配置好memc和srcache缓存机制。测试结果如下：</p><br><p><a href="http://images.cnblogs.com/cnblogs_com/leoo2sk/201110/201110022307233034.png"><img style="background-image:none;padding-left:0px;padding-right:0px;display:inline;padding-top:0px;border:0px" title="image" src="http://images.cnblogs.com/cnblogs_com/leoo2sk/201110/201110022307244539.png" alt="image" width="664" height="564" border="0"></a></p><br><h2>结果对比分析</h2><br><p>为了直观，我取“每秒处理请求数”、“平均每个请求处理时间”和“吞吐率”作为评价指标，制作了一张图表。</p><br><p><a href="http://images.cnblogs.com/cnblogs_com/leoo2sk/201110/201110022307258900.png"><img style="background-image:none;padding-left:0px;padding-right:0px;display:block;float:none;margin-left:auto;margin-right:auto;padding-top:0px;border:0px" title="image" src="http://images.cnblogs.com/cnblogs_com/leoo2sk/201110/201110022307269673.png" alt="image" width="607" height="400" border="0"></a></p><br><p>我想看到图表，结论已毋需我多言。在各项指标上使用memc和srcache构建的缓存机制都大大优于使用PHP操作memcache。其中每秒处理请求数（并发度）和吞吐率都是其9倍左右，而平均个请求所用时间仅有传统策略的1/8。</p><br><p>这里要特别说明一下，这里之所以PHP memcache策略比不使用缓存优势不明显，是因为我们的PHP脚本不涉及I/O操作，如果其中存在如数据库存取，PHP memcache的优势还是有的，但不论如何，Nginx memcache策略在性能上的优势是其无法比拟的。</p><br><p>另外，除了性能优势外，使用这种策略还可以简化PHP逻辑，因为缓存这一层都放在Nginx中了，PHP就从缓存操作中解放了出来，因此是一举多得。</p><br><p>如果你的系统也构建在LNMP上（或LAMP）上，不妨使用本文提到的方法替代传统的缓存策略，尽情享受性能上的提升。</p><br></div><img src="http://www.cnblogs.com/leoo2sk/aggbug/2198012.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/leoo2sk/archive/2011/10/02/nginx-memc-and-srcache.html">本文链接</a></p></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
