<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>GAE1.4尝鲜</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>GAE1.4尝鲜</h2>
<p class="meta">05 Dec 2010</p>

<div class="post">
<h2>GAE1.4尝鲜</h2>

<h3>by</h3>

<h3>at 2010-12-05 11:20:54</h3>

<h3>original <a href="http://www.javaeye.com/topic/833763">http://www.javaeye.com/topic/833763</a></h3>

<p>GAE1.4发布了，带来了很多新的功能。不过我最在意的有两个：一是支持代码下载；二是支持及时通讯（channel api),现在我们来玩玩这两个东西。
<br>
<br><strong>1、代码下载</strong>
<br>
<br>我们一般通过appcfg.py来上传、更新代码，但是没有下载的功能。如果换了一台机器，又看到不代码，真的很窝火。不过，现在GAE提供了，真的很方便，赞一个GAE。下载代码很简单，看一个简单的例子：
<br>
<br><pre name="code">
Usage: appcfg.py [options] download_app -A app_id [ -V version ] &lt;out-dir&gt;
</pre>
<br><pre name="code">
C:\Users\Administrator\Desktop&gt;appcfg.py download_app -A flyingzl -V 2 flyingzl-project
D:\program\python\GAE\appcfg.py:42: DeprecationWarning: the sha module is deprec
ated; use the hashlib module instead
  os.path.join(DIR_PATH, &#39;lib&#39;, &#39;django&#39;),
D:\program\python\GAE\google\appengine\tools\dev_appserver_login.py:33: Deprecat
ionWarning: the md5 module is deprecated; use hashlib instead
  import md5
Server: appengine.google.com.
Fetching file list...
Fetching files...
[1/23] chat.py
[2/23] send_mail.py
[3/23] hello_template.html
[4/23] hello_user.py
...
</pre>
<br>
<br><strong>2、即时通讯支持(channel API)</strong>
<br>
<br>即时通信，即我们常说的comet，用于模拟和远程服务端长连接，常见的技术有轮询（poll）、推送(push)、websocket(html5支持，不过现在大部分服务器还不支持，GAE以后也会支持这个!)。关于后台的实现，各种各样，开源的技术也不少，我们看看google的实现
<br><img src="http://dl.javaeye.com/upload/attachment/361066/cb93e098-efa6-3d6f-8300-4b30e5807bd6.png">
<br>
<br>从图可以看出，在我们和GAE进行通信时，中间其实还有一个基于XMLPP的google talk，我们每次通信首先走的是google talk然后google talk再和gae进行通信。。。在之后的列子中，通过firebug的console我们可以看到加载google talk脚本的过程。
<br>
<br>接着看图：
<br>
<br><img src="http://dl.javaeye.com/upload/attachment/361068/c06a3356-a512-3513-9451-3dcd96be5f25.png">
<br>
<br>可以看到，在browser端，我们是和在一个看不到的iframe在通信，我们把数据传给这个隐藏的iframe，然后iframe再和google talk通信，然后再和GAE通信，貌似有点小复杂。不过没有关系，这些都是对用户透明的。说了这么多废话，直接看api，哈哈
<br>
<br><img src="http://dl.javaeye.com/upload/attachment/361071/f61f5464-1119-3438-905a-e52300674c79.png">
<br>
<br>如果大家熟悉html5的websocket，可以看到channel api的实现完全和websocket一致。
<br>
<br><img src="http://dl.javaeye.com/upload/attachment/361073/8f0fb904-6fd5-3d36-9473-68f5c1a9bcd6.png">
<br>
<br>很简单吧，现在我们做一个样例，就是做一个非常简单的聊天室。有兴趣的童鞋可以好好改造下，界面如下：
<br>
<br><img src="http://dl.javaeye.com/upload/attachment/361077/b5cbcbf2-38cb-3fe1-86dc-e95151b76432.png">
<br>
<br><strong>3、代码实现聊天室</strong>
<br>
<br>首先创建服务端
<br><pre name="code"></p>

<h1>coding=utf-8</h1>

<p>&#39;&#39;&#39;
Created on 2010-12-4
@author: flyingzl
&#39;&#39;&#39;
from google.appengine.ext import webapp
from google.appengine.ext.webapp import util,template
from google.appengine.api import channel
from hashlib import md5
import time</p>

<p>class Chat(webapp.RequestHandler):</p>

<pre><code>def get(self):
    self.response.headers[&amp;#39;Content-Type&amp;#39;]=&amp;#39;text/html;charset=utf-8&amp;#39;
    key=md5(&amp;#39;1234567890&amp;#39;).hexdigest()
    client_id=channel.create_channel(key)
    self.response.out.write(template.render(&amp;quot;templates/chat.html&amp;quot;, {&amp;#39;channel_id&amp;#39;:client_id}))
</code></pre>

<p>class ChatSender(webapp.RequestHandler):
    def get(self):
        self.response.headers[&#39;Content-Type&#39;]=&#39;text/html;charset=utf-8&#39;
        self.error(500)
        self.response.out.write(&#39;只支持Post请求&#39;)</p>

<pre><code>def post(self):
    key=md5(&amp;#39;1234567890&amp;#39;).hexdigest()
    message=self.request.get(&amp;#39;message&amp;#39;,&amp;#39;&amp;#39;)
    now=time.strftime(&amp;quot;%Y-%m-%d %H:%M:%S&amp;quot;)
    ip=self.request.environ[&amp;#39;REMOTE_ADDR&amp;#39;]
    try:
        channel.send_message(key, &amp;quot;%s(%s)--&amp;gt;%s&amp;quot;%(ip,now,message))
    except channel.InvalidChannelClientIdError:
        self.error(500)
        self.response.out.write(&amp;quot;Channel标识符不合法&amp;quot;)
    except channel.InvalidMessageError:
        self.error(500)
        self.response.out.write(&amp;quot;发送的消息太长，最大长度不能超过&amp;quot;)+channel.MAXIMUM_MESSAGE_LENGTH+&amp;quot;个字节&amp;quot;
</code></pre>

<p>def main():
    app=webapp.WSGIApplication([(&#39;/chat&#39;,Chat),(&#39;/chat/sender&#39;,ChatSender)],debug=True);
    util.run_wsgi_app(app)</p>

<p>if <strong>name</strong>==&#39;<strong>main</strong>&#39;:
    main()
</pre>
<br>
<br>代码比较简单，主要有两个过程，一个是创建channel，另外一个是通过channel发送消息。
<br>
<br>再看看客户端:
<br>
<br><pre name="code">
&lt;!doctype&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;/meta&gt;
        &lt;title&gt;Chat&lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            #mainDiv{
                width:600px;
                height:400px;
                padding:5px;
                margin:10px auto;
                border:1px solid lightblue;
            }</p>

<pre><code>        #message{
            width:100%;
            height:370px;
            margin-bottom:5px;
        }

        #userMessage{
            width:450px;
            margin-right:2px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;mainDiv&amp;quot;&amp;gt;
        &amp;lt;textarea id=&amp;#39;message&amp;#39;&amp;gt;&amp;lt;/textarea&amp;gt;
        &amp;lt;input id=&amp;quot;userMessage&amp;quot;  /&amp;gt;&amp;lt;button id=&amp;#39;btn&amp;#39; disabled onClick=&amp;quot;sendMessage()&amp;quot;&amp;gt;正在连接服务器……&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;/_ah/channel/jsapi&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;/js/jquery-1.4.2.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
        var channel_id=&amp;#39;&amp;#39;,
            timeoutID=&amp;#39;&amp;#39;;
        $(function(){
            var channel=new goog.appengine.Channel(channel_id),
                socket=channel.open();
            socket.onopen=function(){
                $(&amp;#39;#btn&amp;#39;).html(&amp;quot;发送&amp;quot;).removeAttr(&amp;#39;disabled&amp;#39;);
            }

            socket.onmessage=function(data){
                var message=$(&amp;quot;#message&amp;quot;).val();
                $.trim(message)?$(&amp;quot;#message&amp;quot;).val(message+&amp;quot;\n&amp;quot;+data.data):$(&amp;quot;#message&amp;quot;).val(data.data);
            }

        });

        function sendMessage(message){
            if(timeoutID){
                alert(&amp;quot;您发送的太快了，休息一下下……&amp;quot;);
                return;
            }
            var message=$(&amp;#39;#userMessage&amp;#39;).val();
            if(!$.trim(message)){
                alert(&amp;quot;请输入要发送的消息!&amp;quot;);
                $(&amp;#39;#userMessage&amp;#39;).focus();
                return;
            }
            $.ajax({
                type:&amp;#39;POST&amp;#39;,
                data:&amp;quot;message=&amp;quot;+message,
                url:&amp;#39;/chat/sender&amp;#39;,
                error:function(err){
                    alert(err.responseText);
                }
            });
            $(&amp;#39;#userMessage&amp;#39;).val(&amp;#39;&amp;#39;)
            timeoutID=setTimeout(function(){
                timeoutID=&amp;#39;&amp;#39;;
            },500);
        }

    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
</code></pre>

<p>&lt;/html&gt;
</pre>
<br>
<br>创建channel的过程是不是和websocket很像？我们只需要监听onopen、onmessage就可以获得服务器传来的消息；不过我有点没搞明白，为什么不可以像websocket那样通过socket.send方法发送数到远程呢？或许本身gae就支持的不好。
<br>
<br>到此，一个简单的聊天室就做好了，几行代码，就完成了一个我们之前要花费很大气力才能做完的，GAE真的是太赞了，继续关注！
<br>
<br>代码本身很简单，我就不上传代码了。大家看明白就可以咯！祝大家周末愉快~~</p>

<p>  <br><br>
  <ul>
    本文附件下载:</p>

<pre><code>  &lt;li&gt;&lt;a href="http://dl.javaeye.com/topics/download/4e36b6c5-9d01-3460-b06c-b581fcd8308f"&gt;googleapis-building-real-time-apps-app-engine-feed-api.pdf&lt;/a&gt; (821.5 KB)&lt;/li&gt;
</code></pre>

<p>  </ul></p>

<pre><code>      &lt;br&gt;&lt;br&gt;
      作者: &lt;a href="http://flyingzl.javaeye.com"&gt;flyingzl&lt;/a&gt; 
      &lt;br&gt;
      声明: 本文系JavaEye网站发布的原创文章，未经作者书面许可，严禁任何网站转载本文，否则必将追究法律责任！
      &lt;br&gt;&lt;br&gt;
      &lt;span style="color:red"&gt;
        &lt;a href="http://www.javaeye.com/topic/833763" style="color:red"&gt;已有 &lt;strong&gt;0&lt;/strong&gt; 人发表回复，猛击-&amp;gt;&amp;gt;&lt;strong&gt;这里&lt;/strong&gt;&amp;lt;&amp;lt;-参与讨论&lt;/a&gt;
      &lt;/span&gt;
      &lt;br&gt;&lt;br&gt;&lt;br&gt;
</code></pre>

<p><span style="color:#e28822">JavaEye推荐</span>
<br></p>

<ul><li><a href="http://www.iteye.com/clicks/433"><span style="color:red;font-weight:bold">—软件人才免语言低担保 赴美带薪读研！— </span></a></li></ul>


<p><br><br><br></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
