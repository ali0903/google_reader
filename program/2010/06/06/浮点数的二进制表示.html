<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>浮点数的二进制表示</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>浮点数的二进制表示</h2>
<p class="meta">06 Jun 2010</p>

<div class="post">
<h2>浮点数的二进制表示</h2>

<h3>by</h3>

<h3>at 2010-06-06 12:42:18</h3>

<h3>original <a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html</a></h3>

<p>1.</p>




<p>前几天，我在读一本C语言教材，有一道例题：</p>


<blockquote>

<p><strong>　　#include &lt;stdio.h&gt;</strong></p>

<p><strong>　　void main(void){</strong></p>

<p><strong>　　　　int num=9;</strong> <em>/* num是整型变量，设为9 */</em></p>

<p><strong>　　　　float* pFloat=&amp;num;</strong><em> /* pFloat表示num的内存地址，但是设为浮点数 */</em></p>

<p><strong>　　　　printf("num的值为：%d\n",num);</strong> <em>/* 显示num的整型值 */</em></p>

<p><strong>　　　　printf("*pFloat的值为：%f\n",*pFloat); </strong><em>/* 显示num的浮点值 */</em></p>

<p><strong>　　　　*pFloat=9.0;</strong> <em>/* 将num的值改为浮点数 */</em></p>

<p><strong>　　　　printf("num的值为：%d\n",num); </strong><em>/* 显示num的整型值 */</em></p>

<p><strong>　　　　printf("*pFloat的值为：%f\n",*pFloat);</strong><em> /* 显示num的浮点值 */</em></p>

<p><strong>　　}</strong></p>

</blockquote>




<p>运行结果如下：</p>




<blockquote>

<p><strong>　　num的值为：9</strong><br>
<strong>　　*pFloat的值为：0.000000</strong><br>
<strong>　　num的值为：1091567616</strong><br>
<strong>　　*pFloat的值为：9.000000</strong></p>

</blockquote>




<p>我很惊讶，num和*pFloat在内存中明明是同一个数，为什么浮点数和整数的解读结果会差别这么大？</p>




<p>要理解这个结果，一定要搞懂浮点数在计算机内部的表示方法。我读了一些资料，下面就是我的笔记。</p>




<p>2.</p>




<p>在讨论浮点数之前，先看一下整数在计算机内部是怎样表示的。</p>




<blockquote>

<p><strong>　　int num=9;</strong></p>

</blockquote>




<p>上面这条命令，声明了一个整数变量，类型为int，值为9（二进制写法为1001）。普通的32位计算机，用4个字节表示int变量，所以9就被保存为00000000 00000000 00000000 00001001，写成16进制就是0x00000009。</p>




<p>那么，我们的问题就简化成：<strong>为什么0x00000009还原成浮点数，就成了0.000000？</strong></p>




<p>3.</p>




<p>根据国际标准IEEE 754，任意一个二进制浮点数V可以表示成下面的形式：</p>




<blockquote>

<p><strong>　　V = (-1)^s×M×2^E</strong></p>

<p><strong>　　（1）(-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。</strong></p>

<p><strong>　　（2）M表示有效数字，大于等于1，小于2。</strong></p>

<p><strong>　　（3）2^E表示指数位。</strong></p>

</blockquote>




<p>举例来说，十进制的5.0，写成二进制是101.0，相当于1.01×2^2。那么，按照上面V的格式，可以得出s=0，M=1.01，E=2。</p>




<p>十进制的-5.0，写成二进制是-101.0，相当于-1.01×2^2。那么，s=1，M=1.01，E=2。</p>




<p>IEEE 754规定，对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。</p>




<p><img src="http://image.beekka.com/blog/201006/bg2010060601.png"></p>




<p>对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。</p>




<p><img src="http://image.beekka.com/blog/201006/bg2010060602.png"></p>




<p>5.</p>




<p>IEEE 754对有效数字M和指数E，还有一些特别规定。</p>




<p>前面说过，1≤M&lt;2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。<strong>IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。</strong>比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。</p>




<p>至于指数E，情况就比较复杂。</p>




<p>首先，E为一个无符号整数（unsigned int）。这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，<strong>所以IEEE 754规定，E的真实值必须再减去一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。</strong></p>




<p>比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。</p>




<p>然后，指数E还可以再分成三种情况：</p>




<p><strong>（1）E不全为0或不全为1。</strong>这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。</p>




<p><strong>（2）E全为0。</strong>这时，浮点数的指数E等于1-127（或者1-1023），有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。</p>




<p><strong>（3）E全为1。</strong>这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。</p>




<p>6.</p>




<p>好了，关于浮点数的表示规则，就说到这里。</p>




<p>下面，让我们回到一开始的问题：<strong>为什么0x00000009还原成浮点数，就成了0.000000？</strong></p>




<p>首先，将0x00000009拆分，得到第一位符号位s=0，后面8位的指数E=00000000，最后23位的有效数字M=000 0000 0000 0000 0000 1001。</p>




<p>由于指数E全为0，所以符合上一节的第二种情况。因此，浮点数V就写成：</p>




<blockquote>

<p>　　V=(-1)^0×0.00000000000000000001001×2^(-126)=1.001×2^(-146)</p>

</blockquote>




<p>显然，V是一个很小的接近于0的正数，所以用十进制小数表示就是0.000000。</p>




<p>7.</p>




<p>再看例题的第二部分。</p>




<p><strong>请问浮点数9.0，如何用二进制表示？还原成十进制又是多少？</strong></p>




<p>首先，浮点数9.0等于二进制的1001.0，即1.001×2^3。</p>




<p>那么，第一位的符号位s=0，有效数字M等于001后面再加20个0，凑满23位，指数E等于3+127=130，即10000010。</p>




<p>所以，写成二进制形式，应该是s+E+M，即0 10000010 001 0000 0000 0000 0000 0000。这个32位的二进制数，还原成十进制，正是1091567616。</p>




<p>（完）</p>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
