<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>关于数组的几道面试题</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>关于数组的几道面试题</h2>
<p class="meta">2010-08-24 20:58</p>

<div class="post">
<h2>关于数组的几道面试题</h2>

<h3>by zdd</h3>

<h3>at 2010-08-24 12:58:00</h3>

<h3>original <a href="http://www.cnblogs.com/graphics/archive/2010/08/24/1761620.html">http://www.cnblogs.com/graphics/archive/2010/08/24/1761620.html</a></h3>

<p><a href="http://www.cnblogs.com/graphics/"><img src="http://pic.cnblogs.com/face/u64257.bmp" alt="" border="0"></a><br>作者: <a href="http://www.cnblogs.com/graphics/">zdd</a> 发表于 2010-08-24 12:58 <a href="http://www.cnblogs.com/graphics/archive/2010/08/24/1761620.html">原文链接</a> 阅读: 1167 评论: 17</p>


<p>数组是最基本的数据结构，关于数组的面试题也屡见不鲜，本文罗列了一些常见的面试题，仅供参考，如果您有更好的题目或者想法，欢迎留言讨论。</p>


<h1>数组求和</h1>


<p>给定一个含有n个元素的整型数组a，求a中所有元素的和。可能您会觉得很简单，是的，的确简单，但是为什么还要说呢，原因有二，第一，这道题要求用递归法，只用一行代码。第二，这是我人生中第一次面试时候遇到的题，意义特殊。</p>


<h2>分析</h2>


<p>简单说一下，两种情况</p>


<p>1. 如果数组元素个数为0，那么和为0。</p>


<p>2. 如果数组元素个数为n，那么先求出前n - 1个元素之和，再加上a[n - 1]即可</p>


<h2>代码</h2>


<div>
<pre><div><span style="color:#008000">//</span><span style="color:#008000"> 数组求和</span><span style="color:#008000"><br></span><span style="color:#0000ff">int</span><span style="color:#000000"> sum(</span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">a, </span><span style="color:#0000ff">int</span><span style="color:#000000"> n)<br>{<br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> n </span><span style="color:#000000">==</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000"> </span><span style="color:#000000">?</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000"> : sum(a, n </span><span style="color:#000000">-</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">) </span><span style="color:#000000">+</span><span style="color:#000000"> a[n </span><span style="color:#000000">-</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">];<br>}</span></div></pre>
</div>


<h1>求数组的最大值和最小值</h1>


<p>给定一个含有n个元素的整型数组a，找出其中的最大值和最小值</p>


<h2>分析</h2>


<p>常规的做法是遍历一次，分别求出最大值和最小值，但我这里要说的是分治法(Divide and couquer)，将数组分成左右两部分，先求出左半部份的最大值和最小值，再求出右半部份的最大值和最小值，然后综合起来求总体的最大值及最小值。这是个递归过程，对于划分后的左右两部分，同样重复这个过程，直到划分区间内只剩一个元素或者两个元素。</p>


<h2>代码</h2>


<div><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span>代码</span>
<div>
<pre><div><span style="color:#008000">//</span><span style="color:#008000"> 求数组的最大值和最小值，返回值在maxValue和minValue</span><span style="color:#008000"><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> MaxandMin(</span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">a, </span><span style="color:#0000ff">int</span><span style="color:#000000"> l, </span><span style="color:#0000ff">int</span><span style="color:#000000"> r, </span><span style="color:#0000ff">int</span><span style="color:#000000">&amp;</span><span style="color:#000000"> maxValue, </span><span style="color:#0000ff">int</span><span style="color:#000000">&amp;</span><span style="color:#000000"> minValue)<br>{<br>    </span><span style="color:#0000ff">if</span><span style="color:#000000">(l </span><span style="color:#000000">==</span><span style="color:#000000"> r)    </span><span style="color:#008000">//</span><span style="color:#008000"> l与r之间只有一个元素</span><span style="color:#008000"><br></span><span style="color:#000000">    {<br>        maxValue </span><span style="color:#000000">=</span><span style="color:#000000"> a[l] ;<br>        minValue </span><span style="color:#000000">=</span><span style="color:#000000"> a[l] ;<br>        </span><span style="color:#0000ff">return</span><span style="color:#000000"> ;<br>    }<br><br>    </span><span style="color:#0000ff">if</span><span style="color:#000000">(l </span><span style="color:#000000">+</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000"> </span><span style="color:#000000">==</span><span style="color:#000000"> r) </span><span style="color:#008000">//</span><span style="color:#008000"> l与r之间只有两个元素</span><span style="color:#008000"><br></span><span style="color:#000000">    {<br>        </span><span style="color:#0000ff">if</span><span style="color:#000000">(a[l] </span><span style="color:#000000">&gt;=</span><span style="color:#000000"> a[r])<br>        {<br>            maxValue </span><span style="color:#000000">=</span><span style="color:#000000"> a[l] ;<br>            minValue </span><span style="color:#000000">=</span><span style="color:#000000"> a[r] ;<br>        }<br>        </span><span style="color:#0000ff">else</span><span style="color:#000000"><br>        {<br>            maxValue </span><span style="color:#000000">=</span><span style="color:#000000"> a[r] ;<br>            minValue </span><span style="color:#000000">=</span><span style="color:#000000"> a[l] ;<br>        }<br>        </span><span style="color:#0000ff">return</span><span style="color:#000000"> ;<br>    }<br><br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> m </span><span style="color:#000000">=</span><span style="color:#000000"> (l </span><span style="color:#000000">+</span><span style="color:#000000"> r) </span><span style="color:#000000">/</span><span style="color:#000000"> </span><span style="color:#800080">2</span><span style="color:#000000"> ; </span><span style="color:#008000">//</span><span style="color:#008000"> 求中点</span><span style="color:#008000"><br></span><span style="color:#000000"><br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> lmax ; </span><span style="color:#008000">//</span><span style="color:#008000"> 左半部份最大值</span><span style="color:#008000"><br></span><span style="color:#000000">    </span><span style="color:#0000ff">int</span><span style="color:#000000"> lmin ; </span><span style="color:#008000">//</span><span style="color:#008000"> 左半部份最小值</span><span style="color:#008000"><br></span><span style="color:#000000">    MaxandMin(a, l, m, lmax, lmin) ;        </span><span style="color:#008000">//</span><span style="color:#008000"> 递归计算左半部份</span><span style="color:#008000"><br></span><span style="color:#000000"><br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> rmax ; </span><span style="color:#008000">//</span><span style="color:#008000"> 右半部份最大值</span><span style="color:#008000"><br></span><span style="color:#000000">    </span><span style="color:#0000ff">int</span><span style="color:#000000"> rmin ; </span><span style="color:#008000">//</span><span style="color:#008000"> 右半部份最小值</span><span style="color:#008000"><br></span><span style="color:#000000">    MaxandMin(a, m </span><span style="color:#000000">+</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">, r, rmax, rmin) ;    </span><span style="color:#008000">//</span><span style="color:#008000"> 递归计算右半部份</span><span style="color:#008000"><br></span><span style="color:#000000"><br>    maxValue </span><span style="color:#000000">=</span><span style="color:#000000"> max(lmax, rmax) ; </span><span style="color:#008000">//</span><span style="color:#008000"> 总的最大值</span><span style="color:#008000"><br></span><span style="color:#000000">    minValue </span><span style="color:#000000">=</span><span style="color:#000000"> min(lmin, rmin) ; </span><span style="color:#008000">//</span><span style="color:#008000"> 总的最小值</span><span style="color:#008000"><br></span><span style="color:#000000">}</span></div></pre>
</div>
</div>


<h1>求数组的最大值和次大值</h1>


<p>给定一个含有n个元素的整型数组，求其最大值和次大值</p>


<h2>分析</h2>


<p>思想和上一题类似，同样是用分治法，不多说了，直接看代码</p>


<h2>代码</h2>


<div><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span>代码</span>
<div>
<pre><div><span style="color:#008000">//</span><span style="color:#008000"> 求数组的最大值和次大值，返回值在max和second中</span><span style="color:#008000"><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> MaxandMin(</span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">a, </span><span style="color:#0000ff">int</span><span style="color:#000000"> left, </span><span style="color:#0000ff">int</span><span style="color:#000000"> right, </span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">&amp;</span><span style="color:#000000">max, </span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">&amp;</span><span style="color:#000000">second)<br>{<br>    </span><span style="color:#0000ff">if</span><span style="color:#000000">(left </span><span style="color:#000000">==</span><span style="color:#000000"> right)<br>    {<br>        max </span><span style="color:#000000">=</span><span style="color:#000000"> a[left] ;<br>        second </span><span style="color:#000000">=</span><span style="color:#000000"> a[left] ;<br>    }<br>    </span><span style="color:#0000ff">else</span><span style="color:#000000"> </span><span style="color:#0000ff">if</span><span style="color:#000000">(left </span><span style="color:#000000">+</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000"> </span><span style="color:#000000">==</span><span style="color:#000000"> right)<br>    {<br>        max </span><span style="color:#000000">=</span><span style="color:#000000"> a[left] </span><span style="color:#000000">&gt;</span><span style="color:#000000"> a[right] </span><span style="color:#000000">?</span><span style="color:#000000"> a[left] : a[right] ;<br>        second </span><span style="color:#000000">=</span><span style="color:#000000"> a[left] </span><span style="color:#000000">&lt;</span><span style="color:#000000"> a[right] </span><span style="color:#000000">?</span><span style="color:#000000"> a[left] : a[right] ;<br>    }<br>    </span><span style="color:#0000ff">else</span><span style="color:#000000"><br>    {<br>        </span><span style="color:#0000ff">int</span><span style="color:#000000"> mid </span><span style="color:#000000">=</span><span style="color:#000000"> left </span><span style="color:#000000">+</span><span style="color:#000000"> (right </span><span style="color:#000000">-</span><span style="color:#000000"> left) </span><span style="color:#000000">/</span><span style="color:#000000"> </span><span style="color:#800080">2</span><span style="color:#000000"> ;<br><br>        </span><span style="color:#0000ff">int</span><span style="color:#000000"> leftmax ;<br>        </span><span style="color:#0000ff">int</span><span style="color:#000000"> leftmin ;<br>        MaxandMin(a, left, mid, leftmax, leftmin) ;<br><br>        </span><span style="color:#0000ff">int</span><span style="color:#000000"> rightmax ;<br>        </span><span style="color:#0000ff">int</span><span style="color:#000000"> rightmin ;<br>        MaxandMin(a, mid </span><span style="color:#000000">+</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">, right, rightmax, rightmin) ;<br><br>        max </span><span style="color:#000000">=</span><span style="color:#000000"> leftmax </span><span style="color:#000000">&gt;</span><span style="color:#000000"> rightmax </span><span style="color:#000000">?</span><span style="color:#000000"> leftmax : rightmax ;<br>        second </span><span style="color:#000000">=</span><span style="color:#000000"> leftmax </span><span style="color:#000000">&lt;</span><span style="color:#000000"> rightmax </span><span style="color:#000000">?</span><span style="color:#000000"> leftmax : rightmax ;<br>    }<br>}<br></span></div></pre>
</div>
</div>


<h1>求数组中出现次数超过一半的元素</h1>


<p>给定一个n个整型元素的数组a，其中有一个元素出现次数超过n / 2，求这个元素。据说是百度的一道题</p>


<h2>分析</h2>


<p>设置一个当前值和当前值的计数器，初始化当前值为数组首元素，计数器值为1，然后从第二个元素开始遍历整个数组，对于每个被遍历到的值a[i]</p>


<p>1 如果a[i]==currentValue，则计数器值加1</p>


<p>2 如果a[i] != currentValue， 则计数器值减1，如果计数器值小于0，则更新当前值为a[i]，并将计数器值重置为1</p>


<h2>代码</h2>


<div><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span>代码</span>
<div>
<pre><div><span style="color:#008000">//</span><span style="color:#008000"> 找出数组中出现次数超过一半的元素</span><span style="color:#008000"><br></span><span style="color:#0000ff">int</span><span style="color:#000000"> Find(</span><span style="color:#0000ff">int</span><span style="color:#000000">*</span><span style="color:#000000"> a, </span><span style="color:#0000ff">int</span><span style="color:#000000"> n)<br>{<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> curValue </span><span style="color:#000000">=</span><span style="color:#000000"> a[</span><span style="color:#800080">0</span><span style="color:#000000">] ;<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> count </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000"> ;<br><br>    </span><span style="color:#0000ff">for</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000"> i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">; i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> n; </span><span style="color:#000000">++</span><span style="color:#000000">i)<br>    {<br>        </span><span style="color:#0000ff">if</span><span style="color:#000000"> (a[i] </span><span style="color:#000000">==</span><span style="color:#000000"> curValue)<br>            count</span><span style="color:#000000">++</span><span style="color:#000000"> ;<br>        </span><span style="color:#0000ff">else</span><span style="color:#000000"><br>        {<br>            count</span><span style="color:#000000">--</span><span style="color:#000000"> ;<br>            </span><span style="color:#0000ff">if</span><span style="color:#000000"> (count </span><span style="color:#000000">&lt;</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">)<br>            {<br>                curValue </span><span style="color:#000000">=</span><span style="color:#000000"> a[i] ;<br>                count </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000"> ;<br>            }<br>        }<br>    }<br><br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> curValue ;<br>}</span></div></pre>
</div>
</div>


<p>另一个方法是先对数组排序，然后取中间元素即可，因为如果某个元素的个数超过一半，那么数组排序后该元素必定占据数组的中间位置。</p>


<h1>求数组中元素的最短距离</h1>


<p>给定一个含有n个元素的整型数组，找出数组中的两个元素x和y使得abs(x - y)值最小</p>


<h2>分析</h2>


<p>先对数组排序，然后遍历一次即可</p>


<h2>代码</h2>


<div><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span>代码</span>
<div>
<pre><div><span style="color:#0000ff">int</span><span style="color:#000000"> compare(</span><span style="color:#0000ff">const</span><span style="color:#000000"> </span><span style="color:#0000ff">void</span><span style="color:#000000">*</span><span style="color:#000000"> a, </span><span style="color:#0000ff">const</span><span style="color:#000000"> </span><span style="color:#0000ff">void</span><span style="color:#000000">*</span><span style="color:#000000"> b)<br>{<br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">(</span><span style="color:#0000ff">int</span><span style="color:#000000">*</span><span style="color:#000000">)a </span><span style="color:#000000">-</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">(</span><span style="color:#0000ff">int</span><span style="color:#000000">*</span><span style="color:#000000">)b ;<br>}<br><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> MinimumDistance(</span><span style="color:#0000ff">int</span><span style="color:#000000">*</span><span style="color:#000000"> a, </span><span style="color:#0000ff">int</span><span style="color:#000000"> n)<br>{<br>    </span><span style="color:#008000">//</span><span style="color:#008000"> Sort</span><span style="color:#008000"><br></span><span style="color:#000000">    qsort(a, n, </span><span style="color:#0000ff">sizeof</span><span style="color:#000000">(</span><span style="color:#0000ff">int</span><span style="color:#000000">), compare) ;<br><br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> i ; </span><span style="color:#008000">//</span><span style="color:#008000"> Index of number 1</span><span style="color:#008000"><br></span><span style="color:#000000">    </span><span style="color:#0000ff">int</span><span style="color:#000000"> j ; </span><span style="color:#008000">//</span><span style="color:#008000"> Index of number 2</span><span style="color:#008000"><br></span><span style="color:#000000"><br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> minDistance </span><span style="color:#000000">=</span><span style="color:#000000"> numeric_limits</span><span style="color:#000000">&lt;</span><span style="color:#0000ff">int</span><span style="color:#000000">&gt;</span><span style="color:#000000">::max() ;<br>    </span><span style="color:#0000ff">for</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000"> k </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">; k </span><span style="color:#000000">&lt;</span><span style="color:#000000"> n </span><span style="color:#000000">-</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">; </span><span style="color:#000000">++</span><span style="color:#000000">k)<br>    {<br>        </span><span style="color:#0000ff">if</span><span style="color:#000000"> (a[k </span><span style="color:#000000">+</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">] </span><span style="color:#000000">-</span><span style="color:#000000"> a[k] </span><span style="color:#000000">&lt;</span><span style="color:#000000"> minDistance)<br>        {<br>            minDistance </span><span style="color:#000000">=</span><span style="color:#000000"> a[k </span><span style="color:#000000">+</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">] </span><span style="color:#000000">-</span><span style="color:#000000"> a[k] ;<br>            i </span><span style="color:#000000">=</span><span style="color:#000000"> a[k] ;<br>            j </span><span style="color:#000000">=</span><span style="color:#000000"> a[k </span><span style="color:#000000">+</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">] ;<br>        }<br>    }<br><br>    cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> </span><span style="color:#800000">"</span><span style="color:#800000">Minimum distance is: </span><span style="color:#800000">"</span><span style="color:#000000"> </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> minDistance </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> endl ;<br>    cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> </span><span style="color:#800000">"</span><span style="color:#800000">i = </span><span style="color:#800000">"</span><span style="color:#000000"> </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> i </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> </span><span style="color:#800000">"</span><span style="color:#800000"> j = </span><span style="color:#800000">"</span><span style="color:#000000"> </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> j </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> endl ;<br>}</span></div></pre>
</div>
</div>


<h1>求两个有序数组的共同元素</h1>


<p>给定两个含有n个元素的有序（非降序）整型数组a和b，求出其共同元素，比如</p>


<p>a = 0, 1, 2, 3, 4</p>


<p>b = 1, 3, 5, 7, 9</p>


<p>输出 1, 3</p>


<h2>分析</h2>


<p>充分利用数组有序的性质，用两个指针i和j分别指向a和b，比较a[i]和b[j]，根据比较结果移动指针，则有如下三种情况</p>


<p>1. a[i] &lt; b[j]，则i增加1，继续比较</p>


<p>2. a[i] == b[j]，则i和j皆加1，继续比较</p>


<p>3. a[i] &lt; b[j]，则j加1，继续比较</p>


<p>重复以上过程直到i或j到达数组末尾。</p>


<h2>代码</h2>


<div><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span>代码</span>
<div>
<pre><div><span style="color:#008000">//</span><span style="color:#008000"> 找出两个数组的共同元素</span><span style="color:#008000"><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> FindCommon(</span><span style="color:#0000ff">int</span><span style="color:#000000">*</span><span style="color:#000000"> a, </span><span style="color:#0000ff">int</span><span style="color:#000000">*</span><span style="color:#000000"> b, </span><span style="color:#0000ff">int</span><span style="color:#000000"> n)<br>{<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">; <br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> j </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000"> ;<br><br>    </span><span style="color:#0000ff">while</span><span style="color:#000000"> (i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> n </span><span style="color:#000000">&amp;&amp;</span><span style="color:#000000"> j </span><span style="color:#000000">&lt;</span><span style="color:#000000"> n)<br>    {<br>        </span><span style="color:#0000ff">if</span><span style="color:#000000"> (a[i] </span><span style="color:#000000">&lt;</span><span style="color:#000000"> b[j])<br>            </span><span style="color:#000000">++</span><span style="color:#000000">i ;<br>        </span><span style="color:#0000ff">else</span><span style="color:#000000"> </span><span style="color:#0000ff">if</span><span style="color:#000000">(a[i] </span><span style="color:#000000">==</span><span style="color:#000000"> b[j])<br>        {<br>            cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> a[i] </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> endl ;<br>            </span><span style="color:#000000">++</span><span style="color:#000000">i ;<br>            </span><span style="color:#000000">++</span><span style="color:#000000">j ;<br>        }<br>        </span><span style="color:#0000ff">else</span><span style="color:#008000">//</span><span style="color:#008000"> a[i] &gt; b[j]</span><span style="color:#008000"><br></span><span style="color:#000000">            </span><span style="color:#000000">++</span><span style="color:#000000">j ;<br>    }<br>}</span></div></pre>
</div>
</div>


<p>这到题还有其他的解法，比如对于a中任意一个元素，在b中对其进行Binary Search，因为a中有n个元素，而在b中进行Binary Search需要logn。所以找出全部相同元素的时间复杂度是O(nlogn)。</p>


<p>另外，上面的方法，只要b有序即可，a是否有序无所谓，因为我们只是在b中做Binary Search。如果a也有序的话，那么再用上面的方法就有点慢了，因为如果a中某个元素在b中的位置是k的话，那么a中下一个元素在b中的位置一定位于k的右侧，所以本次的搜索空间可以根据上次的搜索结果缩小，而不是仍然在整个b中搜索。也即如果a和b都有序的话，代码可以做如下修改，记录上次搜索时b中元素的位置，作为下一次搜索的起始点。</p>


<h1>求三个数组的共同元素</h1>


<p>给定三个含有n个元素的整型数组a,b和c，求他们最小的共同元素</p>


<h2>分析</h2>


<p>如果三个数组都有序，那么可以设置三个指针指向三个数组的头部，然后根据这三个指针所指的值进行比较来移动指针，直道找到共同元素。</p>


<h2>代码</h2>


<div><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span>代码</span>
<div>
<pre><div><span style="color:#008000">//</span><span style="color:#008000"> 三个数组的共同元素-只找最小的</span><span style="color:#008000"><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> FindCommonElements(</span><span style="color:#0000ff">int</span><span style="color:#000000"> a[], </span><span style="color:#0000ff">int</span><span style="color:#000000"> b[], </span><span style="color:#0000ff">int</span><span style="color:#000000"> c[], </span><span style="color:#0000ff">int</span><span style="color:#000000"> x, </span><span style="color:#0000ff">int</span><span style="color:#000000"> y, </span><span style="color:#0000ff">int</span><span style="color:#000000"> z)<br>{<br>    </span><span style="color:#0000ff">for</span><span style="color:#000000">(</span><span style="color:#0000ff">int</span><span style="color:#000000"> i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">, j </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">, k </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">; i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> x </span><span style="color:#000000">&amp;&amp;</span><span style="color:#000000"> j </span><span style="color:#000000">&lt;</span><span style="color:#000000"> y </span><span style="color:#000000">&amp;&amp;</span><span style="color:#000000"> k </span><span style="color:#000000">&lt;</span><span style="color:#000000"> z;)<br>    {<br>        </span><span style="color:#0000ff">if</span><span style="color:#000000">(a[i] </span><span style="color:#000000">&lt;</span><span style="color:#000000"> b[j])<br>        {<br>            i</span><span style="color:#000000">++</span><span style="color:#000000"> ;<br>        }<br>        </span><span style="color:#0000ff">else</span><span style="color:#000000"> </span><span style="color:#008000">//</span><span style="color:#008000"> a[i] &gt;= b[j]</span><span style="color:#008000"><br></span><span style="color:#000000">        {<br>            </span><span style="color:#0000ff">if</span><span style="color:#000000">(b[j] </span><span style="color:#000000">&lt;</span><span style="color:#000000"> c[k])<br>            {<br>                j</span><span style="color:#000000">++</span><span style="color:#000000"> ;<br>            }<br>            </span><span style="color:#0000ff">else</span><span style="color:#000000"> </span><span style="color:#008000">//</span><span style="color:#008000"> b[j] &gt;= c[k]</span><span style="color:#008000"><br></span><span style="color:#000000">            {<br>                </span><span style="color:#0000ff">if</span><span style="color:#000000">(c[k] </span><span style="color:#000000">&lt;</span><span style="color:#000000"> a[i])<br>                {<br>                    k</span><span style="color:#000000">++</span><span style="color:#000000"> ;<br>                }<br>                </span><span style="color:#0000ff">else</span><span style="color:#000000"> </span><span style="color:#008000">//</span><span style="color:#008000"> c[k] &gt;= a[i]</span><span style="color:#008000"><br></span><span style="color:#000000">                {<br>                    cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> c[k] </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> endl ;<br>                    </span><span style="color:#0000ff">return</span><span style="color:#000000"> ;<br>                }<br>            }<br>        }<br>    }<br><br>    cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> </span><span style="color:#800000">"</span><span style="color:#800000">Not found!</span><span style="color:#800000">"</span><span style="color:#000000"> </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> endl ;<br>}</span></div></pre>
</div>
</div>


<p>如果三个数组都无序，可以先对a, b进行排序，然后对c中任意一个元素都在b和c中做二分搜索。</p>


<h2>代码</h2>


<div><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span>代码</span>
<div>
<pre><div><span style="color:#008000">//</span><span style="color:#008000"> Find the unique common element in 3 arrays<br></span><span style="color:#008000">//</span><span style="color:#008000"> O(NlogN)</span><span style="color:#008000"><br></span><span style="color:#0000ff">int</span><span style="color:#000000"> UniqueCommonItem(</span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">a, </span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">b, </span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">c, </span><span style="color:#0000ff">int</span><span style="color:#000000"> n)<br>{<br>    </span><span style="color:#008000">//</span><span style="color:#008000"> sort array a</span><span style="color:#008000"><br></span><span style="color:#000000">    qsort(a, n, </span><span style="color:#0000ff">sizeof</span><span style="color:#000000">(</span><span style="color:#0000ff">int</span><span style="color:#000000">), compare) ; </span><span style="color:#008000">//</span><span style="color:#008000"> NlogN<br><br>    </span><span style="color:#008000">//</span><span style="color:#008000"> sort array b</span><span style="color:#008000"><br></span><span style="color:#000000">    qsort(b, n, </span><span style="color:#0000ff">sizeof</span><span style="color:#000000">(</span><span style="color:#0000ff">int</span><span style="color:#000000">), compare) ; </span><span style="color:#008000">//</span><span style="color:#008000"> NlogN<br><br>    </span><span style="color:#008000">//</span><span style="color:#008000"> for each element in array c, do a binary search in a and b<br>    </span><span style="color:#008000">//</span><span style="color:#008000"> This is up to a complexity of N*2*logN </span><span style="color:#008000"><br></span><span style="color:#000000">    </span><span style="color:#0000ff">for</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000"> i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">; i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> n; i</span><span style="color:#000000">++</span><span style="color:#000000">)<br>    {<br>        </span><span style="color:#0000ff">if</span><span style="color:#000000">(BinarySearch(a, n, c[i]) </span><span style="color:#000000">&amp;&amp;</span><span style="color:#000000"> BinarySearch(b, n, c[i]))<br>            </span><span style="color:#0000ff">return</span><span style="color:#000000"> c[i] ;<br>    }<br><br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> </span><span style="color:#000000">-</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000"> ; </span><span style="color:#008000">//</span><span style="color:#008000"> not found</span><span style="color:#008000"><br></span><span style="color:#000000">}</span></div></pre>
</div>
</div>


<p>也可以对a进行排序，然后对于b和c中任意一个元素都在a中进行二分搜索</p>


<h2>代码</h2>


<div><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span>代码</span>
<div>
<pre><div><span style="color:#008000">//</span><span style="color:#008000"> Find the unique common element in 3 arrays<br></span><span style="color:#008000">//</span><span style="color:#008000"> O(NlogN)</span><span style="color:#008000"><br></span><span style="color:#0000ff">int</span><span style="color:#000000"> UniqueCommonItem1(</span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">a, </span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">b, </span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">c, </span><span style="color:#0000ff">int</span><span style="color:#000000"> n)<br>{<br>    </span><span style="color:#008000">//</span><span style="color:#008000"> sort array a</span><span style="color:#008000"><br></span><span style="color:#000000">    qsort(a, n, </span><span style="color:#0000ff">sizeof</span><span style="color:#000000">(</span><span style="color:#0000ff">int</span><span style="color:#000000">), compare) ; </span><span style="color:#008000">//</span><span style="color:#008000"> NlogN<br><br>    </span><span style="color:#008000">//</span><span style="color:#008000"> Space for time</span><span style="color:#008000"><br></span><span style="color:#000000">    </span><span style="color:#0000ff">bool</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">bb </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#0000ff">new</span><span style="color:#000000"> </span><span style="color:#0000ff">bool</span><span style="color:#000000">[n] ;<br>    memset(bb, </span><span style="color:#800080">0</span><span style="color:#000000">, n) ;<br><br>    </span><span style="color:#0000ff">bool</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">bc </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#0000ff">new</span><span style="color:#000000"> </span><span style="color:#0000ff">bool</span><span style="color:#000000">[n] ;<br>    memset(bb, </span><span style="color:#800080">0</span><span style="color:#000000">, n) ;<br><br>    </span><span style="color:#008000">//</span><span style="color:#008000"> for each element in b, do a BS in a and mark all the common element</span><span style="color:#008000"><br></span><span style="color:#000000">    </span><span style="color:#0000ff">for</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000"> i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">; i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> n; i</span><span style="color:#000000">++</span><span style="color:#000000">)    </span><span style="color:#008000">//</span><span style="color:#008000"> NlogN</span><span style="color:#008000"><br></span><span style="color:#000000">    {<br>        </span><span style="color:#0000ff">if</span><span style="color:#000000">(BinarySearch(a, n, b[i]))<br>            bb[i] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#0000ff">true</span><span style="color:#000000"> ;<br>    }<br><br>    </span><span style="color:#008000">//</span><span style="color:#008000"> for each element in c, do a BS only if b[i] is true</span><span style="color:#008000"><br></span><span style="color:#000000">    </span><span style="color:#0000ff">for</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000"> i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">; i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> n; i</span><span style="color:#000000">++</span><span style="color:#000000">)    </span><span style="color:#008000">//</span><span style="color:#008000"> NlogN</span><span style="color:#008000"><br></span><span style="color:#000000">    {<br>        </span><span style="color:#0000ff">if</span><span style="color:#000000">(b[i] </span><span style="color:#000000">&amp;&amp;</span><span style="color:#000000"> BinarySearch(a, n, c[i]))<br>            </span><span style="color:#0000ff">return</span><span style="color:#000000"> c[i] ;<br>    }<br><br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> </span><span style="color:#000000">-</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000"> ; </span><span style="color:#008000">//</span><span style="color:#008000"> not found</span><span style="color:#008000"><br></span><span style="color:#000000">}</span></div></pre>
</div>
</div>


<p>排序和二分搜索代码如下</p>


<div><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span>代码</span>
<div>
<pre><div><span style="color:#008000">//</span><span style="color:#008000"> Determine whether a contains value k</span><span style="color:#008000"><br></span><span style="color:#0000ff">bool</span><span style="color:#000000"> BinarySearch(</span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">a, </span><span style="color:#0000ff">int</span><span style="color:#000000"> n, </span><span style="color:#0000ff">int</span><span style="color:#000000"> k)<br>{<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> left </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000"> ;<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> right </span><span style="color:#000000">=</span><span style="color:#000000"> n </span><span style="color:#000000">-</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000"> ;<br>    </span><span style="color:#0000ff">while</span><span style="color:#000000"> (left </span><span style="color:#000000">&lt;=</span><span style="color:#000000"> right)<br>    {<br>        </span><span style="color:#0000ff">int</span><span style="color:#000000"> mid </span><span style="color:#000000">=</span><span style="color:#000000"> (left </span><span style="color:#000000">+</span><span style="color:#000000"> right) ;<br><br>        </span><span style="color:#0000ff">if</span><span style="color:#000000">(a[mid] </span><span style="color:#000000">&lt;</span><span style="color:#000000"> k)<br>            left </span><span style="color:#000000">=</span><span style="color:#000000"> mid </span><span style="color:#000000">+</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000"> ;<br>        </span><span style="color:#0000ff">if</span><span style="color:#000000">(a[mid] </span><span style="color:#000000">==</span><span style="color:#000000"> k)<br>            </span><span style="color:#0000ff">return</span><span style="color:#000000"> </span><span style="color:#0000ff">true</span><span style="color:#000000"> ;<br>        </span><span style="color:#0000ff">else</span><span style="color:#000000"><br>            right </span><span style="color:#000000">=</span><span style="color:#000000"> mid </span><span style="color:#000000">-</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000"> ;<br>    }<br><br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> </span><span style="color:#0000ff">false</span><span style="color:#000000"> ;<br>}<br><br></span><span style="color:#008000">//</span><span style="color:#008000"> Compare function for qsort</span><span style="color:#008000"><br></span><span style="color:#0000ff">int</span><span style="color:#000000"> compare(</span><span style="color:#0000ff">const</span><span style="color:#000000"> </span><span style="color:#0000ff">void</span><span style="color:#000000">*</span><span style="color:#000000"> a, </span><span style="color:#0000ff">const</span><span style="color:#000000"> </span><span style="color:#0000ff">void</span><span style="color:#000000">*</span><span style="color:#000000"> b)<br>{<br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">(</span><span style="color:#0000ff">int</span><span style="color:#000000">*</span><span style="color:#000000">)a </span><span style="color:#000000">-</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">(</span><span style="color:#0000ff">int</span><span style="color:#000000">*</span><span style="color:#000000">)b ;<br>}</span></div></pre>
</div>
</div>


<p>小小总结一下，对于在数组中进行查找的问题，可以分如下两种情况处理</p>


<p>1. 如果给定的数组有序，那么首先应该想到Binary Search，所需O(logn)</p>


<p>2. 如果给定的数组无序，那么首先应该想到对数组进行排序，很多排序算法都能在O(nlogn)时间内对数组进行排序，然后再使用二分搜索，总的时间复杂度仍是O(nlogn)。</p>


<p>如果能做到以上两点，大多数关于数组的查找问题，都能迎刃而解。</p>


<h1>找出数组中唯一的重复元素</h1>


<p>给定含有1001个元素的数组，其中存放了1-1000之内的整数，只有一个整数是重复的，请找出这个数</p>


<h2>分析</h2>


<p>求出整个数组的和，再减去1-1000的和</p>


<h2>代码</h2>


<div>
<pre><div><span style="color:#0000ff">int</span><span style="color:#000000"> FindElementWithOddCount(</span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">a, </span><span style="color:#0000ff">int</span><span style="color:#000000"> n)<br>{<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> r </span><span style="color:#000000">=</span><span style="color:#000000"> a[</span><span style="color:#800080">0</span><span style="color:#000000">] ;<br><br>    </span><span style="color:#0000ff">for</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000"> i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">; i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> n; </span><span style="color:#000000">++</span><span style="color:#000000">i)<br>    {<br>        r </span><span style="color:#000000">^=</span><span style="color:#000000"> a[i] ;<br>    }<br><br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> r ;<br>}</span></div></pre>
</div>


<h1>找出出现奇数次的元素</h1>


<p>给定一个含有n个元素的整型数组a，其中只有一个元素出现奇数次，找出这个元素。</p>


<h2>分析</h2>


<p>因为对于任意一个数k，有k ^ k = 0，k ^ 0 = k，所以将a中所有元素进行异或，那么个数为偶数的元素异或后都变成了0，只留下了个数为奇数的那个元素。</p>


<h2>代码</h2>


<p>略</p>


<h1>求数组中满足给定和的数对</h1>


<p>给定两个有序整型数组a和b，各有n个元素，求两个数组中满足给定和的数对，即对a中元素i和b中元素j，满足i + j = d(d已知)</p>


<h2>分析</h2>


<p>两个指针i和j分别指向数组的首尾，然后从两端同时向中间遍历，直到两个指针交叉。</p>


<h2>代码</h2>


<div><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span>代码</span>
<div>
<pre><div><span style="color:#008000">//</span><span style="color:#008000"> 找出满足给定和的数对</span><span style="color:#008000"><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> FixedSum(</span><span style="color:#0000ff">int</span><span style="color:#000000">*</span><span style="color:#000000"> a, </span><span style="color:#0000ff">int</span><span style="color:#000000">*</span><span style="color:#000000"> b, </span><span style="color:#0000ff">int</span><span style="color:#000000"> n, </span><span style="color:#0000ff">int</span><span style="color:#000000"> d)<br>{<br>    </span><span style="color:#0000ff">for</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000"> i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">, j </span><span style="color:#000000">=</span><span style="color:#000000"> n </span><span style="color:#000000">-</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">; i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> n </span><span style="color:#000000">&amp;&amp;</span><span style="color:#000000"> j </span><span style="color:#000000">&gt;=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">)<br>    {<br>        </span><span style="color:#0000ff">if</span><span style="color:#000000"> (a[i] </span><span style="color:#000000">+</span><span style="color:#000000"> b[j] </span><span style="color:#000000">&lt;</span><span style="color:#000000"> d)<br>            </span><span style="color:#000000">++</span><span style="color:#000000">i ;<br>        </span><span style="color:#0000ff">else</span><span style="color:#000000"> </span><span style="color:#0000ff">if</span><span style="color:#000000"> (a[i] </span><span style="color:#000000">+</span><span style="color:#000000"> b[j] </span><span style="color:#000000">==</span><span style="color:#000000"> d)<br>        {<br>            cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> a[i] </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> </span><span style="color:#800000">"</span><span style="color:#800000">, </span><span style="color:#800000">"</span><span style="color:#000000"> </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> b[j] </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> endl ;<br>            </span><span style="color:#000000">++</span><span style="color:#000000">i ;<br>            </span><span style="color:#000000">--</span><span style="color:#000000">j ;<br>        }<br>        </span><span style="color:#0000ff">else</span><span style="color:#000000"> </span><span style="color:#008000">//</span><span style="color:#008000"> a[i] + b[j] &gt; d</span><span style="color:#008000"><br></span><span style="color:#000000">            </span><span style="color:#000000">--</span><span style="color:#000000">j ;<br>    }<br>}</span></div></pre>
</div>
</div>


<h1>最大子段和</h1>


<p>给定一个整型数组a，求出最大连续子段之和，如果和为负数，则按0计算，比如1， 2， -5， 6， 8则输出6 + 8 = 14</p>


<h2>分析</h2>


<p>编程珠玑上的经典题目，不多说了。</p>


<h2>代码</h2>


<div><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span>代码</span>
<div>
<pre><div><span style="color:#000000">/</span><span style="color:#000000"> 子数组的最大和<br></span><span style="color:#0000ff">int</span><span style="color:#000000"> Sum(</span><span style="color:#0000ff">int</span><span style="color:#000000">*</span><span style="color:#000000"> a, </span><span style="color:#0000ff">int</span><span style="color:#000000"> n)<br>{<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> curSum </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">;<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> maxSum </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">;<br>    </span><span style="color:#0000ff">for</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000"> i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">; i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> n; i</span><span style="color:#000000">++</span><span style="color:#000000">)<br>    {<br>        </span><span style="color:#0000ff">if</span><span style="color:#000000"> (curSum </span><span style="color:#000000">+</span><span style="color:#000000"> a[i] </span><span style="color:#000000">&lt;</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">)<br>            curSum </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">;<br>        </span><span style="color:#0000ff">else</span><span style="color:#000000"><br>        {<br>            curSum </span><span style="color:#000000">+=</span><span style="color:#000000"> a[i] ;<br>            maxSum </span><span style="color:#000000">=</span><span style="color:#000000"> max(maxSum, curSum);<br>        }<br>    }<br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> maxSum;<br>}</span></div></pre>
</div>
</div>


<h1>最大子段积</h1>


<p>给定一个整型数足a，求出最大连续子段的乘积，比如 1， 2， -8， 12， 7则输出12 * 7 = 84</p>


<h2>分析</h2>


<p>与最大子段和类似，注意处理负数的情况</p>


<h2>代码</h2>


<div><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span>代码</span>
<div>
<pre><div><span style="color:#008000">//</span><span style="color:#008000"> 子数组的最大乘积</span><span style="color:#008000"><br></span><span style="color:#0000ff">int</span><span style="color:#000000"> MaxProduct(</span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">a, </span><span style="color:#0000ff">int</span><span style="color:#000000"> n)<br>{<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> maxProduct </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">; </span><span style="color:#008000">//</span><span style="color:#008000"> max positive product at current position</span><span style="color:#008000"><br></span><span style="color:#000000">    </span><span style="color:#0000ff">int</span><span style="color:#000000"> minProduct </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">; </span><span style="color:#008000">//</span><span style="color:#008000"> min negative product at current position</span><span style="color:#008000"><br></span><span style="color:#000000">    </span><span style="color:#0000ff">int</span><span style="color:#000000"> r </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">;   </span><span style="color:#008000">//</span><span style="color:#008000"> result, max multiplication totally</span><span style="color:#008000"><br></span><span style="color:#000000"><br>    </span><span style="color:#0000ff">for</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000"> i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">; i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> n; i</span><span style="color:#000000">++</span><span style="color:#000000">)<br>    {<br>        </span><span style="color:#0000ff">if</span><span style="color:#000000"> (a[i] </span><span style="color:#000000">&gt;</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">)<br>        {<br>            maxProduct </span><span style="color:#000000">*=</span><span style="color:#000000"> a[i];<br>            minProduct </span><span style="color:#000000">=</span><span style="color:#000000"> min(minProduct </span><span style="color:#000000">*</span><span style="color:#000000"> a[i], </span><span style="color:#800080">1</span><span style="color:#000000">);<br>        }<br>        </span><span style="color:#0000ff">else</span><span style="color:#000000"> </span><span style="color:#0000ff">if</span><span style="color:#000000"> (a[i] </span><span style="color:#000000">==</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">)<br>        {<br>            maxProduct </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">;<br>            minProduct </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">;<br>        }<br>        </span><span style="color:#0000ff">else</span><span style="color:#000000"> </span><span style="color:#008000">//</span><span style="color:#008000"> a[i] &lt; 0</span><span style="color:#008000"><br></span><span style="color:#000000">        {<br>            </span><span style="color:#0000ff">int</span><span style="color:#000000"> temp </span><span style="color:#000000">=</span><span style="color:#000000"> maxProduct;<br>            maxProduct </span><span style="color:#000000">=</span><span style="color:#000000"> max(minProduct </span><span style="color:#000000">*</span><span style="color:#000000"> a[i], </span><span style="color:#800080">1</span><span style="color:#000000">);<br>            minProduct </span><span style="color:#000000">=</span><span style="color:#000000"> temp </span><span style="color:#000000">*</span><span style="color:#000000"> a[i];<br>        }<br><br>        r </span><span style="color:#000000">=</span><span style="color:#000000"> max(r, maxProduct);<br>    }<br><br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> r;<br>}</span></div></pre>
</div>
</div>


<h1>数组循环移位</h1>


<p>将一个含有n个元素的数组向右循环移动k位，要求时间复杂度是O(n)，且只能使用两个额外的变量，这是在微软的编程之美上看到的一道题</p>


<h2>分析</h2>


<p>比如数组 1 2 3 4循环右移1位 将变成 4 1 2 3， 观察可知1 2 3 的顺序在移位前后没有改变，只是和4的位置交换了一下，所以等同于1 2 3 4 先划分为两部分  </p>


<p>1 2 3 | 4，然后将1 2 3逆序，再将4 逆序 得到 3 2 1 4，最后整体逆序 得到 4 1 2 3</p>


<h2>代码</h2>


<div><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span>代码</span>
<div>
<pre><div><span style="color:#008000">//</span><span style="color:#008000"> 将buffer中start和end之间的元素逆序</span><span style="color:#008000"><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> Reverse( </span><span style="color:#0000ff">int</span><span style="color:#000000"> buffer[], </span><span style="color:#0000ff">int</span><span style="color:#000000"> start, </span><span style="color:#0000ff">int</span><span style="color:#000000"> end )<br>{<br>    </span><span style="color:#0000ff">while</span><span style="color:#000000"> ( start </span><span style="color:#000000">&lt;</span><span style="color:#000000"> end )<br>    {<br>        </span><span style="color:#0000ff">int</span><span style="color:#000000"> temp </span><span style="color:#000000">=</span><span style="color:#000000"> buffer[ start ] ;<br>        buffer[ start</span><span style="color:#000000">++</span><span style="color:#000000"> ] </span><span style="color:#000000">=</span><span style="color:#000000"> buffer[ end ] ;<br>        buffer[ end</span><span style="color:#000000">--</span><span style="color:#000000"> ] </span><span style="color:#000000">=</span><span style="color:#000000"> temp ;<br>    }<br>}<br><br></span><span style="color:#008000">//</span><span style="color:#008000"> 将含有n个元素的数组buffer右移k位</span><span style="color:#008000"><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> Shift( </span><span style="color:#0000ff">int</span><span style="color:#000000"> buffer[], </span><span style="color:#0000ff">int</span><span style="color:#000000"> n, </span><span style="color:#0000ff">int</span><span style="color:#000000"> k )<br>{<br>    k </span><span style="color:#000000">%=</span><span style="color:#000000"> n ;<br><br>    Reverse( buffer, </span><span style="color:#800080">0</span><span style="color:#000000">, n </span><span style="color:#000000">-</span><span style="color:#000000"> k </span><span style="color:#000000">-</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">) ;<br>    Reverse( buffer, n </span><span style="color:#000000">-</span><span style="color:#000000"> k, n </span><span style="color:#000000">-</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000"> ) ;<br>    Reverse( buffer, </span><span style="color:#800080">0</span><span style="color:#000000">, n </span><span style="color:#000000">-</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000"> ) ;<br>}</span></div></pre>
</div>
</div>


<h1>字符串逆序</h1>


<p>给定一个含有n个元素的字符数组a，将其原地逆序。</p>


<h2>分析</h2>


<p>可能您觉得这不是关于数组的，而是关于字符串的。是的。但是别忘了题目要求的是原地逆序，也就是不允许额外分配空间，那么参数肯定是字符数组形式，因为字符串是不能被修改的（这里只C/C++中的字符串常量），所以，和数组有关了吧，只不过不是整型数组，而是字符数组。用两个指针分别指向字符数组的首位，交换其对应的字符，然后两个指针分别向数组中央移动，直到交叉。</p>


<h2>代码</h2>


<div>
<pre><div><span style="color:#008000">//</span><span style="color:#008000"> 字符串逆序</span><span style="color:#008000"><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> Reverse(</span><span style="color:#0000ff">char</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">a, </span><span style="color:#0000ff">int</span><span style="color:#000000"> n)<br>{<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> left </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">; <br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> right </span><span style="color:#000000">=</span><span style="color:#000000"> n </span><span style="color:#000000">-</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">;<br><br>    </span><span style="color:#0000ff">while</span><span style="color:#000000"> (left </span><span style="color:#000000">&lt;</span><span style="color:#000000"> right)<br>    {<br>        </span><span style="color:#0000ff">char</span><span style="color:#000000"> temp </span><span style="color:#000000">=</span><span style="color:#000000"> a[left] ;<br>        a[left</span><span style="color:#000000">++</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> a[right] ;<br>        a[right</span><span style="color:#000000">--</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> temp ;<br>    }<br>}</span></div></pre>
</div>


<h1>组合问题</h1>


<p>给定一个含有n个元素的整型数组a，从中任取m个元素，求所有组合。比如下面的例子</p>


<p>a = 1, 2, 3, 4, 5</p>


<p>m = 3</p>


<p>输出</p>


<p>1 2 3, 1 2 4, 1 2 5, 1 3 4, 1 3 5, 1 4 5</p>


<p>2 3 4, 2 3 5, 2 4 5<br>3 4 5</p>


<h2>分析</h2>


<p>典型的排列组合问题，首选回溯法，为了简化问题，我们将a中n个元素值分别设置为1-n</p>


<h2>代码</h2>


<div><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span>代码</span>
<div>
<pre><div><span style="color:#008000">//</span><span style="color:#008000"> n选m的所有组合</span><span style="color:#008000"><br></span><span style="color:#0000ff">int</span><span style="color:#000000"> buffer[</span><span style="color:#800080">100</span><span style="color:#000000">] ;<br><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> PrintArray(</span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">a, </span><span style="color:#0000ff">int</span><span style="color:#000000"> n)<br>{<br>    </span><span style="color:#0000ff">for</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000"> i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">; i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> n; </span><span style="color:#000000">++</span><span style="color:#000000">i)<br>        cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> a[i] </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> </span><span style="color:#800000">"</span><span style="color:#800000"> </span><span style="color:#800000">"</span><span style="color:#000000">;<br>    cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> endl ;<br>}<br><br></span><span style="color:#0000ff">bool</span><span style="color:#000000"> IsValid(</span><span style="color:#0000ff">int</span><span style="color:#000000"> lastIndex, </span><span style="color:#0000ff">int</span><span style="color:#000000"> value)<br>{<br>    </span><span style="color:#0000ff">for</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000"> i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">; i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> lastIndex; i</span><span style="color:#000000">++</span><span style="color:#000000">)<br>    {<br>        </span><span style="color:#0000ff">if</span><span style="color:#000000"> (buffer[i] </span><span style="color:#000000">&gt;=</span><span style="color:#000000"> value)<br>            </span><span style="color:#0000ff">return</span><span style="color:#000000"> </span><span style="color:#0000ff">false</span><span style="color:#000000">;<br>    }<br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> </span><span style="color:#0000ff">true</span><span style="color:#000000">;<br>}<br><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> Select(</span><span style="color:#0000ff">int</span><span style="color:#000000"> t, </span><span style="color:#0000ff">int</span><span style="color:#000000"> n, </span><span style="color:#0000ff">int</span><span style="color:#000000"> m)<br>{<br>    </span><span style="color:#0000ff">if</span><span style="color:#000000"> (t </span><span style="color:#000000">==</span><span style="color:#000000"> m)<br>        PrintArray(buffer, m);<br>    </span><span style="color:#0000ff">else</span><span style="color:#000000"><br>    {<br>        </span><span style="color:#0000ff">for</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000"> i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">; i </span><span style="color:#000000">&lt;=</span><span style="color:#000000"> n; i</span><span style="color:#000000">++</span><span style="color:#000000">)<br>        {<br>            buffer[t] </span><span style="color:#000000">=</span><span style="color:#000000"> i;<br>            </span><span style="color:#0000ff">if</span><span style="color:#000000"> (IsValid(t, i))<br>                Select(t </span><span style="color:#000000">+</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">, n, m);<br>        }<br>    }<br>}</span></div></pre>
</div>
</div>


<h1>合并两个数组</h1>


<p>给定含有n个元素的两个有序（非降序）整型数组a和b。合并两个数组中的元素到整型数组c，要求去除重复元素并保持c有序（非降序）。例子如下</p>


<p>a = 1, 2, 4, 8</p>


<p>b = 1, 3, 5, 8</p>


<p>c = 1, 2, 3, 4, 5, 8</p>


<h2>分析</h2>


<p>利用合并排序的思想，两个指针i,j和k分别指向数组a和b，然后比较两个指针对应元素的大小，有以下三种情况</p>


<p>1. a[i] &lt; b[j]，则c[k] = a[i]。</p>


<p>2. a[i] == b[j]，则c[k]等于a[i]或b[j]皆可。</p>


<p>3. a[i] &gt; b[j]，则c[k] = b[j]。</p>


<p>重复以上过程，直到i或者j到达数组末尾，然后将剩下的元素直接copy到数组c中即可</p>


<h2>代码</h2>


<div><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif"><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif"><span>代码</span>
<div>
<pre><div><span style="color:#008000">//</span><span style="color:#008000"> 合并两个有序数组</span><span style="color:#008000"><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> Merge(</span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">a, </span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">b, </span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">c, </span><span style="color:#0000ff">int</span><span style="color:#000000"> n)<br>{<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000"> ;<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> j </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000"> ;<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> k </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000"> ;<br><br>    </span><span style="color:#0000ff">while</span><span style="color:#000000"> (i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> n </span><span style="color:#000000">&amp;&amp;</span><span style="color:#000000"> j </span><span style="color:#000000">&lt;</span><span style="color:#000000"> n)<br>    {<br>        </span><span style="color:#0000ff">if</span><span style="color:#000000"> (a[i] </span><span style="color:#000000">&lt;</span><span style="color:#000000"> b[j])</span><span style="color:#008000">//</span><span style="color:#008000"> 如果a的元素小，则插入a中元素到c</span><span style="color:#008000"><br></span><span style="color:#000000">        {<br>            c[k</span><span style="color:#000000">++</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> a[i] ;<br>            </span><span style="color:#000000">++</span><span style="color:#000000">i ;<br>        }<br>        </span><span style="color:#0000ff">else</span><span style="color:#000000"> </span><span style="color:#0000ff">if</span><span style="color:#000000"> (a[i] </span><span style="color:#000000">==</span><span style="color:#000000"> b[j])</span><span style="color:#008000">//</span><span style="color:#008000"> 如果a和b元素相等，则插入二者皆可，这里插入a</span><span style="color:#008000"><br></span><span style="color:#000000">        {<br>            c[k</span><span style="color:#000000">++</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> a[i] ;<br>            </span><span style="color:#000000">++</span><span style="color:#000000">i ;<br>            </span><span style="color:#000000">++</span><span style="color:#000000">j ;<br>        }<br>        </span><span style="color:#0000ff">else</span><span style="color:#000000"> </span><span style="color:#008000">//</span><span style="color:#008000"> a[i] &gt; b[j] </span><span style="color:#008000">//</span><span style="color:#008000"> 如果b中元素小，则插入b中元素到c</span><span style="color:#008000"><br></span><span style="color:#000000">        {<br>            c[k</span><span style="color:#000000">++</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> b[j] ;<br>            </span><span style="color:#000000">++</span><span style="color:#000000">j ;<br>        }<br>    }<br><br>    </span><span style="color:#0000ff">if</span><span style="color:#000000"> (i </span><span style="color:#000000">==</span><span style="color:#000000"> n) </span><span style="color:#008000">//</span><span style="color:#008000"> 若a遍历完毕，处理b中剩下的元素</span><span style="color:#008000"><br></span><span style="color:#000000">    {<br>        </span><span style="color:#0000ff">for</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000"> m </span><span style="color:#000000">=</span><span style="color:#000000"> j; m </span><span style="color:#000000">&lt;</span><span style="color:#000000"> n; </span><span style="color:#000000">++</span><span style="color:#000000">m)<br>            c[k</span><span style="color:#000000">++</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> b[m] ;<br>    }<br>    </span><span style="color:#0000ff">else</span><span style="color:#008000">//</span><span style="color:#008000">j == n,  若b遍历完毕，处理a中剩下的元素</span><span style="color:#008000"><br></span><span style="color:#000000">    {<br>        </span><span style="color:#0000ff">for</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000"> m </span><span style="color:#000000">=</span><span style="color:#000000"> i; m </span><span style="color:#000000">&lt;</span><span style="color:#000000"> n; </span><span style="color:#000000">++</span><span style="color:#000000">m)<br>            c[k</span><span style="color:#000000">++</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> a[m] ;<br>    }<br>}</span></div></pre>
</div>
</div>


<h1>重排问题</h1>


<p>给定含有n个元素的整型数组a，其中包括0元素和非0元素，对数组进行排序，要求：</p>


<p>1. 排序后所有0元素在前，所有非零元素在后，且非零元素排序前后相对位置不变</p>


<p>2. 不能使用额外存储空间</p>


<p>例子如下</p>


<p>输入 0, 3, 0, 2, 1, 0, 0</p>


<p>输出 0, 0, 0, 0, 3, 2, 1</p>


<h2>分析</h2>


<p>此排序非传统意义上的排序，因为它要求排序前后非0元素的相对位置不变，或许叫做整理会更恰当一些。我们可以从后向前遍历整个数组，遇到某个位置k上的元素是非0元素时，将其a[k]放到数组最后一个位置，同时将a[k]赋值为0.遇到下一个非0的元素时，将其放在数组的倒数第二个位置，重复此过程直到遍历完毕即可。</p>


<h2>代码</h2>


<div>
<pre><div><span style="color:#008000">//</span><span style="color:#008000"> 重排数组</span><span style="color:#008000"><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> Arrange(</span><span style="color:#0000ff">int</span><span style="color:#000000"> </span><span style="color:#000000">*</span><span style="color:#000000">a, </span><span style="color:#0000ff">int</span><span style="color:#000000"> n)<br>{<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> k </span><span style="color:#000000">=</span><span style="color:#000000"> n </span><span style="color:#000000">-</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000"> ;<br>    </span><span style="color:#0000ff">for</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000"> i </span><span style="color:#000000">=</span><span style="color:#000000"> n </span><span style="color:#000000">-</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">; i </span><span style="color:#000000">&gt;=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">; </span><span style="color:#000000">--</span><span style="color:#000000">i)<br>    {<br>        </span><span style="color:#0000ff">if</span><span style="color:#000000"> (a[i] </span><span style="color:#000000">!=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">)<br>        {<br>            a[k</span><span style="color:#000000">--</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> a[i] ;<br>            a[i] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000"> ;<br>        }<br>    }<br>}</span></div></pre>
</div>


<p> </p>


<p><img src="http://www.cnblogs.com/graphics/aggbug/1761620.html?type=1" width="1" height="1" alt=""><p>评论: 17　<a href="http://www.cnblogs.com/graphics/archive/2010/08/24/1761620.html#pagedcomment">查看评论</a>　<a href="http://www.cnblogs.com/graphics/archive/2010/08/24/1761620.html#commentform">发表评论</a></p><p><a href="http://job.cnblogs.com/">程序员找工作，就在博客园</a></p><hr><p>最新新闻：<br>· <a href="http://news.cnblogs.com/n/71885/">大华建设收购联游网络60%股份 唐骏任董事长</a><span style="color:gray">(2010-08-24 22:30)</span><br>· <a href="http://news.cnblogs.com/n/71887/">腾讯收购康盛后 猜想百万站长去留</a><span style="color:gray">(2010-08-24 22:04)</span><br>· <a href="http://news.cnblogs.com/n/71884/">丹麦发明家自制载人火箭 将于8月30日发射</a><span style="color:gray">(2010-08-24 21:31)</span><br>· <a href="http://news.cnblogs.com/n/71883/">中国复制Craigslist：竞价排名VS非盈利</a><span style="color:gray">(2010-08-24 21:29)</span><br>· <a href="http://news.cnblogs.com/n/71882/">奇美索尼互指侵权 谁动谁的奶酪？</a><span style="color:gray">(2010-08-24 21:26)</span><br></p><p>编辑推荐：<a href="http://kb.cnblogs.com/page/71661/">[热点新闻]腾讯收购康盛创想(持续更新中)</a><br></p><p>网站导航：<a href="http://www.cnblogs.com">博客园首页</a>  <a href="http://home.cnblogs.com/">个人主页</a>  <a href="http://news.cnblogs.com">新闻</a>  <a href="http://home.cnblogs.com/ing/">闪存</a>  <a href="http://home.cnblogs.com/group/">小组</a>  <a href="http://space.cnblogs.com/q/">博问</a>  <a href="http://space.cnblogs.com">社区</a>  <a href="http://kb.cnblogs.com">知识库</a></p></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
