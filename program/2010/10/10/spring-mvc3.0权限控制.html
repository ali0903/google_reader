<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>spring mvc3.0权限控制</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>spring mvc3.0权限控制</h2>
<p class="meta">10 Oct 2010</p>

<div class="post">
<h2>spring mvc3.0权限控制</h2>

<h3>by</h3>

<h3>at 2010-10-10 12:17:13</h3>

<h3>original <a href="http://www.javaeye.com/topic/780375">http://www.javaeye.com/topic/780375</a></h3>

<p>新项目中用到了Spring mvc3.0，之后又升级到3.0.4，因为对静态资源处理有更好支持
<br>
<br><pre name="code">
&lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/<strong>&quot; /&gt;
</pre>
<br>
<br>spring mvc 3.0最大的特别即是对restful url很友好的支持。但也带来很多不便的地方，比如权限控制，花不少时间阅读源码，发现根本无法扩展对方法级别的控制，也就是使<span style="color:red">Controller层失去了面向对象的特征</span>，惨！不知道作者是怎么想的，Juergen Hoeller！恨死你了，居然不留一点扩展的余地，要自己写过滤和匹配映射规则虽然能行，但没必要去repeat ，最后无耐Copy源码，修改一翻，想怎么控制就怎么控制了。
<br>
<br>总结：
<br>     在一个项目组中，如果要使用新技术，必须要有一个人精通，碰到任何问题都能解决，否则，千万不能用新技术。
<br>
<br>spring 配置文件如下：
<br><pre name="code">
&lt;bean class=&quot;com.jquickwork.extend.AnnotationMethodHandlerAdapter&quot;&gt;
        &lt;property name=&quot;permissionService&quot;&gt;
            &lt;bean class=&quot;com.</strong>****.manage.web.common.service.PermissionServiceImpl&quot;&gt;
                &lt;property name=&quot;rightService&quot; ref=&quot;RightService&quot;&gt;&lt;/property&gt;
                &lt;property name=&quot;test&quot; value=&quot;false&quot; /&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;</p>

<p></pre>
<br>
<br>修改源码后的 AnnotationMethodHandlerAdapter类如下：
<br>
<br><pre name="code">
/<em>
 * Copyright 2002-2010 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 </em>/</p>

<p>package com.jquickwork.extend;</p>

<p>import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import java.lang.reflect.Method;
import java.security.Principal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;</p>

<p>import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;</p>

<p>import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.beans.factory.config.BeanExpressionContext;
import org.springframework.beans.factory.config.BeanExpressionResolver;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.core.LocalVariableTableParameterNameDiscoverer;
import org.springframework.core.Ordered;
import org.springframework.core.ParameterNameDiscoverer;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpInputMessage;
import org.springframework.http.HttpOutputMessage;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.ByteArrayHttpMessageConverter;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.StringHttpMessageConverter;
import org.springframework.http.converter.xml.SourceHttpMessageConverter;
import org.springframework.http.converter.xml.XmlAwareFormHttpMessageConverter;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.http.server.ServletServerHttpRequest;
import org.springframework.http.server.ServletServerHttpResponse;
import org.springframework.ui.ExtendedModelMap;
import org.springframework.ui.Model;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.ObjectUtils;
import org.springframework.util.PathMatcher;
import org.springframework.util.StringUtils;
import org.springframework.validation.support.BindingAwareModelMap;
import org.springframework.web.HttpMediaTypeNotAcceptableException;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.HttpSessionRequiredException;
import org.springframework.web.bind.MissingServletRequestParameterException;
import org.springframework.web.bind.ServletRequestDataBinder;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.annotation.InitBinder;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.SessionAttributes;
import org.springframework.web.bind.annotation.support.HandlerMethodInvoker;
import org.springframework.web.bind.annotation.support.HandlerMethodResolver;
import org.springframework.web.bind.support.DefaultSessionAttributeStore;
import org.springframework.web.bind.support.SessionAttributeStore;
import org.springframework.web.bind.support.WebArgumentResolver;
import org.springframework.web.bind.support.WebBindingInitializer;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.context.request.RequestScope;
import org.springframework.web.context.request.ServletWebRequest;
import org.springframework.web.multipart.MultipartRequest;
import org.springframework.web.servlet.HandlerAdapter;
import org.springframework.web.servlet.HandlerMapping;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.View;
import org.springframework.web.servlet.mvc.annotation.ModelAndViewResolver;
import org.springframework.web.servlet.mvc.multiaction.InternalPathMethodNameResolver;
import org.springframework.web.servlet.mvc.multiaction.MethodNameResolver;
import org.springframework.web.servlet.mvc.multiaction.NoSuchRequestHandlingMethodException;
import org.springframework.web.servlet.support.RequestContextUtils;
import org.springframework.web.servlet.support.WebContentGenerator;
import org.springframework.web.util.UrlPathHelper;
import org.springframework.web.util.WebUtils;</p>

<p>import com.tuankela.manage.web.common.service.PermissionException;
import com.tuankela.manage.web.common.service.PermissionService;</p>

<p>/<em>*
 * Implementation of the {@link org.springframework.web.servlet.HandlerAdapter} interface
 * that maps handler methods based on HTTP paths, HTTP methods and request parameters
 * expressed through the {@link RequestMapping} annotation.
 *
 * &lt;p&gt;Supports request parameter binding through the {@link RequestParam} annotation.
 * Also supports the {@link ModelAttribute} annotation for exposing model attribute
 * values to the view, as well as {@link InitBinder} for binder initialization methods
 * and {@link SessionAttributes} for automatic session management of specific attributes.
 *
 * &lt;p&gt;This adapter can be customized through various bean properties.
 * A common use case is to apply shared binder initialization logic through
 * a custom {@link #setWebBindingInitializer WebBindingInitializer}.
 *
 * @author Juergen Hoeller
 * @author Arjen Poutsma
 * @since 2.5
 * @see #setPathMatcher
 * @see #setMethodNameResolver
 * @see #setWebBindingInitializer
 * @see #setSessionAttributeStore
 </em>/
public class AnnotationMethodHandlerAdapter extends WebContentGenerator
        implements HandlerAdapter, Ordered, BeanFactoryAware {</p>

<pre><code>private PermissionService permissionService;
/**
 * Log category to use when no mapped handler is found for a request.
 * @see #pageNotFoundLogger
 */
public static final String PAGE_NOT_FOUND_LOG_CATEGORY = &amp;quot;org.springframework.web.servlet.PageNotFound&amp;quot;;

/**
 * Additional logger to use when no mapped handler is found for a request.
 * @see #PAGE_NOT_FOUND_LOG_CATEGORY
 */
protected static final Log pageNotFoundLogger = LogFactory.getLog(PAGE_NOT_FOUND_LOG_CATEGORY);


private UrlPathHelper urlPathHelper = new UrlPathHelper();

private PathMatcher pathMatcher = new AntPathMatcher();

private MethodNameResolver methodNameResolver = new InternalPathMethodNameResolver();

private WebBindingInitializer webBindingInitializer;

private SessionAttributeStore sessionAttributeStore = new DefaultSessionAttributeStore();

private int cacheSecondsForSessionAttributeHandlers = 0;

private boolean synchronizeOnSession = false;

private ParameterNameDiscoverer parameterNameDiscoverer = new LocalVariableTableParameterNameDiscoverer();

private WebArgumentResolver[] customArgumentResolvers;

private ModelAndViewResolver[] customModelAndViewResolvers;

private HttpMessageConverter&amp;lt;?&amp;gt;[] messageConverters;

private int order = Ordered.LOWEST_PRECEDENCE;

private ConfigurableBeanFactory beanFactory;

private BeanExpressionContext expressionContext;

private final Map&amp;lt;Class&amp;lt;?&amp;gt;, ServletHandlerMethodResolver&amp;gt; methodResolverCache =
        new ConcurrentHashMap&amp;lt;Class&amp;lt;?&amp;gt;, ServletHandlerMethodResolver&amp;gt;();


public AnnotationMethodHandlerAdapter() {
    // no restriction of HTTP methods by default
    super(false);

    // See SPR-7316
    StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter();
    stringHttpMessageConverter.setWriteAcceptCharset(false);
    messageConverters = new HttpMessageConverter[]{new ByteArrayHttpMessageConverter(), stringHttpMessageConverter,
            new SourceHttpMessageConverter(), new XmlAwareFormHttpMessageConverter()};
}


/**
 * Set if URL lookup should always use the full path within the current servlet
 * context. Else, the path within the current servlet mapping is used if applicable
 * (that is, in the case of a &amp;quot;.../*&amp;quot; servlet mapping in web.xml).
 * &amp;lt;p&amp;gt;Default is &amp;quot;false&amp;quot;.
 * @see org.springframework.web.util.UrlPathHelper#setAlwaysUseFullPath
 */
public void setAlwaysUseFullPath(boolean alwaysUseFullPath) {
    this.urlPathHelper.setAlwaysUseFullPath(alwaysUseFullPath);
}

/**
 * Set if context path and request URI should be URL-decoded. Both are returned
 * &amp;lt;i&amp;gt;undecoded&amp;lt;/i&amp;gt; by the Servlet API, in contrast to the servlet path.
 * &amp;lt;p&amp;gt;Uses either the request encoding or the default encoding according
 * to the Servlet spec (ISO-8859-1).
 * @see org.springframework.web.util.UrlPathHelper#setUrlDecode
 */
public void setUrlDecode(boolean urlDecode) {
    this.urlPathHelper.setUrlDecode(urlDecode);
}

/**
 * Set the UrlPathHelper to use for resolution of lookup paths.
 * &amp;lt;p&amp;gt;Use this to override the default UrlPathHelper with a custom subclass,
 * or to share common UrlPathHelper settings across multiple HandlerMappings and HandlerAdapters.
 */
public void setUrlPathHelper(UrlPathHelper urlPathHelper) {
    Assert.notNull(urlPathHelper, &amp;quot;UrlPathHelper must not be null&amp;quot;);
    this.urlPathHelper = urlPathHelper;
}

/**
 * Set the PathMatcher implementation to use for matching URL paths against registered URL patterns.
 * &amp;lt;p&amp;gt;Default is {@link org.springframework.util.AntPathMatcher}.
 */
public void setPathMatcher(PathMatcher pathMatcher) {
    Assert.notNull(pathMatcher, &amp;quot;PathMatcher must not be null&amp;quot;);
    this.pathMatcher = pathMatcher;
}

/**
 * Set the MethodNameResolver to use for resolving default handler methods
 * (carrying an empty &amp;lt;code&amp;gt;@RequestMapping&amp;lt;/code&amp;gt; annotation).
 * &amp;lt;p&amp;gt;Will only kick in when the handler method cannot be resolved uniquely
 * through the annotation metadata already.
 */
public void setMethodNameResolver(MethodNameResolver methodNameResolver) {
    this.methodNameResolver = methodNameResolver;
}

/**
 * Specify a WebBindingInitializer which will apply pre-configured
 * configuration to every DataBinder that this controller uses.
 */
public void setWebBindingInitializer(WebBindingInitializer webBindingInitializer) {
    this.webBindingInitializer = webBindingInitializer;
}

/**
 * Specify the strategy to store session attributes with.
 * &amp;lt;p&amp;gt;Default is {@link org.springframework.web.bind.support.DefaultSessionAttributeStore},
 * storing session attributes in the HttpSession, using the same attribute name as in the model.
 */
public void setSessionAttributeStore(SessionAttributeStore sessionAttributeStore) {
    Assert.notNull(sessionAttributeStore, &amp;quot;SessionAttributeStore must not be null&amp;quot;);
    this.sessionAttributeStore = sessionAttributeStore;
}

/**
 * Cache content produced by &amp;lt;code&amp;gt;@SessionAttributes&amp;lt;/code&amp;gt; annotated handlers
 * for the given number of seconds. Default is 0, preventing caching completely.
 * &amp;lt;p&amp;gt;In contrast to the &amp;quot;cacheSeconds&amp;quot; property which will apply to all general handlers
 * (but not to &amp;lt;code&amp;gt;@SessionAttributes&amp;lt;/code&amp;gt; annotated handlers), this setting will
 * apply to &amp;lt;code&amp;gt;@SessionAttributes&amp;lt;/code&amp;gt; annotated handlers only.
 * @see #setCacheSeconds
 * @see org.springframework.web.bind.annotation.SessionAttributes
 */
public void setCacheSecondsForSessionAttributeHandlers(int cacheSecondsForSessionAttributeHandlers) {
    this.cacheSecondsForSessionAttributeHandlers = cacheSecondsForSessionAttributeHandlers;
}

/**
 * Set if controller execution should be synchronized on the session,
 * to serialize parallel invocations from the same client.
 * &amp;lt;p&amp;gt;More specifically, the execution of the &amp;lt;code&amp;gt;handleRequestInternal&amp;lt;/code&amp;gt;
 * method will get synchronized if this flag is &amp;quot;true&amp;quot;. The best available
 * session mutex will be used for the synchronization; ideally, this will
 * be a mutex exposed by HttpSessionMutexListener.
 * &amp;lt;p&amp;gt;The session mutex is guaranteed to be the same object during
 * the entire lifetime of the session, available under the key defined
 * by the &amp;lt;code&amp;gt;SESSION_MUTEX_ATTRIBUTE&amp;lt;/code&amp;gt; constant. It serves as a
 * safe reference to synchronize on for locking on the current session.
 * &amp;lt;p&amp;gt;In many cases, the HttpSession reference itself is a safe mutex
 * as well, since it will always be the same object reference for the
 * same active logical session. However, this is not guaranteed across
 * different servlet containers; the only 100% safe way is a session mutex.
 * @see org.springframework.web.util.HttpSessionMutexListener
 * @see org.springframework.web.util.WebUtils#getSessionMutex(javax.servlet.http.HttpSession)
 */
public void setSynchronizeOnSession(boolean synchronizeOnSession) {
    this.synchronizeOnSession = synchronizeOnSession;
}

/**
 * Set the ParameterNameDiscoverer to use for resolving method parameter names if needed
 * (e.g. for default attribute names).
 * &amp;lt;p&amp;gt;Default is a {@link org.springframework.core.LocalVariableTableParameterNameDiscoverer}.
 */
public void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {
    this.parameterNameDiscoverer = parameterNameDiscoverer;
}

/**
 * Set a custom WebArgumentResolvers to use for special method parameter types.
 * &amp;lt;p&amp;gt;Such a custom WebArgumentResolver will kick in first, having a chance to resolve
 * an argument value before the standard argument handling kicks in.
 */
public void setCustomArgumentResolver(WebArgumentResolver argumentResolver) {
    this.customArgumentResolvers = new WebArgumentResolver[] {argumentResolver};
}

/**
 * Set one or more custom WebArgumentResolvers to use for special method parameter types.
 * &amp;lt;p&amp;gt;Any such custom WebArgumentResolver will kick in first, having a chance to resolve
 * an argument value before the standard argument handling kicks in.
 */
public void setCustomArgumentResolvers(WebArgumentResolver[] argumentResolvers) {
    this.customArgumentResolvers = argumentResolvers;
}

/**
 * Set a custom ModelAndViewResolvers to use for special method return types.
 * &amp;lt;p&amp;gt;Such a custom ModelAndViewResolver will kick in first, having a chance to resolve
 * a return value before the standard ModelAndView handling kicks in.
 */
public void setCustomModelAndViewResolver(ModelAndViewResolver customModelAndViewResolver) {
    this.customModelAndViewResolvers = new ModelAndViewResolver[] {customModelAndViewResolver};
}

/**
 * Set one or more custom ModelAndViewResolvers to use for special method return types.
 * &amp;lt;p&amp;gt;Any such custom ModelAndViewResolver will kick in first, having a chance to resolve
 * a return value before the standard ModelAndView handling kicks in.
 */
public void setCustomModelAndViewResolvers(ModelAndViewResolver[] customModelAndViewResolvers) {
    this.customModelAndViewResolvers = customModelAndViewResolvers;
}

/**
 * Set the message body converters to use.
 * &amp;lt;p&amp;gt;These converters are used to convert from and to HTTP requests and responses.
 */
public void setMessageConverters(HttpMessageConverter&amp;lt;?&amp;gt;[] messageConverters) {
    this.messageConverters = messageConverters;
}

/**
 * Return the message body converters that this adapter has been configured with.
 */
public HttpMessageConverter&amp;lt;?&amp;gt;[] getMessageConverters() {
    return messageConverters;
}

/**
 * Specify the order value for this HandlerAdapter bean.
 * &amp;lt;p&amp;gt;Default value is &amp;lt;code&amp;gt;Integer.MAX_VALUE&amp;lt;/code&amp;gt;, meaning that it&amp;#39;s non-ordered.
 * @see org.springframework.core.Ordered#getOrder()
 */
public void setOrder(int order) {
    this.order = order;
}

public int getOrder() {
    return this.order;
}

public void setBeanFactory(BeanFactory beanFactory) {
    if (beanFactory instanceof ConfigurableBeanFactory) {
        this.beanFactory = (ConfigurableBeanFactory) beanFactory;
        this.expressionContext = new BeanExpressionContext(this.beanFactory, new RequestScope());
    }
}


public boolean supports(Object handler) {
    return getMethodResolver(handler).hasHandlerMethods();
}

public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
        throws Exception {

    if (AnnotationUtils.findAnnotation(handler.getClass(), SessionAttributes.class) != null) {
        // Always prevent caching in case of session attribute management.
        checkAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true);
        // Prepare cached set of session attributes names.
    }
    else {
        // Uses configured default cacheSeconds setting.
        checkAndPrepare(request, response, true);
    }

    // Execute invokeHandlerMethod in synchronized block if required.
    if (this.synchronizeOnSession) {
        HttpSession session = request.getSession(false);
        if (session != null) {
            Object mutex = WebUtils.getSessionMutex(session);
            synchronized (mutex) {
                return invokeHandlerMethod(request, response, handler);
            }
        }
    }

    return invokeHandlerMethod(request, response, handler);
}

protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, Object handler)
        throws Exception {

    ServletHandlerMethodResolver methodResolver = getMethodResolver(handler);
    Method handlerMethod = methodResolver.resolveHandlerMethod(request);
    ServletHandlerMethodInvoker methodInvoker = new ServletHandlerMethodInvoker(methodResolver);
    ServletWebRequest webRequest = new ServletWebRequest(request, response);
    ExtendedModelMap implicitModel = new BindingAwareModelMap();

    Object result = methodInvoker.invokeHandlerMethod(handlerMethod, handler, webRequest, implicitModel);
    ModelAndView mav =
            methodInvoker.getModelAndView(handlerMethod, handler.getClass(), result, implicitModel, webRequest);
    methodInvoker.updateModelAttributes(handler, (mav != null ? mav.getModel() : null), implicitModel, webRequest);
    return mav;
}

public long getLastModified(HttpServletRequest request, Object handler) {
    return -1;
}

/**
 * Build a HandlerMethodResolver for the given handler type.
 */
private ServletHandlerMethodResolver getMethodResolver(Object handler) {
    Class handlerClass = ClassUtils.getUserClass(handler);
    ServletHandlerMethodResolver resolver = this.methodResolverCache.get(handlerClass);
    if (resolver == null) {
        resolver = new ServletHandlerMethodResolver(handlerClass);
        this.methodResolverCache.put(handlerClass, resolver);
    }
    return resolver;
}


/**
 * Template method for creating a new ServletRequestDataBinder instance.
 * &amp;lt;p&amp;gt;The default implementation creates a standard ServletRequestDataBinder.
 * This can be overridden for custom ServletRequestDataBinder subclasses.
 * @param request current HTTP request
 * @param target the target object to bind onto (or &amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt;
 * if the binder is just used to convert a plain parameter value)
 * @param objectName the objectName of the target object
 * @return the ServletRequestDataBinder instance to use
 * @throws Exception in case of invalid state or arguments
 * @see ServletRequestDataBinder#bind(javax.servlet.ServletRequest)
 * @see ServletRequestDataBinder#convertIfNecessary(Object, Class, org.springframework.core.MethodParameter) 
 */
protected ServletRequestDataBinder createBinder(HttpServletRequest request, Object target, String objectName)
        throws Exception {
    return new ServletRequestDataBinder(target, objectName);
}

/**
 * Template method for creating a new HttpInputMessage instance.
 * &amp;lt;p&amp;gt;The default implementation creates a standard {@link ServletServerHttpRequest}.
 * This can be overridden for custom {@code HttpInputMessage} implementations
 * @param servletRequest current HTTP request
 * @return the HttpInputMessage instance to use
 * @throws Exception in case of errors
 */
protected HttpInputMessage createHttpInputMessage(HttpServletRequest servletRequest) throws Exception {
    return new ServletServerHttpRequest(servletRequest);
}

/**
 * Template method for creating a new HttpOuputMessage instance.
 * &amp;lt;p&amp;gt;The default implementation creates a standard {@link ServletServerHttpResponse}.
 * This can be overridden for custom {@code HttpOutputMessage} implementations
 * @param servletResponse current HTTP response
 * @return the HttpInputMessage instance to use
 * @throws Exception in case of errors
 */
protected HttpOutputMessage createHttpOutputMessage(HttpServletResponse servletResponse) throws Exception {
    return new ServletServerHttpResponse(servletResponse);
}


/**
 * Servlet-specific subclass of {@link HandlerMethodResolver}.
 */
private class ServletHandlerMethodResolver extends HandlerMethodResolver {

    private final Map&amp;lt;Method, RequestMappingInfo&amp;gt; mappings = new HashMap&amp;lt;Method, RequestMappingInfo&amp;gt;();

    private ServletHandlerMethodResolver(Class&amp;lt;?&amp;gt; handlerType) {
        init(handlerType);
    }

    @Override
    protected boolean isHandlerMethod(Method method) {
        if (this.mappings.containsKey(method)) {
            return true;
        }
        RequestMapping mapping = AnnotationUtils.findAnnotation(method, RequestMapping.class);
        if (mapping != null) {
            RequestMappingInfo mappingInfo = new RequestMappingInfo();
            mappingInfo.patterns = mapping.value();
            if (!hasTypeLevelMapping() || !Arrays.equals(mapping.method(), getTypeLevelMapping().method())) {
                mappingInfo.methods = mapping.method();
            }
            if (!hasTypeLevelMapping() || !Arrays.equals(mapping.params(), getTypeLevelMapping().params())) {
                mappingInfo.params = mapping.params();
            }
            if (!hasTypeLevelMapping() || !Arrays.equals(mapping.headers(), getTypeLevelMapping().headers())) {
                mappingInfo.headers = mapping.headers();
            }
            this.mappings.put(method, mappingInfo);
            return true;
        }
        return false;
    }

    public Method resolveHandlerMethod(HttpServletRequest request) throws ServletException {
        String lookupPath = urlPathHelper.getLookupPathForRequest(request);
        Comparator&amp;lt;String&amp;gt; pathComparator = pathMatcher.getPatternComparator(lookupPath);
        Map&amp;lt;RequestMappingInfo, Method&amp;gt; targetHandlerMethods = new LinkedHashMap&amp;lt;RequestMappingInfo, Method&amp;gt;();
        Set&amp;lt;String&amp;gt; allowedMethods = new LinkedHashSet&amp;lt;String&amp;gt;(7);
        String resolvedMethodName = null;
        for (Method handlerMethod : getHandlerMethods()) {
            RequestMappingInfo mappingInfo = this.mappings.get(handlerMethod);
            boolean match = false;
            if (mappingInfo.hasPatterns()) {
                List&amp;lt;String&amp;gt; matchingPatterns = new ArrayList&amp;lt;String&amp;gt;(mappingInfo.patterns.length);
                for (String pattern : mappingInfo.patterns) {
                    if (!hasTypeLevelMapping() &amp;amp;&amp;amp; !pattern.startsWith(&amp;quot;/&amp;quot;)) {
                        pattern = &amp;quot;/&amp;quot; + pattern;
                    }
                    String combinedPattern = getCombinedPattern(pattern, lookupPath, request);
                    if (combinedPattern != null) {
                        if (mappingInfo.matches(request)) {
                            match = true;
                            matchingPatterns.add(combinedPattern);
                        }
                        else {
                            if (!mappingInfo.matchesRequestMethod(request)) {
                                allowedMethods.addAll(mappingInfo.methodNames());
                            }
                            break;
                        }
                    }
                }
                Collections.sort(matchingPatterns, pathComparator);
                mappingInfo.matchedPatterns = matchingPatterns;
            }
            else {
                // No paths specified: parameter match sufficient.
                match = mappingInfo.matches(request);
                if (match &amp;amp;&amp;amp; mappingInfo.methods.length == 0 &amp;amp;&amp;amp; mappingInfo.params.length == 0 &amp;amp;&amp;amp;
                        resolvedMethodName != null &amp;amp;&amp;amp; !resolvedMethodName.equals(handlerMethod.getName())) {
                    match = false;
                }
                else {
                    if (!mappingInfo.matchesRequestMethod(request)) {
                        allowedMethods.addAll(mappingInfo.methodNames());
                    }
                }
            }
            if (match) {
                Method oldMappedMethod = targetHandlerMethods.put(mappingInfo, handlerMethod);
                if (oldMappedMethod != null &amp;amp;&amp;amp; oldMappedMethod != handlerMethod) {
                    if (methodNameResolver != null &amp;amp;&amp;amp; mappingInfo.patterns.length == 0) {
                        if (!oldMappedMethod.getName().equals(handlerMethod.getName())) {
                            if (resolvedMethodName == null) {
                                resolvedMethodName = methodNameResolver.getHandlerMethodName(request);
                            }
                            if (!resolvedMethodName.equals(oldMappedMethod.getName())) {
                                oldMappedMethod = null;
                            }
                            if (!resolvedMethodName.equals(handlerMethod.getName())) {
                                if (oldMappedMethod != null) {
                                    targetHandlerMethods.put(mappingInfo, oldMappedMethod);
                                    oldMappedMethod = null;
                                }
                                else {
                                    targetHandlerMethods.remove(mappingInfo);
                                }
                            }
                        }
                    }
                    if (oldMappedMethod != null) {
                        throw new IllegalStateException(
                                &amp;quot;Ambiguous handler methods mapped for HTTP path &amp;#39;&amp;quot; + lookupPath + &amp;quot;&amp;#39;: {&amp;quot; +
                                        oldMappedMethod + &amp;quot;, &amp;quot; + handlerMethod +
                                        &amp;quot;}. If you intend to handle the same path in multiple methods, then factor &amp;quot; +
                                        &amp;quot;them out into a dedicated handler class with that path mapped at the type level!&amp;quot;);
                    }
                }
            }
        }
        if (!targetHandlerMethods.isEmpty()) {
            List&amp;lt;RequestMappingInfo&amp;gt; matches = new ArrayList&amp;lt;RequestMappingInfo&amp;gt;(targetHandlerMethods.keySet());
            RequestMappingInfoComparator requestMappingInfoComparator =
                    new RequestMappingInfoComparator(pathComparator, request);
            Collections.sort(matches, requestMappingInfoComparator);
            RequestMappingInfo bestMappingMatch = matches.get(0);
            String bestMatchedPath = bestMappingMatch.bestMatchedPattern();
            if (bestMatchedPath != null) {
                //validate permission
                permissionService.isPermit(request, bestMatchedPath ,bestMappingMatch.patterns[0]);
                extractHandlerMethodUriTemplates(bestMatchedPath, lookupPath, request);
            }
            return targetHandlerMethods.get(bestMappingMatch);
        }
        else {
            if (!allowedMethods.isEmpty()) {
                throw new HttpRequestMethodNotSupportedException(request.getMethod(),
                        StringUtils.toStringArray(allowedMethods));
            }
            throw new NoSuchRequestHandlingMethodException(lookupPath, request.getMethod(),
                    request.getParameterMap());
        }
    }

    /**
     * Determines the combined pattern for the given methodLevelPattern and path.
     * &amp;lt;p&amp;gt;Uses the following algorithm: &amp;lt;ol&amp;gt;
     * &amp;lt;li&amp;gt;If there is a type-level mapping with path information, it is {@linkplain
     * PathMatcher#combine(String, String) combined} with the method-level pattern.&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;If there is a {@linkplain HandlerMapping#BEST_MATCHING_PATTERN_ATTRIBUTE best matching pattern} in the
     * request, it is combined with the method-level pattern.&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;Otherwise, the method-level pattern is returned.&amp;lt;/li&amp;gt;
     * &amp;lt;/ol&amp;gt;
     */
    private String getCombinedPattern(String methodLevelPattern, String lookupPath, HttpServletRequest request) {
        if (hasTypeLevelMapping() &amp;amp;&amp;amp; (!ObjectUtils.isEmpty(getTypeLevelMapping().value()))) {
            String[] typeLevelPatterns = getTypeLevelMapping().value();
            for (String typeLevelPattern : typeLevelPatterns) {
                if (!typeLevelPattern.startsWith(&amp;quot;/&amp;quot;)) {
                    typeLevelPattern = &amp;quot;/&amp;quot; + typeLevelPattern;
                }
                String combinedPattern = pathMatcher.combine(typeLevelPattern, methodLevelPattern);
                if (isPathMatchInternal(combinedPattern, lookupPath)) {
                    return combinedPattern;
                }
            }
            return null;
        }
        String bestMatchingPattern = (String) request.getAttribute(HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE);
        if (StringUtils.hasText(bestMatchingPattern) &amp;amp;&amp;amp; bestMatchingPattern.endsWith(&amp;quot;*&amp;quot;)) {
            String combinedPattern = pathMatcher.combine(bestMatchingPattern, methodLevelPattern);
            if (!combinedPattern.equals(bestMatchingPattern) &amp;amp;&amp;amp;
                    (isPathMatchInternal(combinedPattern, lookupPath))) {
                return combinedPattern;
            }
        }
        if (isPathMatchInternal(methodLevelPattern, lookupPath)) {
            return methodLevelPattern;
        }
        return null;
    }

    private boolean isPathMatchInternal(String pattern, String lookupPath) {
        if (pattern.equals(lookupPath) || pathMatcher.match(pattern, lookupPath)) {
            return true;
        }
        boolean hasSuffix = pattern.indexOf(&amp;#39;.&amp;#39;) != -1;
        if (!hasSuffix &amp;amp;&amp;amp; pathMatcher.match(pattern + &amp;quot;.*&amp;quot;, lookupPath)) {
            return true;
        }
        boolean endsWithSlash = pattern.endsWith(&amp;quot;/&amp;quot;);
        if (!endsWithSlash &amp;amp;&amp;amp; pathMatcher.match(pattern + &amp;quot;/&amp;quot;, lookupPath)) {
            return true;
        }
        return false;
    }

    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    private void extractHandlerMethodUriTemplates(String mappedPattern,
            String lookupPath,
            HttpServletRequest request) {

        Map&amp;lt;String, String&amp;gt; variables =
                (Map&amp;lt;String, String&amp;gt;) request.getAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE);

        int patternVariableCount = StringUtils.countOccurrencesOf(mappedPattern, &amp;quot;{&amp;quot;);

        if ( (variables == null || patternVariableCount != variables.size())  
                &amp;amp;&amp;amp; pathMatcher.match(mappedPattern, lookupPath)) {
            variables = pathMatcher.extractUriTemplateVariables(mappedPattern, lookupPath);
            request.setAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, variables);
        }
    }
}


/**
 * Servlet-specific subclass of {@link HandlerMethodInvoker}.
 */
private class ServletHandlerMethodInvoker extends HandlerMethodInvoker {

    private boolean responseArgumentUsed = false;

    private ServletHandlerMethodInvoker(HandlerMethodResolver resolver) {
        super(resolver, webBindingInitializer, sessionAttributeStore, parameterNameDiscoverer,
                customArgumentResolvers, messageConverters);
    }

    @Override
    protected void raiseMissingParameterException(String paramName, Class paramType) throws Exception {
        throw new MissingServletRequestParameterException(paramName, paramType.getSimpleName());
    }

    @Override
    protected void raiseSessionRequiredException(String message) throws Exception {
        throw new HttpSessionRequiredException(message);
    }

    @Override
    protected WebDataBinder createBinder(NativeWebRequest webRequest, Object target, String objectName)
            throws Exception {

        return AnnotationMethodHandlerAdapter.this.createBinder(
                webRequest.getNativeRequest(HttpServletRequest.class), target, objectName);
    }

    @Override
    protected void doBind(WebDataBinder binder, NativeWebRequest webRequest) throws Exception {
        ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
        servletBinder.bind(webRequest.getNativeRequest(ServletRequest.class));
    }

    @Override
    protected HttpInputMessage createHttpInputMessage(NativeWebRequest webRequest) throws Exception {
        HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);
        return AnnotationMethodHandlerAdapter.this.createHttpInputMessage(servletRequest);
    }

    @Override
    protected HttpOutputMessage createHttpOutputMessage(NativeWebRequest webRequest) throws Exception {
        HttpServletResponse servletResponse = (HttpServletResponse) webRequest.getNativeResponse();
        return AnnotationMethodHandlerAdapter.this.createHttpOutputMessage(servletResponse);
    }

    @Override
    protected Object resolveDefaultValue(String value) {
        if (beanFactory == null) {
            return value;
        }
        String placeholdersResolved = beanFactory.resolveEmbeddedValue(value);
        BeanExpressionResolver exprResolver = beanFactory.getBeanExpressionResolver();
        if (exprResolver == null) {
            return value;
        }
        return exprResolver.evaluate(placeholdersResolved, expressionContext);
    }

    @Override
    protected Object resolveCookieValue(String cookieName, Class paramType, NativeWebRequest webRequest)
            throws Exception {

        HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);
        Cookie cookieValue = WebUtils.getCookie(servletRequest, cookieName);
        if (Cookie.class.isAssignableFrom(paramType)) {
            return cookieValue;
        }
        else if (cookieValue != null) {
            return urlPathHelper.decodeRequestString(servletRequest, cookieValue.getValue());
        }
        else {
            return null;
        }
    }

    @Override
    @SuppressWarnings({&amp;quot;unchecked&amp;quot;})
    protected String resolvePathVariable(String pathVarName, Class paramType, NativeWebRequest webRequest)
            throws Exception {

        HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);
        Map&amp;lt;String, String&amp;gt; uriTemplateVariables =
                (Map&amp;lt;String, String&amp;gt;) servletRequest.getAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE);
        if (uriTemplateVariables == null || !uriTemplateVariables.containsKey(pathVarName)) {
            throw new IllegalStateException(
                    &amp;quot;Could not find @PathVariable [&amp;quot; + pathVarName + &amp;quot;] in @RequestMapping&amp;quot;);
        }
        return uriTemplateVariables.get(pathVarName);
    }

    @Override
    protected Object resolveStandardArgument(Class&amp;lt;?&amp;gt; parameterType, NativeWebRequest webRequest) throws Exception {
        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
        HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);

        if (ServletRequest.class.isAssignableFrom(parameterType) ||
                MultipartRequest.class.isAssignableFrom(parameterType)) {
            Object nativeRequest = webRequest.getNativeRequest(parameterType);
            if (nativeRequest == null) {
                throw new IllegalStateException(
                        &amp;quot;Current request is not of type [&amp;quot; + parameterType.getName() + &amp;quot;]: &amp;quot; + request);
            }
            return nativeRequest;
        }
        else if (ServletResponse.class.isAssignableFrom(parameterType)) {
            this.responseArgumentUsed = true;
            Object nativeResponse = webRequest.getNativeResponse(parameterType);
            if (nativeResponse == null) {
                throw new IllegalStateException(
                        &amp;quot;Current response is not of type [&amp;quot; + parameterType.getName() + &amp;quot;]: &amp;quot; + response);
            }
            return nativeResponse;
        }
        else if (HttpSession.class.isAssignableFrom(parameterType)) {
            return request.getSession();
        }
        else if (Principal.class.isAssignableFrom(parameterType)) {
            return request.getUserPrincipal();
        }
        else if (Locale.class.equals(parameterType)) {
            return RequestContextUtils.getLocale(request);
        }
        else if (InputStream.class.isAssignableFrom(parameterType)) {
            return request.getInputStream();
        }
        else if (Reader.class.isAssignableFrom(parameterType)) {
            return request.getReader();
        }
        else if (OutputStream.class.isAssignableFrom(parameterType)) {
            this.responseArgumentUsed = true;
            return response.getOutputStream();
        }
        else if (Writer.class.isAssignableFrom(parameterType)) {
            this.responseArgumentUsed = true;
            return response.getWriter();
        }
        return super.resolveStandardArgument(parameterType, webRequest);
    }

    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public ModelAndView getModelAndView(Method handlerMethod, Class handlerType, Object returnValue,
            ExtendedModelMap implicitModel, ServletWebRequest webRequest) throws Exception {

        ResponseStatus responseStatusAnn = AnnotationUtils.findAnnotation(handlerMethod, ResponseStatus.class);
        if (responseStatusAnn != null) {
            HttpStatus responseStatus = responseStatusAnn.value();
            String reason = responseStatusAnn.reason();
            if (!StringUtils.hasText(reason)) {
                webRequest.getResponse().setStatus(responseStatus.value());
            }
            else {
                webRequest.getResponse().sendError(responseStatus.value(), reason);
            }

            // to be picked up by the RedirectView
            webRequest.getRequest().setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, responseStatus);

            responseArgumentUsed = true;
        }

        // Invoke custom resolvers if present...
        if (customModelAndViewResolvers != null) {
            for (ModelAndViewResolver mavResolver : customModelAndViewResolvers) {
                ModelAndView mav = mavResolver.resolveModelAndView(
                        handlerMethod, handlerType, returnValue, implicitModel, webRequest);
                if (mav != ModelAndViewResolver.UNRESOLVED) {
                    return mav;
                }
            }
        }

        if (returnValue instanceof HttpEntity) {
            handleHttpEntityResponse((HttpEntity&amp;lt;?&amp;gt;) returnValue, webRequest);
            return null;
        }
        else if (AnnotationUtils.findAnnotation(handlerMethod, ResponseBody.class) != null) {
            handleResponseBody(returnValue, webRequest);
            return null;
        }
        else if (returnValue instanceof ModelAndView) {
            ModelAndView mav = (ModelAndView) returnValue;
            mav.getModelMap().mergeAttributes(implicitModel);
            return mav;
        }
        else if (returnValue instanceof Model) {
            return new ModelAndView().addAllObjects(implicitModel).addAllObjects(((Model) returnValue).asMap());
        }
        else if (returnValue instanceof View) {
            return new ModelAndView((View) returnValue).addAllObjects(implicitModel);
        }
        else if (AnnotationUtils.findAnnotation(handlerMethod, ModelAttribute.class) != null) {
            addReturnValueAsModelAttribute(handlerMethod, handlerType, returnValue, implicitModel);
            return new ModelAndView().addAllObjects(implicitModel);
        }
        else if (returnValue instanceof Map) {
            return new ModelAndView().addAllObjects(implicitModel).addAllObjects((Map) returnValue);
        }
        else if (returnValue instanceof String) {
            return new ModelAndView((String) returnValue).addAllObjects(implicitModel);
        }
        else if (returnValue == null) {
            // Either returned null or was &amp;#39;void&amp;#39; return.
            if (this.responseArgumentUsed || webRequest.isNotModified()) {
                return null;
            }
            else {
                // Assuming view name translation...
                return new ModelAndView().addAllObjects(implicitModel);
            }
        }
        else if (!BeanUtils.isSimpleProperty(returnValue.getClass())) {
            // Assume a single model attribute...
            addReturnValueAsModelAttribute(handlerMethod, handlerType, returnValue, implicitModel);
            return new ModelAndView().addAllObjects(implicitModel);
        }
        else {
            throw new IllegalArgumentException(&amp;quot;Invalid handler method return value: &amp;quot; + returnValue);
        }
    }

    private void handleResponseBody(Object returnValue, ServletWebRequest webRequest)
            throws Exception {
        if (returnValue == null) {
            return;
        }
        HttpInputMessage inputMessage = createHttpInputMessage(webRequest);
        HttpOutputMessage outputMessage = createHttpOutputMessage(webRequest);
        writeWithMessageConverters(returnValue, inputMessage, outputMessage);
    }

    private void handleHttpEntityResponse(HttpEntity&amp;lt;?&amp;gt; responseEntity, ServletWebRequest webRequest)
            throws Exception {
        if (responseEntity == null) {
            return;
        }
        HttpInputMessage inputMessage = createHttpInputMessage(webRequest);
        HttpOutputMessage outputMessage = createHttpOutputMessage(webRequest);
        if (responseEntity instanceof ResponseEntity &amp;amp;&amp;amp; outputMessage instanceof ServerHttpResponse) {
            ((ServerHttpResponse)outputMessage).setStatusCode(((ResponseEntity) responseEntity).getStatusCode());
        }
        HttpHeaders entityHeaders = responseEntity.getHeaders();
        if (!entityHeaders.isEmpty()) {
            outputMessage.getHeaders().putAll(entityHeaders);
        }
        Object body = responseEntity.getBody();
        if (body != null) {
            writeWithMessageConverters(body, inputMessage, outputMessage);
        }
        else {
            // flush headers
            outputMessage.getBody();
        }
    }

    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    private void writeWithMessageConverters(Object returnValue,
            HttpInputMessage inputMessage, HttpOutputMessage outputMessage)
            throws IOException, HttpMediaTypeNotAcceptableException {
        List&amp;lt;MediaType&amp;gt; acceptedMediaTypes = inputMessage.getHeaders().getAccept();
        if (acceptedMediaTypes.isEmpty()) {
            acceptedMediaTypes = Collections.singletonList(MediaType.ALL);
        }
        MediaType.sortByQualityValue(acceptedMediaTypes);
        Class&amp;lt;?&amp;gt; returnValueType = returnValue.getClass();
        List&amp;lt;MediaType&amp;gt; allSupportedMediaTypes = new ArrayList&amp;lt;MediaType&amp;gt;();
        if (getMessageConverters() != null) {
            for (MediaType acceptedMediaType : acceptedMediaTypes) {
                for (HttpMessageConverter messageConverter : getMessageConverters()) {
                    if (messageConverter.canWrite(returnValueType, acceptedMediaType)) {
                        messageConverter.write(returnValue, acceptedMediaType, outputMessage);
                        if (logger.isDebugEnabled()) {
                            MediaType contentType = outputMessage.getHeaders().getContentType();
                            if (contentType == null) {
                                contentType = acceptedMediaType;
                            }
                            logger.debug(&amp;quot;Written [&amp;quot; + returnValue + &amp;quot;] as \&amp;quot;&amp;quot; + contentType +
                                    &amp;quot;\&amp;quot; using [&amp;quot; + messageConverter + &amp;quot;]&amp;quot;);
                        }
                        this.responseArgumentUsed = true;
                        return;
                    }
                }
            }
            for (HttpMessageConverter messageConverter : messageConverters) {
                allSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes());
            }
        }
        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);
    }

}


/**
 * Holder for request mapping metadata. Allows for finding a best matching candidate.
 */
static class RequestMappingInfo {

    String[] patterns = new String[0];

    List&amp;lt;String&amp;gt; matchedPatterns = Collections.emptyList();

    RequestMethod[] methods = new RequestMethod[0];

    String[] params = new String[0];

    String[] headers = new String[0];

    public boolean hasPatterns() {
        return patterns.length &amp;gt; 0;
    }

    public String bestMatchedPattern() {
        return (!this.matchedPatterns.isEmpty() ? this.matchedPatterns.get(0) : null);
    }

    public boolean matches(HttpServletRequest request) {
        return matchesRequestMethod(request) &amp;amp;&amp;amp; matchesParameters(request) &amp;amp;&amp;amp; matchesHeaders(request);
    }

    public boolean matchesHeaders(HttpServletRequest request) {
        return checkHeaders(this.headers, request);
    }

    public boolean matchesParameters(HttpServletRequest request) {
        return checkParameters(this.params, request);
    }

    public boolean matchesRequestMethod(HttpServletRequest request) {
        return checkRequestMethod(this.methods, request);
    }

    public Set&amp;lt;String&amp;gt; methodNames() {
        Set&amp;lt;String&amp;gt; methodNames = new LinkedHashSet&amp;lt;String&amp;gt;(methods.length);
        for (RequestMethod method : methods) {
            methodNames.add(method.name());
        }
        return methodNames;
    }

    @Override
    public boolean equals(Object obj) {
        RequestMappingInfo other = (RequestMappingInfo) obj;
        return (Arrays.equals(this.patterns, other.patterns) &amp;amp;&amp;amp; Arrays.equals(this.methods, other.methods) &amp;amp;&amp;amp;
                Arrays.equals(this.params, other.params) &amp;amp;&amp;amp; Arrays.equals(this.headers, other.headers));
    }

    @Override
    public int hashCode() {
        return (Arrays.hashCode(this.patterns) * 23 + Arrays.hashCode(this.methods) * 29 +
                Arrays.hashCode(this.params) * 31 + Arrays.hashCode(this.headers));
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append(Arrays.asList(patterns));
        if (methods.length &amp;gt; 0) {
            builder.append(&amp;#39;,&amp;#39;);
            builder.append(Arrays.asList(methods));
        }
        if (headers.length &amp;gt; 0) {
            builder.append(&amp;#39;,&amp;#39;);
            builder.append(Arrays.asList(headers));
        }
        if (params.length &amp;gt; 0) {
            builder.append(&amp;#39;,&amp;#39;);
            builder.append(Arrays.asList(params));
        }
        return builder.toString();
    }
}


/**
 * Comparator capable of sorting {@link RequestMappingInfo}s (RHIs) so that sorting a list with this comparator will
 * result in:
 * &amp;lt;ul&amp;gt;
 * &amp;lt;li&amp;gt;RHIs with {@linkplain RequestMappingInfo#matchedPatterns better matched paths} take prescedence
 * over those with a weaker match (as expressed by the {@linkplain PathMatcher#getPatternComparator(String) path
 * pattern comparator}.) Typically, this means that patterns without wild cards and uri templates will be ordered
 * before those without.&amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;RHIs with one single {@linkplain RequestMappingInfo#methods request method} will be
 * ordered before those without a method, or with more than one method.&amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;RHIs with more {@linkplain RequestMappingInfo#params request parameters} will be ordered before those with
 * less parameters&amp;lt;/li&amp;gt;
 * &amp;lt;/ol&amp;gt;
 */
static class RequestMappingInfoComparator implements Comparator&amp;lt;RequestMappingInfo&amp;gt; {

    private final Comparator&amp;lt;String&amp;gt; pathComparator;

    private final ServerHttpRequest request;

    RequestMappingInfoComparator(Comparator&amp;lt;String&amp;gt; pathComparator, HttpServletRequest request) {
        this.pathComparator = pathComparator;
        this.request = new ServletServerHttpRequest(request);
    }

    public int compare(RequestMappingInfo info1, RequestMappingInfo info2) {
        int pathComparison = pathComparator.compare(info1.bestMatchedPattern(), info2.bestMatchedPattern());
        if (pathComparison != 0) {
            return pathComparison;
        }
        int info1ParamCount = info1.params.length;
        int info2ParamCount = info2.params.length;
        if (info1ParamCount != info2ParamCount) {
            return info2ParamCount - info1ParamCount;
        }
        int info1HeaderCount = info1.headers.length;
        int info2HeaderCount = info2.headers.length;
        if (info1HeaderCount != info2HeaderCount) {
            return info2HeaderCount - info1HeaderCount;
        }
        int acceptComparison = compareAcceptHeaders(info1, info2);
        if (acceptComparison != 0) {
            return acceptComparison;
        }
        int info1MethodCount = info1.methods.length;
        int info2MethodCount = info2.methods.length;
        if (info1MethodCount == 0 &amp;amp;&amp;amp; info2MethodCount &amp;gt; 0) {
            return 1;
        }
        else if (info2MethodCount == 0 &amp;amp;&amp;amp; info1MethodCount &amp;gt; 0) {
            return -1;
        }
        else if (info1MethodCount == 1 &amp;amp; info2MethodCount &amp;gt; 1) {
            return -1;
        }
        else if (info2MethodCount == 1 &amp;amp; info1MethodCount &amp;gt; 1) {
            return 1;
        }
        return 0;
    }

    private int compareAcceptHeaders(RequestMappingInfo info1, RequestMappingInfo info2) {
        List&amp;lt;MediaType&amp;gt; requestAccepts = request.getHeaders().getAccept();
        MediaType.sortByQualityValue(requestAccepts);

        List&amp;lt;MediaType&amp;gt; info1Accepts = getAcceptHeaderValue(info1);
        List&amp;lt;MediaType&amp;gt; info2Accepts = getAcceptHeaderValue(info2);

        for (MediaType requestAccept : requestAccepts) {
            int pos1 = indexOfIncluded(info1Accepts, requestAccept);
            int pos2 = indexOfIncluded(info2Accepts, requestAccept);
            if (pos1 != pos2) {
                return pos2 - pos1;
            }
        }
        return 0;
    }

    private int indexOfIncluded(List&amp;lt;MediaType&amp;gt; infoAccepts, MediaType requestAccept) {
        for (int i = 0; i &amp;lt; infoAccepts.size(); i++) {
            MediaType info1Accept = infoAccepts.get(i);
            if (requestAccept.includes(info1Accept)) {
                return i;
            }
        }
        return -1;
    }

    private List&amp;lt;MediaType&amp;gt; getAcceptHeaderValue(RequestMappingInfo info) {
        for (String header : info.headers) {
            int separator = header.indexOf(&amp;#39;=&amp;#39;);
            if (separator != -1) {
                String key = header.substring(0, separator);
                String value = header.substring(separator + 1);
                if (&amp;quot;Accept&amp;quot;.equalsIgnoreCase(key)) {
                    return MediaType.parseMediaTypes(value);
                }
            }
        }
        return Collections.emptyList();
    }
}





///----------------------org.springframework.web.servlet.mvc.annotation.ServletAnnotationMappingUtils--------------///
/**
 * Check whether the given request matches the specified request methods.
 * @param methods the HTTP request methods to check against
 * @param request the current HTTP request to check
 */
public static boolean checkRequestMethod(RequestMethod[] methods, HttpServletRequest request) {
    if (ObjectUtils.isEmpty(methods)) {
        return true;
    }
    for (RequestMethod method : methods) {
        if (method.name().equals(request.getMethod())) {
            return true;
        }
    }
    return false;
}

/**
 * Check whether the given request matches the specified parameter conditions.
 * @param params the parameter conditions, following {@link RequestMapping#params()}
 * @param request the current HTTP request to check
 */
public static boolean checkParameters(String[] params, HttpServletRequest request) {
    if (!ObjectUtils.isEmpty(params)) {
        for (String param : params) {
            int separator = param.indexOf(&amp;#39;=&amp;#39;);
            if (separator == -1) {
                if (param.startsWith(&amp;quot;!&amp;quot;)) {
                    if (WebUtils.hasSubmitParameter(request, param.substring(1))) {
                        return false;
                    }
                }
                else if (!WebUtils.hasSubmitParameter(request, param)) {
                    return false;
                }
            }
            else {
                String key = param.substring(0, separator);
                String value = param.substring(separator + 1);
                if (!value.equals(request.getParameter(key))) {
                    return false;
                }
            }
        }
    }
    return true;
}

/**
 * Check whether the given request matches the specified header conditions.
 * @param headers the header conditions, following {@link RequestMapping#headers()}
 * @param request the current HTTP request to check
 */
public static boolean checkHeaders(String[] headers, HttpServletRequest request) {
    if (!ObjectUtils.isEmpty(headers)) {
        for (String header : headers) {
            int separator = header.indexOf(&amp;#39;=&amp;#39;);
            if (separator == -1) {
                if (header.startsWith(&amp;quot;!&amp;quot;)) {
                    if (request.getHeader(header.substring(1)) != null) {
                        return false;
                    }
                }
                else if (request.getHeader(header) == null) {
                    return false;
                }
            }
            else {
                String key = header.substring(0, separator);
                String value = header.substring(separator + 1);
                if (isMediaTypeHeader(key)) {
                    List&amp;lt;MediaType&amp;gt; requestMediaTypes = MediaType.parseMediaTypes(request.getHeader(key));
                    List&amp;lt;MediaType&amp;gt; valueMediaTypes = MediaType.parseMediaTypes(value);
                    boolean found = false;
                    for (Iterator&amp;lt;MediaType&amp;gt; valIter = valueMediaTypes.iterator(); valIter.hasNext() &amp;amp;&amp;amp; !found;) {
                        MediaType valueMediaType = valIter.next();
                        for (Iterator&amp;lt;MediaType&amp;gt; reqIter = requestMediaTypes.iterator(); reqIter.hasNext() &amp;amp;&amp;amp; !found;) {
                            MediaType requestMediaType = reqIter.next();
                            if (valueMediaType.includes(requestMediaType)) {
                                found = true;
                            }
                        }

                    }
                    if (!found) {
                        return false;
                    }
                }
                else if (!value.equals(request.getHeader(key))) {
                    return false;
                }
            }
        }
    }
    return true;
}

private static boolean isMediaTypeHeader(String headerName) {
    return &amp;quot;Accept&amp;quot;.equalsIgnoreCase(headerName) || &amp;quot;Content-Type&amp;quot;.equalsIgnoreCase(headerName);
}


public void setPermissionService(PermissionService permissionService) {
    this.permissionService = permissionService;
}
</code></pre>

<p>}</p>

<p></pre></p>

<pre><code>      &lt;br&gt;&lt;br&gt;
      作者: &lt;a href="http://jiangshaolin.javaeye.com"&gt;jiangshaolin&lt;/a&gt; 
      &lt;br&gt;
      声明: 本文系JavaEye网站发布的原创文章，未经作者书面许可，严禁任何网站转载本文，否则必将追究法律责任！
      &lt;br&gt;&lt;br&gt;
      &lt;span style="color:red"&gt;
        &lt;a href="http://www.javaeye.com/topic/780375" style="color:red"&gt;已有 &lt;strong&gt;0&lt;/strong&gt; 人发表回复，猛击-&amp;gt;&amp;gt;&lt;strong&gt;这里&lt;/strong&gt;&amp;lt;&amp;lt;-参与讨论&lt;/a&gt;
      &lt;/span&gt;
      &lt;br&gt;&lt;br&gt;&lt;br&gt;
</code></pre>

<p><span style="color:#e28822">JavaEye推荐</span>
<br></p>

<ul><li><a href="http://www.iteye.com/clicks/439"><span style="color:blue;font-weight:bold">限时报名参加Oracle技术大会</span></a></li><li><a href="http://www.iteye.com/clicks/433"><span style="color:red;font-weight:bold">—软件人才免语言低担保 赴美带薪读研！— </span></a></li><li><a href="http://www.iteye.com/clicks/138"><span style="color:red;font-weight:bold">上海：高薪诚聘php开发人员</span></a></li></ul>


<p><br><br><br></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
