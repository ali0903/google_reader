<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>为您详细比较三个 CSS 预处理器（框架）：Sass、LESS 和 Stylus</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>为您详细比较三个 CSS 预处理器（框架）：Sass、LESS 和 Stylus</h2>
<p class="meta">2013-01-13 18:54</p>

<div class="post">
<h2>为您详细比较三个 CSS 预处理器（框架）：Sass、LESS 和 Stylus</h2>

<h3>by 司徒正美</h3>

<h3>at 2013-01-13 10:54:00</h3>

<h3>original <a href="http://www.cnblogs.com/rubylouvre/archive/2013/01/13/2858251.html">http://www.cnblogs.com/rubylouvre/archive/2013/01/13/2858251.html</a></h3>

<p>CSS 预处理器技术已经非常的成熟，而且也涌现出了越来越多的 CSS 的预处理器框架。本文向你介绍使用最为普遍的三款 CSS 预处理器框架，分别是 Sass、Less CSS、Stylus。</p>


<p> <p>首先我们来简单介绍下什么是 CSS 预处理器，CSS 预处理器是一种语言用来为 CSS 增加一些编程的的特性，无需考虑浏览器的兼容性问题，例如你可以在 CSS 中使用变量、简单的程序逻辑、函数等等在编程语言中的一些基本技巧，可以让你的 CSS 更见简洁，适应性更强，代码更直观等诸多好处。</p> <p>不要再停留在石器时代了，下面让我们开始 CSS 预处理器之旅。</p> <p>我们将会从语法、变量、嵌套、混入(Mixin)、继承、导入、函数和操作符等方面分别对这三个框架进行比较介绍。</p> <p>语法</p> <p>在使用 CSS 预处理器之前最重要的是理解语法，幸运的是基本上大多数预处理器的语法跟 CSS 都差不多。</p> <p>首先 Sass 和 Less 都使用的是标准的 CSS 语法，因此如果你可以很方便的将已有的 CSS 代码转为预处理器代码，默认 Sass 使用 .sass 扩展名，而 Less 使用 .less 扩展名。</p> <p>下面是这二者的语法：</p> /<em> style.scss or style.less </em>/<br>h1 {<br>  color: #0982C1;<br>} <p> </p> <p>你注意到了，这是一个再普通不过的，不过 Sass 同时也支持老的语法，就是不包含花括号和分号的方式：</p> /<em> style.sass </em>/<br>h1<br>  color: #0982c1 <p> 而 Stylus 支持的语法要更多样性一点，它默认使用 .styl 的文件扩展名，下面是 Stylus 支持的语法：</p> /<em> style.styl </em>/<br>h1 {<br>  color: #0982C1;<br>}<br> <br>/<em> omit brackets </em>/<br>h1<br>  color: #0982C1;<br> <br>/<em> omit colons and semi-colons </em>/<br>h1<br>  color #0982C1 <p> 你也可以在同一个样式单中使用不同的变量，例如下面的写法也不会报错：</p> h1 {<br>  color #0982c1<br>}<br>h2<br>  font-size: 1.2em <p> <span style="font-weight:bold">变量</span></p> <p>你可以在 CSS 预处理器中声明变量，并在整个样式单中使用，支持任何类型的变量，例如颜色、数值（不管是否包括单位）、文本。然后你可以任意引用该变量。</p> <p>Sass 的变量必须是 $ 开始，然后变量名和值使用冒号隔开，跟 CSS 的属性一致：</p> $mainColor: #0982c1;<br>$siteWidth: 1024px;<br>$borderStyle: dotted;<br> <br>body {<br>  color: $mainColor;<br>  border: 1px $borderStyle $mainColor;<br>  max-width: $siteWidth;<br>} <p> 而 Less 的变量名使用 @ 符号开始：</p> @mainColor: #0982c1;<br>@siteWidth: 1024px;<br>@borderStyle: dotted;<br> <br>body {<br>  color: @mainColor;<br>  border: 1px @borderStyle @mainColor;<br>  max-width: @siteWidth;<br>} <p> Stylus 对变量名没有任何限定，你可以是 $ 开始，也可以是任意的字符，而且与变量值之间可以用冒号、空格隔开，需要注意的是 Stylus (0.22.4) 将会编译 @ 开始的变量，但其对应的值并不会赋予该变量，换句话说，在 Stylus 的变量名不要用 @ 开头。</p> mainColor = #0982c1<br>siteWidth = 1024px<br>$borderStyle = dotted<br> <br>body<br>  color mainColor<br>  border 1px $borderStyle mainColor<br>  max-width siteWidth <p> 上面的三种不同的 CSS 预处理器的写法，最终都将产生相同的结果：</p> body {<br>  color: #0982c1;<br>  border: 1px dotted #0982c1;<br>  max-width: 1024px;<br>} <p> 你可以想象，加入你的 CSS 中使用了某个颜色的地方多达数十次，那么要修改颜色时你必须找到这数十次的地方并一一修改，而有了 CSS 预处理器，修改一个地方就够了！</p> <p>嵌套</p> <p>如果我们需要在CSS中相同的 parent 引用多个元素，这将是非常乏味的，你需要一遍又一遍地写 parent。例如：</p> section {<br>  margin: 10px;<br>}<br>section nav {<br>  height: 25px;<br>}<br>section nav a {<br>  color: #0982C1;<br>}<br>section nav a:hover {<br>  text-decoration: underline;<br>} <p> 而如果用 CSS 预处理器，就可以少些很多单词，而且父子节点关系一目了然。我们这里提到的三个 CSS 框架都是允许嵌套语法：</p> section {<br>  margin: 10px;<br> <br>  nav {<br>    height: 25px;<br> <br>    a {<br>      color: #0982C1;<br> <br>      &amp;amp;:hover {<br>        text-decoration: underline;<br>      }<br>    }<br>  }<br>} <p> 最终生成的 CSS 结果是：</p> section {<br>  margin: 10px;<br>}<br>section nav {<br>  height: 25px;<br>}<br>section nav a {<br>  color: #0982C1;<br>}<br>section nav a:hover {<br>  text-decoration: underline;<br>} <p> 非常之方便！</p> <p><span style="font-weight:bold">Mixins (混入)</span></p> <p>Mixins 有点像是函数或者是宏，当你某段 CSS 经常需要在多个元素中使用时，你可以为这些共用的 CSS 定义一个 Mixin，然后你只需要在需要引用这些 CSS 地方调用该 Mixin 即可。</p> <p>Sass 的混入语法：</p> /<em> Sass mixin error with (optional) argument $borderWidth which defaults to 2px if not specified </em>/<br>@mixin error($borderWidth: 2px) {<br>  border: $borderWidth solid #F00;<br>  color: #F00;<br>}<br> <br>.generic-error {<br>  padding: 20px;<br>  margin: 4px;<br>  @ include error(); /<em> Applies styles from mixin error </em>/<br>}<br>.login-error {<br>  left: 12px;<br>  position: absolute;<br>  top: 20px;<br>  @ include error(5px); /<em> Applies styles from mixin error with argument $borderWidth equal to 5px</em>/<br>} <p> Less CSS 的混入语法：</p> /<em> LESS mixin error with (optional) argument @borderWidth which defaults to 2px if not specified </em>/<br>.error(@borderWidth: 2px) {<br>  border: @borderWidth solid #F00;<br>  color: #F00;<br>}<br> <br>.generic-error {<br>  padding: 20px;<br>  margin: 4px;<br>  .error(); /<em> Applies styles from mixin error </em>/<br>}<br>.login-error {<br>  left: 12px;<br>  position: absolute;<br>  top: 20px;<br>  .error(5px); /<em> Applies styles from mixin error with argument @borderWidth equal to 5px </em>/<br>} <p> Stylus 的混入语法：</p> /<em> Stylus mixin error with (optional) argument borderWidth which defaults to 2px if not specified </em>/<br>error(borderWidth= 2px) {<br>  border: borderWidth solid #F00;<br>  color: #F00;<br>}<br> <br>.generic-error {<br>  padding: 20px;<br>  margin: 4px;<br>  error(); /<em> Applies styles from mixin error </em>/<br>}<br>.login-error {<br>  left: 12px;<br>  position: absolute;<br>  top: 20px;<br>  error(5px); /<em> Applies styles from mixin error with argument borderWidth equal to 5px </em>/<br>} <p> 最终它们都将编译成如下的 CSS 样式：</p> .generic-error {<br>  padding: 20px;<br>  margin: 4px;<br>  border: 2px solid #f00;<br>  color: #f00;<br>}<br>.login-error {<br>  left: 12px;<br>  position: absolute;<br>  top: 20px;<br>  border: 5px solid #f00;<br>  color: #f00;<br>} <p> <span style="font-weight:bold">继承</span></p> <p>当我们需要为多个元素定义相同样式的时候，我们可以考虑使用继承的做法。例如我们经常需要：</p> p,<br>ul,<br>ol {<br>  /<em> styles here </em>/<br>} <p> 在 Sass 和 Stylus 我们可以这样写：</p> .block {<br>  margin: 10px 5px;<br>  padding: 2px;<br>}<br> <br>p {<br>  @extend .block; /<em> Inherit styles from '.block' </em>/<br>  border: 1px solid #EEE;<br>}<br>ul, ol {<br>  @extend .block; /<em> Inherit styles from '.block' </em>/<br>  color: #333;<br>  text-transform: uppercase;<br>} <p> 在这里首先定义 .block 块，然后让 p 、ul 和 ol 元素继承 .block ，最终生成的 CSS 如下：</p> .block, p, ul, ol {<br>  margin: 10px 5px;<br>  padding: 2px;<br>}<br>p {<br>  border: 1px solid #EEE;<br>}<br>ul, ol {<br>  color: #333;<br>  text-transform: uppercase;<br>} <p> 在这方面 Less 表现的稍微弱一些，更像是混入写法：</p> .block {<br>  margin: 10px 5px;<br>  padding: 2px;<br>}<br> <br>p {<br>  .block; /<em> Inherit styles from '.block' </em>/<br>  border: 1px solid #EEE;<br>}<br>ul, ol {<br>  .block; /<em> Inherit styles from '.block' </em>/<br>  color: #333;<br>  text-transform: uppercase;<br>} <p> 生成的 CSS 如下：</p> .block {<br>  margin: 10px 5px;<br>  padding: 2px;<br>}<br>p {<br>  margin: 10px 5px;<br>  padding: 2px;<br>  border: 1px solid #EEE;<br>}<br>ul,<br>ol {<br>  margin: 10px 5px;<br>  padding: 2px;<br>  color: #333;<br>  text-transform: uppercase;<br>} <p> 你所看到的上面的代码中，.block 的样式将会被插入到相应的你想要继承的选择器中，但需要注意的是优先级的问题。</p> <p>导入 (Import)</p> <p>很多 CSS 开发者对导入的做法都不太感冒，因为它需要多次的 HTTP 请求。但是在 CSS 预处理器中的导入操作则不同，它只是在语义上包含了不同的文件，但最终结果是一个单一的 CSS 文件，如果你是通过 <code>@ import &quot;file.css&quot;;</code> 导入 CSS 文件，那效果跟普通的 CSS 导入一样。注意：导入文件中定义的混入、变量等信息也将会被引入到主样式文件中，因此需要避免它们互相冲突。</p> <p>reset.css:</p> /<em> file.{type} </em>/<br>body {<br>  background: #EEE;<br>} <p> main.xxx:</p> @ import &quot;reset.css&quot;;<br>@ import &quot;file.{type}&quot;;<br> <br>p {<br>  background: #0982C1;<br>} <p> 最终生成的 CSS：</p> @ import &quot;reset.css&quot;;<br>body {<br>  background: #EEE;<br>}<br>p {<br>  background: #0982C1;<br>} <p> <span style="font-weight:bold">颜色函数</span></p> <p>CSS 预处理器一般都会内置一些颜色处理函数用来对颜色值进行处理，例如加亮、变暗、颜色梯度等。</p> <p>Sass：</p> lighten($color, 10%); /<em> returns a color 10% lighter than $color </em>/<br>darken($color, 10%);  /<em> returns a color 10% darker than $color </em>/<br> <br>saturate($color, 10%);   /<em> returns a color 10% more saturated than $color </em>/<br>desaturate($color, 10%); /<em> returns a color 10% less saturated than $color </em>/<br> <br>grayscale($color);  /<em> returns grayscale of $color </em>/<br>complement($color); /<em> returns complement color of $color </em>/<br>invert($color);     /<em> returns inverted color of $color </em>/<br> <br>mix($color1, $color2, 50%); /<em> mix $color1 with $color2 with a weight of 50% </em>/ <p> </p> <p>上面只是简单列了 Sass 的一些基本颜色处理函数，完整的列表请看 <a href="http://sass-lang.com/docs/yardoc/Sass/Script/Functions.html" rel="nofollow">Sass Documentation</a>.</p> <p>下面是一个具体的例子：</p> $color: #0982C1;<br> <br>h1 {<br>  background: $color;<br>  border: 3px solid darken($color, 50%);<br>} <p> Less CSS: </p> lighten(@color, 10%); /<em> returns a color 10% lighter than @color </em>/<br>darken(@color, 10%);  /<em> returns a color 10% darker than @color </em>/<br> <br>saturate(@color, 10%);   /<em> returns a color 10% more saturated than @color </em>/<br>desaturate(@color, 10%); /<em> returns a color 10% less saturated than @color </em>/<br> <br>spin(@color, 10);  /<em> returns a color with a 10 degree larger in hue than @color </em>/<br>spin(@color, -10); /<em> returns a color with a 10 degree smaller hue than @color </em>/<br> <br>mix(@color1, @color2); /<em> return a mix of @color1 and @color2 </em>/ <p> </p> <p>LESS 完整的颜色函数列表请看 <a href="http://lesscss.org/#-color-functions" rel="nofollow">LESS Documentation</a>.</p> <p>LESS 使用颜色函数的例子：</p> @color: #0982C1;<br> <br>h1 {<br>  background: @color;<br>  border: 3px solid darken(@color, 50%);<br>} <p> Stylus:</p> lighten(color, 10%); /<em> returns a color 10% lighter than 'color' </em>/<br>darken(color, 10%);  /<em> returns a color 10% darker than 'color' </em>/<br> <br>saturate(color, 10%);   /<em> returns a color 10% more saturated than 'color' </em>/<br>desaturate(color, 10%); /<em> returns a color 10% less saturated than 'color' </em>/ <p> </p> <p>完整的颜色函数列表请阅读 <a href="http://learnboost.github.com/stylus/docs/bifs.html" rel="nofollow">Stylus Documentation</a>.</p> <p>实例：</p> color = #0982C1<br> <br>h1<br>  background color<br>  border 3px solid darken(color, 50%) <p> <span style="font-weight:bold">运算符</span></p> <p>你可以直接在 CSS 预处理器中进行样式的计算，例如：</p> body {<br>  margin: (14px/2);<br>  top: 50px + 100px;<br>  right: 100px - 50px;<br>  left: 10 * 10;<br>} <p> <span style="font-weight:bold">一些跟具体浏览器相关的处理</span></p> <p>这是宣传使用预处理的原因之一，并且是一个很好的理由，这样可以节省的大量的时间和汗水。创建一个mixin来处理不同浏览器的CSS写法是很简单的，节省了大量的重复工作和痛苦的代码编辑。</p> <p>Sass</p> @mixin border-radius($values) {<br>  -webkit-border-radius: $values;<br>     -moz-border-radius: $values;<br>          border-radius: $values;<br>}<br> <br>div {<br>  @ include border-radius(10px);<br>} <p> Less CSS</p> .border-radius(@values) {<br>  -webkit-border-radius: @values;<br>     -moz-border-radius: @values;<br>          border-radius: @values;<br>}<br> <br>div {<br>  .border-radius(10px);<br>} <p> Stylus</p> border-radius(values) {<br>  -webkit-border-radius: values;<br>     -moz-border-radius: values;<br>          border-radius: values;<br>}<br> <br>div {<br>  border-radius(10px);<br>} <p> 编译结果：</p> div {<br>  -webkit-border-radius: 10px;<br>     -moz-border-radius: 10px;<br>          border-radius: 10px;<br>} <p> <span style="font-weight:bold">3D文本</span></p> <p>要生成具有 3D 效果的文本可以使用 <code>text-shadows</code> ，唯一的问题就是当要修改颜色的时候就非常的麻烦，而通过 mixin 和颜色函数可以很轻松的实现：</p> <p>Sass</p> @mixin text3d($color) {<br>  color: $color;<br>  text-shadow: 1px 1px 0px darken($color, 5%),<br>               2px 2px 0px darken($color, 10%),<br>               3px 3px 0px darken($color, 15%),<br>               4px 4px 0px darken($color, 20%),<br>               4px 4px 2px #000;<br>}<br> <br>h1 {<br>  font-size: 32pt;<br>  @ include text3d(#0982c1);<br>} <p> Less CSS</p> .text3d(@color) {<br>  color: @color;<br>  text-shadow: 1px 1px 0px darken(@color, 5%),<br>               2px 2px 0px darken(@color, 10%),<br>               3px 3px 0px darken(@color, 15%),<br>               4px 4px 0px darken(@color, 20%),<br>               4px 4px 2px #000;<br>}<br> <br>span {<br>  font-size: 32pt;<br>  .text3d(#0982c1);<br>} <p> Stylus</p> text3d(color)<br>  color: color<br>  text-shadow: 1px 1px 0px darken(color, 5%), 2px 2px 0px darken(color, 10%), 3px 3px 0px darken(color, 15%), 4px 4px 0px darken(color, 20%), 4px 4px 2px #000<br>span<br>  font-size: 32pt<br>  text3d(#0982c1) <p> 生成的 CSS</p> span {<br>  font-size: 32pt;<br>  color: #0982c1;<br>  text-shadow: 1px 1px 0px #097bb7,<br>               2px 2px 0px #0875ae,<br>               3px 3px 0px #086fa4,<br>               4px 4px 0px #07689a,<br>               4px 4px 2px #000;<br>} <p> 效果图：</p> <p><img src="http://images.cnblogs.com/cnblogs_com/rubylouvre/205314/o_3dtext.png"></p> <p>列 (Columns)</p> <p>使用数值操作和变量可以很方便的实现适应屏幕大小的布局处理。</p> <p>Sass</p> $siteWidth: 1024px;<br>$gutterWidth: 20px;<br>$sidebarWidth: 300px;<br> <br>body {<br>  margin: 0 auto;<br>  width: $siteWidth;<br>}<br>.content {<br>  float: left;<br>  width: $siteWidth - ($sidebarWidth+$gutterWidth);<br>}<br>.sidebar {<br>  float: left;<br>  margin-left: $gutterWidth;<br>  width: $sidebarWidth;<br>} <p> Less CSS</p> @siteWidth: 1024px;<br>@gutterWidth: 20px;<br>@sidebarWidth: 300px;<br> <br>body {<br>  margin: 0 auto;<br>  width: @siteWidth;<br>}<br>.content {<br>  float: left;<br>  width: @siteWidth - (@sidebarWidth+@gutterWidth);<br>}<br>.sidebar {<br>  float: left;<br>  margin-left: @gutterWidth;<br>  width: @sidebarWidth;<br>} <p> Stylus</p> siteWidth = 1024px;<br>gutterWidth = 20px;<br>sidebarWidth = 300px;<br> <br>body {<br>  margin: 0 auto;<br>  width: siteWidth;<br>}<br>.content {<br>  float: left;<br>  width: siteWidth - (sidebarWidth+gutterWidth);<br>}<br>.sidebar {<br>  float: left;<br>  margin-left: gutterWidth;<br>  width: sidebarWidth;<br>} <p> 实际效果</p> body {<br>  margin: 0 auto;<br>  width: 1024px;<br>}<br>.content {<br>  float: left;<br>  width: 704px;<br>}<br>.sidebar {<br>  float: left;<br>  margin-left: 20px;<br>  width: 300px;<br>} <p> <span>错误报告</span></p> <p>如果你经常 CSS 你会发现很难找到 CSS 中错误的地方，这也是预处理框架的好处，它会报告错误，你可以从这<span style="text-decoration:underline">篇</span><a href="http://tjholowaychuk.com/post/5002088731/stylus-vs-sass-vs-less-error-reporting" rel="nofollow">文章</a>中学习如何让 CSS 框架错误报告。</p> <p>注释</p> <p>以上三种框架都支持形如 /<em> </em>/ 的多行注释以及 // 的单行注释。</p> <p><a href="http://net.tutsplus.com/tutorials/html-css-techniques/sass-vs-less-vs-stylus-a-preprocessor-shootout/" rel="nofollow">英文原文</a>，OSCHINA 原创翻译</p><img src="http://www.cnblogs.com/rubylouvre/aggbug/2858251.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/rubylouvre/archive/2013/01/13/2858251.html">本文链接</a></p></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
