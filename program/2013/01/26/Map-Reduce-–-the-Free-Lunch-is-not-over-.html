<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Map Reduce – the Free Lunch is not over?</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>Map Reduce – the Free Lunch is not over?</h2>
<p class="meta">26 Jan 2013</p>

<div class="post">
<h2>Map Reduce – the Free Lunch is not over?</h2>

<h3>by</h3>

<h3>at 2013-01-25 17:15:00</h3>

<h3>original <a href="http://kb.cnblogs.com/page/170370/">http://kb.cnblogs.com/page/170370/</a></h3>

<p>　　原文发表于 2006 年 11 月 15 日</p>


<p>　　微软著名的 C++大师 <a href="http://www.gotw.ca/">Herb Sutter</a> 在 2005 年初的时候曾经写过一篇重量级的文章——<a href="http://www.gotw.ca/publications/concurrency-ddj.htm">The Free Lunch Is Over: A Fundamental Turn Toward Concurrency in Software</a>，预言OO之后软件开发将要面临的又一次重大变革——并行计算。</p>


<p>　　摩尔定律统治下的软件开发时代有一个非常有意思的现象：“Andy giveth, and Bill taketh away.”。不管CPU的主频有多快，我们始终有办法来利用它，而我们也陶醉在机器升级带来的程序性能提高中。</p>


<p>　　我记着我大二的时候曾经做过一个五子棋的程序，当时的算法就是预先设计一些棋型（有优先级），然后扫描棋盘，对形势进行分析，看看当前走哪部对自己最重要。当然下棋还要堵别人，这就需要互换双方的棋型再计算。如果只算一步，很可能被狡猾的对手欺骗，所以为了多想几步，还需要递归和回朔。在当时的机器上，算 3 步就基本上需要 3 秒左右的时间了。后来大学毕业收拾东西的时候找到这个程序，试了一下，发现算 10 步需要的时间也基本上感觉不出来了。</p>


<p>　　不知道你是否有同样的经历，我们不知不觉的一直在享受着这样的免费午餐。可是，随着摩尔定律的提前终结，免费的午餐终究要还回去。虽然硬件设计师还在努力：Hyper Threading CPU（多出一套寄存器，相当于一个逻辑CPU）使得 Pipeline 尽可能满负荷，使多个 Thread 的操作有可能并行，使得多线程程序的性能有 5%-15% 的提升；增加 Cache 容量也使得包括 Single-Thread 和 Multi-Thread 程序都能受益。也许这些还能帮助你一段时间，但问题是，我们必须做出改变，面对这个即将到来的变革，你准备好了么？</p>


<p>　　Concurrency Programming != Multi-Thread Programming。很多人都会说 MultiThreading 谁不会，问题是，你是为什么使用/如何使用多线程的？我从前做过一个类似 AcdSee 一样的图像查看/处理程序，我通常用它来处理我的数码照片。我在里面用了大量的多线程，不过主要目的是在图像处理的时候不要 Block 住 UI，所以将 CPU Intensive 的计算部分用后台线程进行处理，而并没有把对图像矩阵的运算并行分开。</p>


<p>　　我觉得 Concurrency Programming 真正的挑战在于 Programming Model 的改变，在程序员的脑子里面要对自己的程序怎样并行化有很清楚的<strong>认识</strong>，更重要的是，如何去<strong>实现</strong>（包括架构、容错、实时监控等等）这种并行化，如何去<strong>调试</strong>，如何去<strong>测试</strong>。</p>


<p>　　在 Google，每天有海量的数据需要在有限的时间内进行处理（其实每个互联网公司都会碰到这样的问题），每个程序员都需要进行分布式的程序开发，这其中包括如何分布、调度、监控以及容错等等。Google的 <a href="http://labs.google.com/papers/mapreduce.html">MapReduce </a>正是把分布式的业务逻辑从这些复杂的细节中抽象出来，使得没有或者很少并行开发经验的程序员也能进行并行应用程序的开发。</p>


<p>　　MapReduce 中最重要的两个词就是Map（映射）和 Reduce（规约）。初看 Map/Reduce 这两个词，熟悉 Function Language 的人一定感觉很熟悉。FP 把这样的函数称为“higher order function”（“High order function” 被成为 Function Programming 的利器之一哦），也就是说，这些函数是被编写来与其它函数相结合（或者说被其它函数调用的）。如果说硬要比的化，可以把它想象成 C 里面的 CallBack 函数，或者 STL 里面的 Functor。比如你要对一个 STL 的容器进行查找，需要制定每两个元素相比较的Functor(Comparator)，这个 Comparator 在遍历容器的时候就会被调用。</p>


<p>　　拿前面说过图像处理程序来举例，其实大多数的图像处理操作都是对图像矩阵进行某种运算。这里的运算通常有两种，一种是映射，一种是规约。拿两种效果来说，”老照片”效果通常是强化照片的 G/B 值，然后对每个象素加一些随机的偏移，这些操作在二维矩阵上的每一个元素都是独立的，是 Map 操作。而”雕刻”效果需要提取图像边缘，就需要元素之间的运算了，是一种 Reduce 操作。再举个简单的例子，一个一维矩阵（数组）[0,1,2,3,4] 可以映射为 [0,2,3,6,8]（乘2），也可以映射为[1,2,3,4,5]（加1）。它可以规约为0（元素求积）也可以规约为10（元素求和）。</p>


<p>　　面对复杂问题，古人教导我们要“<strong>分</strong>而<strong>治</strong>之”，英文中对应的词是”<strong>Divide</strong> and <strong>Conquer</strong>“。Map/Reduce 其实就是 Divide/Conquer 的过程，通过把问题 Divide，使这些Divide 后的 Map 运算高度并行，再将 Map 后的结果 Reduce（根据某一个Key），得到最终的结果。</p>


<p>　　Googler 发现这是问题的核心，其它都是共性问题。因此，他们把 Map/Reduce 抽象分离出来。这样，Google 的程序员可以只关心应用逻辑，关心根据哪些 Key 把问题进行分解，哪些操作是 Map 操作，哪些操作是 Reduce 操作。其它并行计算中的复杂问题诸如分布、工作调度、容错、机器间通信都交给 Map/Reduce Framework 去做，很大程度上简化了整个编程模型。</p>


<p>　　MapReduce 的另一个特点是，Map 和 Reduce 的<strong>输入和输出都是中间临时文件</strong>（MapReduce 利用 Google 文件系统来管理和访问这些文件），而不是不同进程间或者不同机器间的其它通信方式。我觉得，这是 Google 一贯的风格，化繁为简，返璞归真。</p>


<p>　　接下来就放下其它，研究一下 Map/Reduce 操作。（其它比如容错、备份任务也有很经典的经验和实现，论文里面都有详述）</p>


<p>　　Map的定义：</p>


<blockquote><p>Map, written by the user, takes an input pair and produces a set of intermediate key/value pairs. The MapReduce library groups together all intermediate values associated with the same intermediate key I and passes them to the Reduce function.</p></blockquote>


<p>　　Reduce的定义：</p>


<blockquote><p>The Reduce function, also written by the user, accepts an intermediate key I and a set of values for that key. It merges together these values to form a possibly smaller set of values. Typically just zero or one output value is produced per Reduce invocation. The intermediate values are supplied to the user’s reduce function via an iterator. This allows us to handle lists of values that are too large to fit in memory.</p></blockquote>


<p>　　MapReduce 论文中给出了这样一个例子：在一个文档集合中统计每个单词出现的次数。</p>


<p>　　Map 操作的输入是每一篇文档，将输入文档中每一个单词的出现输出到中间文件中去。</p>


<div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#000000">map(String key, String value):<br>    </span><span style="color:#008000">//</span><span style="color:#008000"> key: document name<br>    </span><span style="color:#008000">//</span><span style="color:#008000"> value: document contents</span><br>    <span style="color:#0000ff">for</span> each word w <span style="color:#0000ff">in</span><span style="color:#000000"> value:<br>        EmitIntermediate(w, “</span><span style="color:#800080">1</span>″);</div>


<p>　　比如我们有两篇文档，内容分别是</p>


<p>　　A － “I love programming”</p>


<p>　　B － “I am a blogger, you are also a blogger”。</p>


<p>　　B 文档经过 Map 运算后输出的中间文件将会是：</p>


<div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">I,1<span style="color:#000000"><br>am</span>,1<span style="color:#000000"><br>a</span>,1<span style="color:#000000"><br>blogger</span>,1<span style="color:#000000"><br>you</span>,1<span style="color:#000000"><br>are</span>,1<span style="color:#000000"><br>a</span>,1<span style="color:#000000"><br>blogger</span>,1</div>


<p>　　Reduce 操作的输入是单词和出现次数的序列。用上面的例子来说，就是 (“I”, [1, 1]), (“love”, [1]), (“programming”, [1]), (“am”, [1]), (“a”, [1,1]) 等。然后根据每个单词，算出总的出现次数。</p>


<div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#000000">reduce(String key, Iterator values):<br>    </span><span style="color:#008000">//</span><span style="color:#008000"> key: a word<br>    </span><span style="color:#008000">//</span><span style="color:#008000"> values: a list of counts</span><br>    <span style="color:#0000ff">int</span> result = <span style="color:#800080">0</span><span style="color:#000000">;<br>    </span><span style="color:#0000ff">for</span> each v <span style="color:#0000ff">in</span><span style="color:#000000"> values:<br>        result </span>+=<span style="color:#000000"> ParseInt(v);<br>    Emit(AsString(result));</span></div>


<p>　　最后输出的最终结果就会是：(“I”, 2″), (“a”, 2″)……</p>


<p>　　实际的执行顺序是：</p>


<ol><li>MapReduce Library 将 Input 分成 M 份。这里的 Input Splitter 也可以是多台机器<strong>并行 Split</strong>。</li><li>Master 将 M 份 Job 分给 Idle 状态的 M 个 worker 来处理；</li><li>对于输入中的每一个 &lt;key, value&gt; pair 进行 Map 操作，将中间结果 Buffer 在 Memory 里；</li><li>定期的（或者根据内存状态），将 Buffer 中的中间信息 Dump 到<strong>本地</strong>磁盘上，并且把文件信息传回给 Master（Master 需要把这些信息发送给 Reduce worker）。这里最重要的一点是，<strong>在写磁盘的时候，需要将中间文件做Partition（比如R个）</strong>。拿上面的例子来举例，如果把所有的信息存到一个文件，Reduce worker 又会变成瓶颈。我们只需要保证<strong>相同 Ke y能出现在同一个 Partition </strong>里面就可以把这个问题分解。</li><li>R 个 Reduce worker 开始工作，从不同的 Map worker 的Partition那里拿到数据（<strong>read the buffered data from the local disks of the map workers</strong>），用key 进行排序（如果内存中放不下需要用到外部排序 – external sort）。很显然，排序（或者说Group）是 Reduce 函数之前必须做的一步。 这里面很关键的是，每个Reduce worker 会去从很多 Map worker 那里拿到 X(0&lt;X&lt;R) Partition 的中间结果，这样，所有属于这个 Key 的信息已经都在这个 worker 上了。</li><li>Reduce worker 遍历中间数据，对每一个唯一 Key，执行 Reduce 函数（参数是这个 key 以及相对应的一系列 Value）。</li><li>执行完毕后，唤醒用户程序，返回结果（最后应该有 R 份 Output，每个 Reduce Worker 一个）。</li></ol>


<p>　　可见，这里的分（Divide）体现在两步，分别是将输入分成 M 份，以及将 Map 的中间结果分成R份。将输入分开通常很简单，Map 的中间结果通常用“hash(key) mod R”这个结果作为标准，保证相同的 Key 出现在同一个 Partition 里面。当然，使用者也可以指定自己的 Partition Function，比如，对于 Url Key，如果希望同一个 Host 的 URL 出现在同一个 Partition，可以用“hash(Hostname(urlkey)) mod R”作为 Partition Function。</p>


<p>　　对于上面的例子来说，每个文档中都可能会出现成千上万的 (“the”, 1)这样的中间结果，琐碎的中间文件必然导致传输上的损失。因此，MapReduce还 支持用户提供 Combiner Function。这个函数通常与 Reduce Function 有相同的实现，不同点在于 Reduce 函数的输出是最终结果，而 Combiner 函数的输出是 Reduce 函数的某一个输入的中间文件。</p>


<p>　　Tom White给出了 Nutch[2] 中另一个很直观的例子，<a href="http://weblogs.java.net/blog/tomwhite/archive/2005/09/mapreduce.html">分布式Grep</a>。我一直觉得，Pipe 中的很多操作，比如 More、Grep、Cat 都类似于一种 Map 操作，而 Sort、Uniq、wc 等都相当于某种 Reduce 操作。</p>


<p>　　加上前两天 Google 刚刚发布的 <a href="http://labs.google.com/papers/bigtable.html">BigTable </a>论文，现在 Google 有了自己的集群 – <a href="http://labs.google.com/papers/googlecluster.html">Googel Cluster</a>，分布式文件系统 – <a href="http://labs.google.com/papers/gfs.html">GFS</a>，分布式计算环境 – <a href="http://labs.google.com/papers/mapreduce.html">MapReduce</a>，分布式结构化存储 – <a href="http://labs.google.com/papers/bigtable.html">BigTable</a>，再加上 <a href="http://labs.google.com/papers/chubby.html">Lock Service</a>。我真的能感觉的到 Google 著名的免费晚餐之外的对于程序员的另一种免费的晚餐，那个由大量的 commodity PC 组成的 large clusters。我觉得这些才真正是Google的核心价值所在。</p>


<p>呵　　呵，就像微软老兵 <a href="http://www.joelonsoftware.com/">Joel Spolsky</a>（你应该看过他的”Joel on Software”吧？）曾经说过，对于微软来说最可怕的是[1]，微软还在苦苦追赶 Google 来完善 Search 功能的时候，Google 已经在部署下一代的超级计算机了。</p>


<blockquote><p>The very fact that Google invented MapReduce, and Microsoft didn’t, says something about why <strong>Microsoft is still playing catch up trying to get basic search features to work, while Google has moved on to the next problem: building Skynet^H^H^H^H^H^H the world’s largest massively parallel supercomputer</strong>. I don’t think Microsoft completely understands just how far behind they are on that wave.</p></blockquote>


<p>　　注1：其实，微软也有自己的方案 – <a href="http://research.microsoft.com/research/sv/dryad/">DryAd</a>。问题是，大公司里，要想重新部署这样一个底层的 InfraStructure，无论是技术的原因，还是政治的原因，将是如何的难。</p>


<p>　　注2：<a href="http://lucene.apache.org/">Lucene </a>之父Doug Cutting的又一力作，Project <a href="http://lucene.apache.org/hadoop/">Hadoop</a> - 由Hadoop分布式文件系统和一个 Map/Reduce 的实现组成，Lucene/Nutch 的成产线也够齐全的了。</p>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
