<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>C++写node笔记（七）</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>C++写node笔记（七）</h2>
<p class="meta">2013-01-25 22:49</p>

<div class="post">
<h2>C++写node笔记（七）</h2>

<h3>by snoopyxdy</h3>

<h3>at 2013-01-25 14:49:07</h3>

<h3>original <a href="http://snoopyxdy.blog.163.com/blog/static/60117440201302431946486">http://snoopyxdy.blog.163.com/blog/static/60117440201302431946486</a></h3>

<div>最近用c++先后写了3个node_moudle，有2个放到了npm上，一个项目感觉性能不佳，流产了，总结一下吧：<div>两个上线项目分别是<br><div>A、hvalidator</div><div>node简单验证模块，主要验证一些数据格式，以及email地址，ip，url等正则判断，这个模块算是第一个node addon的产出，处女作。</div><div>npm install hvalidator</div><div>github：<a rel="nofollow" href="https://github.com/DoubleSpout/node-hvalidator">https://github.com/DoubleSpout/node-hvalidator</a><br><br></div></div><div>B、ccap</div><div>利用CImg图形库和libjpeg库让node不用依赖第三方库生成简单验证码。可以设置验证码的大小，内容，质量等。</div><div>npm install ccap</div><div>github：<a style="line-height:22px" rel="nofollow" href="https://github.com/DoubleSpout/ccap">https://github.com/DoubleSpout/ccap</a></div><div><br></div><div>v8手册handle&lt;value&gt;类：<a style="line-height:22px" rel="nofollow" href="http://bespin.cz/~ondras/html/classv8_1_1Value.html">http://bespin.cz/~ondras/html/classv8_1_1Value.html</a></div><div><br></div><div><b>1、一个node的addon基本入口格式应该如下：</b></div><div><br></div><div><div><pre><p></p><div>#define BUILDING_NODE_EXTENSION</div><div>#include &lt;node.h&gt;</div><div>#include "xxx.h"</div><div><br></div><div><p></p><div><span style="line-height:22px">using namespace v8;</span></div><div>void Init(Handle&lt;Object&gt; target) {</div><div>  target-&gt;Set(String::NewSymbol(&quot;输出属性名&quot;),</div><div>           FunctionTemplate::New(C++函数名)-&gt;GetFunction());</div><div>}</div><div>NODE_MODULE(输出模块名, Init)</div></div><p></p></pre></div><div><p></p></div></div><div><br></div><div><b>2、node官方的实例一般都是定义一个class，把要输出给node的方法设置为static静态方法，如下：</b></div><div><div><pre><div><span style="line-height:22px">#include &lt;node.h&gt;</span></div><div>#include &lt;string&gt;</div><div><span style="line-height:22px"><br></span></div><div><span style="line-height:22px">class SimpleF {</span></div><div> public:</div><div>  static v8::Handle&lt;v8::Value&gt; trim(const v8::Arguments&amp; args);</div><div>  static v8::Handle&lt;v8::Value&gt; ltrim(const v8::Arguments&amp; args);</div><div>  static v8::Handle&lt;v8::Value&gt; rtrim(const v8::Arguments&amp; args); </div><div>  static v8::Handle&lt;v8::Value&gt; toXss(const v8::Arguments&amp; args);</div><div>  static v8::Handle&lt;v8::Value&gt; replace(const v8::Arguments&amp; args);</div><div> <span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">  </span></div><div> protected:</div><div>  static void toCString(std::string&amp; str, v8::Handle&lt;v8::Value&gt; strp);</div><div>  static void lTrimString(std::string&amp; str,const std::string&amp; filters = &quot;\r\t\n &quot;);</div><div><br></div><div> private:</div><div>  SimpleF();</div><div>  ~SimpleF();</div><div>};</div><p></p></pre></div><div>比如上面这段代码就定义了一个SimpleF的类，然后定义了很多静态方法供输出给node</div></div><div><br></div><div><br></div><div><b>3、一个简单的输出给node的静态类方法示例</b></div><div><br></div><div><pre><p></p><div>Handle&lt;Value&gt; SimpleV::isArray(const Arguments&amp; args) {//是否是数组</div><div>  HandleScope scope;</div><div>  return scope.Close(Boolean::New(args[0]-&gt;IsArray()));</div><div>}</div><p></p></pre></div><div>比如上面这段就是输出给node，并且返回一个bool值，告诉node端第一个参数是否为数组</div><div><br></div><div><br></div><div><b>4、静态方法可以返回给node各种不同的格式，比如整形，字符串，数组，对象等</b></div><div><b><br></b></div><div>布尔值：return scope.Close(Boolean::New(1)); //返回true</div><div><br></div><div>数字：<span style="line-height:22px">return scope.Close(Number::New(1));</span><span style="line-height:22px"> //返回数字1</span></div><div><span style="line-height:22px"><br></span></div><div><span style="line-height:22px">字符串：</span></div><div>char *a = '1';</div><div><span style="line-height:22px">return scope.Close(Number::New(a));</span><span style="line-height:22px"> //返回字符串a</span></div><div><span style="line-height:22px"><br></span></div><div>数组：</div><div>Handle&lt;Array&gt; ary = Array::New(2);</div><div><div>ary-&gt;Set(0,Integer::New(1));</div><div>ary-&gt;Set(1,<span style="line-height:22px">String</span>::New("m"));</div><div>return scope.Close(ary);</div></div><div>//返回数组[1,"m"];</div><div><br></div><div>对象：</div><div><div style="line-height:22px">Handle&lt;<span style="line-height:22px">Object</span>&gt; obj = Object::New();</div><div style="line-height:22px"><div style="line-height:22px"><span style="line-height:22px">obj</span>-&gt;Set(<span style="line-height:22px">String::New(&quot;a&quot;) </span>,Integer::New(1));</div><div style="line-height:22px"><span style="line-height:22px">obj</span>-&gt;Set(<span style="line-height:22px">String::New("b")</span>, String::New("m"));</div><div style="line-height:22px">return scope.Close(<span style="line-height:22px">obj</span>);</div></div><div style="line-height:22px">//返回数组{a:1,b:"m"};</div></div><div style="line-height:22px"><br></div><div style="line-height:22px">函数：</div><div><div>Handle&lt;Value&gt; MyFunction(const Arguments&amp; args) {//这表定义了一个静态方法</div><div>  HandleScope scope;</div><div>  return scope.Close(String::New(&quot;hello world&quot;));</div><div>}</div><div><br></div><div>Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(MyFunction);//将上面的静态方法作为返回值返回node</div><div>Local&lt;Function&gt; fn = tpl-&gt;GetFunction();</div><div>fn-&gt;SetName(String::NewSymbol(&quot;theFunction&quot;)); // 忽略名字则表示匿名</div><div><span style="line-height:22px">return scope.Close(fn);</span></div></div><div><span style="line-height:22px"><br></span></div><div><span style="line-height:22px"><br></span></div><div><span style="line-height:22px"><b>5、获取node传递参数的值</b></span></div>获得数字的值：<div><div>double：arg[0]-&gt;NumberValue ()</div><div>int64_t：<span style="line-height:22px">arg[0]-&gt;</span><span style="line-height:22px">IntegerValue ()</span></div><div>uint32_t：<span style="line-height:22px">arg[0]-&gt;</span><span style="line-height:22px">Uint32Value ()</span></div><div>int32_t：<span style="line-height:22px">arg[0]-&gt;</span><span style="line-height:22px">Int32Value ()</span></div><div><span style="line-height:22px"><br></span></div><div>获得布尔值：</div><div>bool：arg[0]-&gt;BooleanValue ()</div><div><br></div><div>获得字符串：</div><div>String::Utf8Value utf8_value(arg[0]-&gt;ToString());</div><div>string&amp; str(*<span style="line-height:22px">utf8_value</span><span style="line-height:22px">);</span></div><div><span style="line-height:22px"><br></span></div><div>获得数组，对象</div><div>Local&lt;Object&gt; lo(arg[0]-&gt;ToObject ());</div><div><br></div><div>获得数组或是对象中的某一个值：</div><div>Local&lt;Value&gt; ary0 = <span style="line-height:22px">lo-&gt;Get(0); //获取数组中第一个元素的值，返回</span>Local&lt;Value&gt;</div><div>获得对象中的某一个值</div><div><span style="line-height:22px">Local&lt;Value&gt; ary0 = </span><span style="line-height:22px">lo-&gt;Get(String::New(&quot;m&quot;)); //获取对象中key字段为m的值，返回</span><span style="line-height:22px">Local&lt;Value&gt;</span></div><div><span style="line-height:22px"><br></span></div><div><span style="line-height:22px"><b>6、一些常用的代码片段：</b></span></div><div><br></div><div>6.1将node端的字符串传化为std::string类型：</div><div><pre><p>void router::toCString(std::string&amp; str, Handle&lt;Value&gt; strp){<br>      String::Utf8Value utf8_value(strp-&gt;ToString());//转化成v8::Utf8Value<br>      str = *utf8_value;//转化为string<br>}</p></pre><br></div><div>6.2将c++的std::string转化为char * 返回给node</div><div><pre><p>std::string s;<br>const char *sp = s.c_str();<br>return scope.Close(String::New(sp));</p></pre><br></div><div>6.3 c++的replace函数：</div><div><pre><p>void SimpleF::CSreplace(std::string&amp; s1,std::string&amp; s2,std::string&amp; s3)<br>{<br> std::string::size_type pos=0;<br> std::string::size_type a=s2.size();<br> std::string::size_type b=s3.size();<br><br><br>  while((pos=s1.find(s2,pos))!=std::string::npos)<br>  {<br>   s1.replace(pos,a,s3);<br>   pos+=b;<br>  }<br><br>}</p></pre><br></div><div>6.4 c++linux下和windows下的正则表达式</div><div><br></div><div>linux生成正则表达式（这里没有释放，因为要重复使用该正则）：</div><div><pre><p>#include &lt;regex.h&gt;</p><p>regex_t genRegex(std::string regstr){<br> regex_t preg;<br> const char *regex = regstr.c_str();<br><br> regcomp(&amp;preg, regex, REG_EXTENDED|REG_NOSUB);<br> return preg; <br>}</p></pre>linux正则匹配：</div><div><pre><p>bool match(regex_t preg,std::string&amp; str){<br> int z;<br> const char *buf = str.c_str();<br> const size_t nmatch = 1;<br> regmatch_t pm[nmatch];<br> z = regexec(&amp;preg, buf, nmatch, pm, 0);<br> return z != REG_NOMATCH;<br>}</p></pre><br></div><div>windows下的正则生成，同样没有释放内容，重复使用：</div><div><pre><p>#include &lt;regex&gt;</p><p>std::regex genRegex(std::string regstr){<br> std::regex pattern(regstr,std::regex_constants::extended);<br> return pattern; <br>}</p></pre>windows下正则匹配：</div><div><pre><p>bool match(std::regex pattern,std::string&amp; str){<br> std::match_results&lt;std::string::const_iterator&gt; result;<br> bool valid = std::regex_match(str,result,pattern);<br> return valid;<br>}</p></pre><br></div><div>6.5 c++调用node端的函数：</div><div><pre><p>Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[0]);<br>const unsigned argc = 1;<br>Local&lt;Value&gt; argv[argc] = { Local&lt;Value&gt;::New(String::New(&quot;hello world&quot;)) };<br>cb-&gt;Call(Context::GetCurrent()-&gt;Global(), argc, argv);</p></pre></div><div><br></div></div><div>持续更新。。</div></div>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
