<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Base 64 Encoding 编码</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>Base 64 Encoding 编码</h2>
<p class="meta">16 Jan 2013</p>

<div class="post">
<h2>Base 64 Encoding 编码</h2>

<h3>by</h3>

<h3>at 2013-01-16 10:28:33</h3>

<h3>original <a href="http://kb.cnblogs.com/page/166471/">http://kb.cnblogs.com/page/166471/</a></h3>

<p><span style="line-height:1.8">　　Base 64 Encoding有什么用？举个简单的例子，你使用SMTP协议 （Simple Mail Transfer Protocol 简单邮件传输协议）来发送邮件。因为这个协议是基于文本的协议，所以如果邮件中包含一幅图片，我们知道图片的存储格式是二进制数据（binary data），而非文本格式，我们必须将二进制的数据编码成文本格式，这时候Base 64 Encoding就派上用场了。</span></p>


<p>　　（一）编码原理</p>


<p>　　Base 64 Encoding 的编码原理是将每三个字节（byte）转换为四个字符，每个字符占6 bit。</p>


<p style="text-align:center"><a href="http://images.cnblogs.com/cnblogs_com/jfzhu/201212/201212100007219276.png"><img style="background-image:none;padding-left:0px;padding-right:0px;display:inline;padding-top:0px;border:0px" title="image" src="http://images.cnblogs.com/cnblogs_com/jfzhu/201212/201212100007235698.png" alt="image" width="603" height="148" border="0"></a></p>


<p>　　6 bit一共有64种组合方式，也就是说该编码共需要使用至少64种字符（后面我们还会介绍一个特殊字符 =）。Base 64 Encoding使用了从 A 到 Z、a 到 z、0 到 9、以及 + 和 / 这些字符（即[A-Za-z0-9+/]）。</p>


<p style="text-align:center"><a href="http://images.cnblogs.com/cnblogs_com/jfzhu/201212/201212100007251912.png"><img style="background-image:none;padding-left:0px;padding-right:0px;display:inline;padding-top:0px;border:0px" title="image" src="http://images.cnblogs.com/cnblogs_com/jfzhu/201212/201212100007266174.png" alt="image" width="363" height="440" border="0"></a></p>


<p>　　假设我们有三个字节的数据，byte[] {1, 2, 3}，用二进制表示为：</p>


<p>　　00000001 | 00000010 | 00000011</p>


<p>　　依据上面的原理，使用Basee 64 Encoding编码后结果应该为：</p>


<p>　　000000 | 010000 | 001000 | 000011</p>


<p>　　转换为十进制为 0 | 16 | 8 | 3，对照上面的表，编码后的文本为 AQID</p>


<p>　　既然Base 64 Encoding将每三个字节转换为四个字符，那如果一幅图片的字节数不能被3整除该怎么办？</p>


<p>　　如果剩余一个字节，该字节同样被转换为四个字符。第一个6 bit转换成一个字符，接下来2 bit转换成一个字符（注意这里是向右添加0），最后添加两个=字符。</p>


<p style="text-align:center"><a href="http://images.cnblogs.com/cnblogs_com/jfzhu/201212/201212100007283533.png"><img style="background-image:none;padding-left:0px;padding-right:0px;display:inline;padding-top:0px;border:0px" title="image" src="http://images.cnblogs.com/cnblogs_com/jfzhu/201212/201212100007299465.png" alt="image" width="331" height="153" border="0"></a></p>


<p>　　假设我们有四个字节的数据，byte[] {1, 2, 3, 4}，用二进制表示为：</p>


<p>　　00000001 | 00000010 | 00000011 | 00000100</p>


<p>　　依据上面的原理，使用Basee 64 Encoding编码后结果应该为：</p>


<p>　　000000 | 010000 | 001000 | 000011 | 000001 | 000000</p>


<p>　　转换为十进制为 0 | 16 | 8 | 3 | 1 | 0，对照上面的表，编码后的文本为 AQIDBA==</p>


<p>　　如果不能被3整除，而余下两个字节，编码方式类似剩余一个字节，同样是转换成四个字符，最后一个字符用=。</p>


<p style="text-align:center"><a href="http://images.cnblogs.com/cnblogs_com/jfzhu/201212/201212100007315711.png"><img style="background-image:none;padding-left:0px;padding-right:0px;display:inline;padding-top:0px;border:0px" title="image" src="http://images.cnblogs.com/cnblogs_com/jfzhu/201212/201212100007324674.png" alt="image" width="451" height="144" border="0"></a></p>


<p>　　假设我们有五个字节的数据，byte[] {1, 2, 3, 4, 5}，用二进制表示为：</p>


<p>　　00000001 | 00000010 | 00000011 | 00000100 | 00000101</p>


<p>　　依据上面的原理，使用Basee 64 Encoding编码后结果应该为：</p>


<p>　　000000 | 010000 | 001000 | 000011 | 000001 | 000000 | 010100</p>


<p>　　转换为十进制为 0 | 16 | 8 | 3 | 1 | 0 | 20，对照上面的表，编码后的文本为 AQIDBAU=</p>


<p>　　（二）在.Net中的实现</p>


<p>　　在.Net中，将二进制数据编码为文本可以使用public static string ToBase64String(byte[] inArray)方法；从文本文件转换回二进制数据可以使用public static byte[] FromBase64String(string s)方法。</p>


<p>　　下面验证一下上面讲解的例子，分别将三组数据 byte[] {1, 2, 3}，byte[] {1, 2, 3, 4}，byte[] {1, 2, 3, 4, 5} 进行编码，并检验编码后的文本是否分别为AQID，AQIDBA==，AQIDBAU=。</p>


<div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">byte</span>[] binary1 = <span style="color:#0000ff">new</span> <span style="color:#0000ff">byte</span>[] { <span style="color:#800080">1</span>, <span style="color:#800080">2</span>, <span style="color:#800080">3</span><span style="color:#000000"> }; <br></span><span style="color:#0000ff">string</span> encoded1 =<span style="color:#000000"> Convert.ToBase64String(binary1); <br></span><span style="color:#0000ff">byte</span>[] decoded1 =<span style="color:#000000"> Convert.FromBase64String(encoded1); <br>Console.WriteLine(</span><span style="color:#800000">"</span><span style="color:#800000">Encoded string: {0}, Decoded binary is equal to orignial binary? {1}</span><span style="color:#800000">"</span><span style="color:#000000"> <br>    , encoded1, binary1.SequenceEqual(decoded1));<br><br></span><span style="color:#0000ff">byte</span>[] binary2 = <span style="color:#0000ff">new</span> <span style="color:#0000ff">byte</span>[] { <span style="color:#800080">1</span>, <span style="color:#800080">2</span>, <span style="color:#800080">3</span>, <span style="color:#800080">4</span><span style="color:#000000">}; <br></span><span style="color:#0000ff">string</span> encoded2 =<span style="color:#000000"> Convert.ToBase64String(binary2); <br></span><span style="color:#0000ff">byte</span>[] decoded2 =<span style="color:#000000"> Convert.FromBase64String(encoded2); <br>Console.WriteLine(</span><span style="color:#800000">"</span><span style="color:#800000">Encoded string: {0}, Decoded binary is equal to orignial binary? {1}</span><span style="color:#800000">"</span><span style="color:#000000"> <br>    , encoded2, binary2.SequenceEqual(decoded2));<br><br></span><span style="color:#0000ff">byte</span>[] binary3 = <span style="color:#0000ff">new</span> <span style="color:#0000ff">byte</span>[] { <span style="color:#800080">1</span>, <span style="color:#800080">2</span>, <span style="color:#800080">3</span>, <span style="color:#800080">4</span>, <span style="color:#800080">5</span><span style="color:#000000">}; <br></span><span style="color:#0000ff">string</span> encoded3 =<span style="color:#000000"> Convert.ToBase64String(binary3); <br></span><span style="color:#0000ff">byte</span>[] decoded3 =<span style="color:#000000"> Convert.FromBase64String(encoded3); <br>Console.WriteLine(</span><span style="color:#800000">"</span><span style="color:#800000">Encoded string: {0}, Decoded binary is equal to orignial binary? {1}</span><span style="color:#800000">"</span><span style="color:#000000"> <br>    , encoded3, binary3.SequenceEqual(decoded3)); </span></div>


<p>　　输出结果为：</p>


<p>　　Encoded string: AQID, Decoded binary is equal to orignial binary? True <br>　　Encoded string: AQIDBA==, Decoded binary is equal to orignial binary? True <br>　　Encoded string: AQIDBAU=, Decoded binary is equal to orignial binary? True</p>


<p>　　总结：本文介绍了为何要使用编码，以及Base 64 Encoding编码的原理，最后还介绍了Base 64 Encoding在.Net中的实现。</p>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
