<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>浅析node的buffer模块（一创建）</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>浅析node的buffer模块（一创建）</h2>
<p class="meta">19 Apr 2013</p>

<div class="post">
<h2>浅析node的buffer模块（一创建）</h2>

<h3>by snoopyxdy</h3>

<h3>at 2013-04-19 10:55:25</h3>

<h3>original <a href="http://snoopyxdy.blog.163.com/blog/static/60117440201331683752285">http://snoopyxdy.blog.163.com/blog/static/60117440201331683752285</a></h3>

<div><div><span style="line-height:22px">buffer是nodejs中存储长字符串以及二进制数据的存储介质，buffer我们在使用过程中到底要注意哪些问题？最近结合node的源码简单了解了一下buffer的工作机制。</span></div><div>关于buffer大家可能都听说过8KB的故事，至于8KB的内容我的另外一篇文章有比较详细的介绍，包括一个典型的内存泄露的例子：</div><div><a href="http://snoopyxdy.blog.163.com/blog/static/601174402013230102139585/">buffer.concat引出的bug</a><br><br></div><div>打开0.10.4的源码，在lib目录下找到buffer.js，我们先概览一下整个文件的组成：</div><div>1、两个工具函数，clamp和toHex</div><div>2、SlowBuffer类，并且这个类的一些接口继承自buffer类</div><div>3、buffer类，定义并实现了node api文档上的接口函数</div><div><br></div><div>本文只讨论buffer实例的创建，读取和写入将留到下两章讨论。</div><div><b>一、创建buffer实例</b></div><div>我们从创建一个buffer开始，看看暴露在接口之后的node是如何实现buffer功能的。</div><div>1、比如我们创建一个1KB的buffer，var buf = new Buffer(1024);</div><div>2、buffer类会根据传入的字符串或大小数字或字符数组的大小来分配新的buffer池或者使用旧的，<span style="line-height:22px">字符串或大小数字或字符数组的大小以下简称buf大小</span></div><div>2.1、如果buf大小大于8KB，则buffer类将返回一个slowbuffer实例给buf存储</div><div>2.2、如果buf大小小于8KB并且还小于当前buffer池内剩余的空间，则将此buf实例存入当前buffer池，和其他buffer实例共享这个8KB的内存池。</div><div>2.3、如果buf大小不大于0，则将zerobuffer实例返回给buf，也就是说所有0大小的buffer实例都是一个。</div><div>3、如果传入的参数不是数字，也就是说是字符串或者字符数组，在创建buf实例时会将内容写入刚才分配的buffer内存中。</div><div>3.1、如果是字符串，则调用如下代码：之后我们再讨论this.write方法</div><div><pre><p></p><div>if (type === 'string') {</div><div>        // We are a string</div><div>        this.length = this.write(subject, 0, encoding); //将字符串写入</div><div> } </div><p></p></pre></div><div>3.2、如果传入的参数是buffer实例，则将copy这份buffer实例内容：如果传入的buffer实例是与其他buffer共享内存存储的话，则要根据偏移量进行copy，如果是独享的则不用，偏移量设置为0。之后再讨论buffer.copy的方法</div><div><pre><p></p><div>else if (Buffer.isBuffer(subject)) {</div><div>        if (subject.parent)</div><div>          subject.parent.copy(this.parent,</div><div>                              this.offset,</div><div>                              subject.offset,</div><div>                              this.length + subject.offset);</div><div>        else</div><div>          subject.copy(this.parent, this.offset, 0, this.length);</div><div>} </div><p></p></pre></div><div>3.3、如果是字符数组，则循环将buf实例的parent实例的偏移之后的内容刷入字符数组的内容，代码如下：</div><div><pre><p></p><div>else if (isArrayIsh(subject)) {</div><div>        for (var i = 0; i &lt; this.length; i++)</div><div>          this.parent[i + this.offset] = subject[i];</div><div>      }</div><p></p></pre></div><div>我们看一下<span style="line-height:22px;font-family:monospace;white-space:pre">isArrayIsh工具函数</span></div><div><pre><p>function isArrayIsh(subject) {
  return Array.isArray(subject) ||
         subject &amp;&amp; typeof subject === &#39;object&#39; &amp;&amp;
         typeof subject.length === &#39;number&#39;;
}</p></pre></div><div><font face="monospace"><span style="white-space:pre">这个</span></font><span style="line-height:22px;font-family:monospace;white-space:pre">isArrayIsh接受2种数组</span></div><div><span style="line-height:22px;font-family:monospace;white-space:pre">1、['a','b','c','d']</span></div><div><span style="line-height:22px;font-family:monospace;white-space:pre">2、{1:'a',2:'b',3:'c',4:'d',length:4}</span></div><div><br></div><div><br></div><div>4.最后buffer类将调用C++接口，把数据刷入内存,其实是利用v8接口建立起内存地址和js对象之间的引用。</div><div>SlowBuffer.makeFastBuffer(this.parent, this, this.offset, this.length);</div><div><br></div><div>目前为止，我们创建了一个新的buf实例，但是具体它是如何被创建和存储的呢？我们主要看如下代码：</div><div>当创建的buffer超过8KB时，buffer.js用如下代码创建一个buffer实例，</div><div><pre><p>this.parent = new SlowBuffer(this.length);</p></pre></div><div><br></div><div>当小于8KB时则使用如下代码，创建一个空的8KB内存空间</div><div><pre><p></p><div>function allocPool() {</div><div>  pool = new SlowBuffer(Buffer.poolSize);</div><div>  pool.used = 0;</div><div>}</div><div><br></div><div>buffer类代码：</div><div>if (!pool || pool.length - pool.used &lt; this.length) allocPool();<br>      this.parent = pool;</div><p></p></pre></div><div>可见，buffer实例的parent属性保存着slowbuffer实例，可以调用c++封装暴露出的接口。</div><div><br></div><div>我们先看一下C++为slowerbuffer定义了多少接口：</div><div><pre><p>static void Initialize(v8::Handle&lt;v8::Object&gt; target); //初始化函数</p></pre><pre><p>// copy free<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "binarySlice", Buffer::BinarySlice);<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "asciiSlice", Buffer::AsciiSlice);<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "base64Slice", Buffer::Base64Slice);<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "ucs2Slice", Buffer::Ucs2Slice);<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "hexSlice", Buffer::HexSlice);<br>  // TODO NODE_SET_PROTOTYPE_METHOD(t, "utf16Slice", Utf16Slice);<br>  // copy<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "utf8Slice", Buffer::Utf8Slice);<br><br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "utf8Write", Buffer::Utf8Write);<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "asciiWrite", Buffer::AsciiWrite);<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "binaryWrite", Buffer::BinaryWrite);<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "base64Write", Buffer::Base64Write);<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "ucs2Write", Buffer::Ucs2Write);<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "hexWrite", Buffer::HexWrite);<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "readFloatLE", Buffer::ReadFloatLE);<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "readFloatBE", Buffer::ReadFloatBE);<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "readDoubleLE", Buffer::ReadDoubleLE);<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "readDoubleBE", Buffer::ReadDoubleBE);<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "writeFloatLE", Buffer::WriteFloatLE);<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "writeFloatBE", Buffer::WriteFloatBE);<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "writeDoubleLE", Buffer::WriteDoubleLE);<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "writeDoubleBE", Buffer::WriteDoubleBE);<br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "fill", Buffer::Fill); <br>  NODE_SET_PROTOTYPE_METHOD(constructor_template, "copy", Buffer::Copy);<br><br>  NODE_SET_METHOD(constructor_template-&gt;GetFunction(),<br>                  "byteLength",<br>                  Buffer::ByteLength);<br>  NODE_SET_METHOD(constructor_template-&gt;GetFunction(),<br>                  "makeFastBuffer",<br>                  Buffer::MakeFastBuffer);</p></pre><div><br></div>大致定义了以上这么多接口可以供node调用，同时对buffer.cc还定义了setFastBufferConstructor函数，不过在buffer.js中没有用到它，是用来设置<span style="line-height:22px">fast_buffer_constructor静态变量的，主要用于判断node的对象是否为Buffer类的实例</span></div><div><br>当node调用 var buf = new Buffer()</div><div>会将poolsize发给buffer::new这个方法：</div><div><div><pre><p></p><div>Handle&lt;Value&gt; Buffer::New(const Arguments &amp;args) {</div><div>  if (!args.IsConstructCall()) { //如果不是构造函数调用，如果不是，则使用构造函数调用</div><div>    return FromConstructorTemplate(constructor_template, args);</div><div>  }</div><div><br></div><div>  HandleScope scope;</div><div><br></div><div>  if (!args[0]-&gt;IsUint32()) return ThrowTypeError(&quot;Bad argument&quot;);</div><div><br></div><div>  size_t length = args[0]-&gt;Uint32Value();</div><div>  if (length &gt; Buffer::kMaxLength) {</div><div>    return ThrowRangeError(&quot;length &gt; kMaxLength&quot;);</div><div>  }</div><div>  new Buffer(args.This(), length);</div><div><br></div><div>  return args.This();</div><div>}</div><p></p></pre></div>对参数做了一些合法性验证之后，将实例化Buffer类，执行Buffer的构造函数：</div><div><pre><p></p><div>Buffer::Buffer(Handle&lt;Object&gt; wrapper, size_t length) : ObjectWrap() {</div><div>  Wrap(wrapper);</div><div><br></div><div>  length_ = 0;</div><div>  callback_ = NULL;</div><div>  handle_.SetWrapperClassId(BUFFER_CLASS_ID);</div><div>//定义包装的对象ID，检查堆的运行情况，初始化时会去定义这个堆的id和回调函数</div><div><br></div><div>  Replace(NULL, length, NULL, NULL);</div><div>}</div><p></p></pre></div>Buffer类构造函数初始化了两个类成员，然后设定了 <span style="font-family:monospace;line-height:22px;white-space:pre">SetWrapperClassId ，最后调用replace函数申请内存空间</span><div><pre><p><font face="monospace">// if replace doesn't have a callback, data must be copied<br>// const_cast in Buffer::New requires this<br>void Buffer::Replace(char *data, size_t length,<br>                     free_callback callback, void *hint) {<br>  HandleScope scope;<br><br>  if (callback_) {//非初始化执行</font><font face="monospace"><br>    callback_(data_, callback_hint_);<br>  } else if (length_) {<br>    delete [] data_; <br>    V8::AdjustAmountOfExternalAllocatedMemory(<br>        -static_cast&lt;intptr_t&gt;(sizeof(Buffer) + length_));<br>  }<br><br>  length_ = length; <br>  callback_ = callback;<br>  callback_hint_ = hint;<br><br>  if (callback_) { //初始化不执行<br>    data_ = data;<br>  } else if (length_) { //初始化执行<br>    data_ = new char[length_]; //将data_指针指向char[length]<br>    if (data) //参数传递了<br>      memcpy(data_, data, length_); //从data内存指针拷贝length长度的字节到data_指针指向的内存中<br>    V8::AdjustAmountOfExternalAllocatedMemory(sizeof(Buffer) + length_); </font></p><p><font face="monospace">//调用V8调整外部内存大小的</font></p><p><font face="monospace">//文档上说注册更多的外部内存会让V8的GC更加活跃</font></p><p>//当然从这点我们就可以发现，slowbuffer的创建确实会有消耗</p><p><font face="monospace"><br>  } else {<br>    data_ = NULL;<br>  }<br><br>  handle_-&gt;SetIndexedPropertiesToExternalArrayData(data_,   <br>                                                   kExternalUnsignedByteArray,<br>                                                   length_);</font></p><p><font face="monospace">//</font><span style="line-height:22px">SetIndexedPropertiesToExternalArrayData表示将js对象的内存地址通过V8做好关联，当js对象失去对这个地址的访问</span></p><p><span style="line-height:22px">//v8引起将delete这个</span><span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">data_ </span><span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">指针。</span></p><p><font face="monospace"><br>  handle_-&gt;Set(length_symbol, Integer::NewFromUnsigned(length_));</font></p><p><font face="monospace"><br></font></p><p><font face="monospace">//关于这个handle_是在node_object_wrap.h文件中的ObjectWrap类定义的</font></p><p><font face="monospace">//v8::Persistent&lt;v8::Object&gt; handle_; // ro 至于 </font><span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">Persistent 和 handle 的区别，cnode上有一篇文章介绍的很详细，</span></p><p><span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">//简单点说就是：handle是栈，</span><span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">Persistent是堆</span></p><p>//最后这行表示设置这个对象的属性length</p><p>//<span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">length_symbol 表示length ，见代码：</span></p><p><font face="monospace">// length_symbol = NODE_PSYMBOL("length");<br>}</font></p></pre></div><div><span style="font-family:monospace;line-height:22px;white-space:pre">另外v8手册已经废弃了</span><span style="line-height:22px;font-family:monospace;white-space:pre">V8::AdjustAmountOfExternalAllocatedMemory</span><span style="line-height:22px;font-family:monospace;white-space:pre">，转而使用Isolate类</span></div><div><div style="font-family:&#39;Lucida Grande&#39;,Verdana,Geneva,Arial,sans-serif;font-size:12px;border-top-width:1px;border-top-style:solid;border-top-color:rgb(168,184,217);border-left-width:1px;border-left-style:solid;border-left-color:rgb(168,184,217);border-right-width:1px;border-right-style:solid;border-right-color:rgb(168,184,217);padding:6px 0px;color:rgb(37,53,85);font-weight:bold;border-top-right-radius:8px;border-top-left-radius:8px;background-color:rgb(226,232,242);line-height:normal;background-repeat:repeat no-repeat"><table style="font-size:12px;white-space:nowrap;font-weight:bold;margin-left:6px"><tbody><tr><td style="margin-left:6px">static intptr_t v8::V8::AdjustAmountOfExternalAllocatedMemory</td><td>(</td><td>intptr_t </td><td style="color:rgb(96,32,32)"><em style="font-style:normal">change_in_bytes</em></td><td> ) </td><td><code>[static]</code></td></tr></tbody></table></div><div style="font-family:&#39;Lucida Grande&#39;,Verdana,Geneva,Arial,sans-serif;font-size:12px;border-width:0px 1px 1px;border-bottom-style:solid;border-bottom-color:rgb(168,184,217);border-left-style:solid;border-left-color:rgb(168,184,217);border-right-style:solid;border-right-color:rgb(168,184,217);padding:2px 5px;background-color:rgb(251,252,253);border-bottom-left-radius:8px;border-bottom-right-radius:8px;background-image:-webkit-gradient(linear,50% 0%,50% 100%,from(rgb(255,255,255)),,,,to(rgb(238,241,247)));line-height:normal"><p>Deprecated. Use <a style="color:rgb(70,101,162);font-weight:bold;text-decoration:none" rel="nofollow" href="http://bespin.cz/~ondras/html/classv8_1_1Isolate.html#af59797f9f30d2712b431f1fba8aa599f">Isolate::AdjustAmountOfExternalAllocatedMemory</a> instead.</p></div></div><div><span style="font-family:monospace;line-height:22px;white-space:pre"><br></span></div><div><span style="font-family:monospace;line-height:22px;white-space:pre"><br></span></div><div><span style="font-family:monospace;line-height:22px;white-space:pre">测试环境：4CPU Linux 2.6.8 x64 8G Men</span></div><div><span style="font-family:monospace;line-height:22px;white-space:pre"><br></span></div><div><font face="monospace"><span style="white-space:pre">测试1：</span></font></div><div><font face="monospace"><span style="white-space:pre">生成两种buffer，对比速度：</span></font></div><div><font face="monospace"><span style="white-space:pre">A、1024*4</span></font></div><div><font face="monospace"><span style="white-space:pre">B、1024*4+1</span></font></div><div><font face="monospace"><span style="white-space:pre">代码：</span></font></div><div><pre><p>var time = 10*10000; //10万次<br>console.time('1024*4')<br>for(var i=0;i&lt;time;i++)<br>    var x = new Buffer(1024*4);<br>console.timeEnd('1024*4')<br><br>console.time('1024*4+1')<br>for(var j=0;j&lt;time;j++)<br>  var y = new Buffer(1024*4+1);<br>console.timeEnd('1024*4+1')<br></p><div><br></div></pre></div><div><span style="font-family:monospace;line-height:22px;white-space:pre">测试结果：</span></div><div><pre><p>1024*4: 337ms<br>1024*4+1: 615ms</p></pre></div><div><font face="monospace"><span style="white-space:pre">虽然只有1字节的改变，但是生成的速度却将近相差1倍。<br>当然这也算8KB的一个注意点，但是从中我们不难发现，重新申请一份额外的内存空间的消耗是挺大的。</span></font></div><div><font face="monospace"><span style="white-space:pre"><br></span></font></div><div><font face="monospace"><span style="white-space:pre">测试2：</span></font></div><div><font face="monospace"><span style="white-space:pre">我们如何避免频繁的生成slowbuffer将是性能上的一个重点</span></font></div><div><span style="font-family:monospace;line-height:22px;white-space:pre">比如我们有10万个长度在1至2048之间不等的字符串我们需要保存，并且我们需要快速的读取其中的任意一个字符串出来。</span></div><div><span style="font-family:monospace;line-height:22px;white-space:pre">测试代码：</span></div><div><pre><p>var time = 10*10000;<br>var str = '1';<br>var max = 2048;<br><br>console.time('many buffer')<br>var ary1=[]<br>for(var i=0;i&lt;time;i++){<br> var tempi = Math.ceil(Math.random()*max)<br>    var tempstr = str<br>   while(tempi--){<br>     tempstr += str<br>  }<br>   ary1.push(new Buffer(tempstr))<br>}<br>console.timeEnd('many buffer')<br><br>console.time('one buffer')<br>var ary_offset=[];<br>var ary_len=[];<br><span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">var tempbuf = new Buffer(time*max)</span><br>var offset = 0;<br>for(var i=0;i&lt;time;i++){<br>   var len;<br>    var tempi = len = Math.ceil(Math.random()*max)<br>  var tempstr = str<br>   while(tempi--){<br>     tempstr += str<br>  }<br>   var end = offset+len<br><br>    tempbuf.fill(tempstr, offset, end)<br>      ary_offset.push(offset)<br>     ary_len.push(end)<br>    offset = end<br>}<br>console.timeEnd('one buffer')<br><br><br>console.time('many buffer read')<br>for(var x=0;x&lt;100000;x++){<br>    ary1[x].toString('utf-8')<br>}<br>console.timeEnd('many buffer read')<br><br>console.time('one buffer read')<br>for(var y=0;y&lt;100000;y++){<br>   tempbuf.toString('utf-8', ary_offset[y], ary_len[y])<br>}<br>console.timeEnd('one buffer read')</p></pre></div><div><span style="font-family:monospace;line-height:22px;white-space:pre">测试结果：</span></div><div><pre><p>many buffer: 4622ms<br>one buffer: 2942ms<br>many buffer read: 92ms<br>one buffer read: 91ms</p></pre></div><div><span style="font-family:monospace;line-height:22px;white-space:pre">结果表明这两种方法生成的速度相差比较大，但是遍历读取速度相当，可是消耗的内存第二种更大一些。<br>对于内存的消耗和执行的时间取舍我们要根据实际情况来取舍了。</span></div><div><br></div><div><span style="font-family:monospace;line-height:22px;white-space:pre"><br></span></div><div><span style="font-family:monospace;line-height:22px;white-space:pre"><br></span></div><div><span style="font-family:monospace;line-height:22px;white-space:pre">总结一下：</span></div><div><span style="font-family:monospace;line-height:22px;white-space:pre">1、8KB的内存使用注意情况，不多说了，看我上面给出的链接有详细说明，第一个例子也说明了8KB的问题</span></div><div><span style="font-family:monospace;line-height:22px;white-space:pre">2、可能创建buffer对于8KB的性能问题更突出一些，但是我们还是应当尽量避免大数量的创建buffer对象，<br>如果真的有必要创建很多buffer对象，不如创建一个大的buffer，然后记录每块使用的偏移这样比生成很多小buffer要快很多。</span></div><div><span style="font-family:monospace;line-height:22px;white-space:pre"><br></span></div><div><span style="font-family:monospace;line-height:22px;white-space:pre"><br></span></div><div><span style="font-family:monospace;line-height:22px;white-space:pre"><br></span></div><div><span style="font-family:monospace;line-height:22px;white-space:pre"><br></span></div><div><span style="font-family:monospace;line-height:22px;white-space:pre"><br></span></div></div>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
