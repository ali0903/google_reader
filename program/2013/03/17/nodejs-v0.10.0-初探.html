<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>nodejs-v0.10.0 初探</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>nodejs-v0.10.0 初探</h2>
<p class="meta">2013-03-17 00:37</p>

<div class="post">
<h2>nodejs-v0.10.0 初探</h2>

<h3>by snoopyxdy</h3>

<h3>at 2013-03-16 16:37:51</h3>

<h3>original <a href="http://snoopyxdy.blog.163.com/blog/static/6011744020132129942981">http://snoopyxdy.blog.163.com/blog/static/6011744020132129942981</a></h3>

<div><b style="line-height:22px">v0.10.0介绍</b><div><span style="line-height:22px">nodev10.0版本来了，对于性能官方肯定是说性能大大提高了</span><b><br></b><div><div><a rel="nofollow" href="http://blog.nodejs.org/2013/03/11/node-v0-10-0-stable/">http://blog.nodejs.org/2013/03/11/node-v0-10-0-stable/</a></div><div>大致翻译如下：</div><div>很高兴一个新的稳定版本的node发布了。</div><div>这个分支带来了很多显著的改进，主要是api的调整，让我们更加容易使用并且向后兼容。</div><div>在之前的帖子中，我们介绍了stream2的api调整了，如果你还没有阅读他，请尽快阅读他。（剩下的就是说之前stream的api不是很完善，现在他们下决心要让这个api更好）</div><div><br></div><div>更重要的是stream作为node的核心，改变之后接口变得更加易用了。<span style="line-height:22px">所以强烈建议使用stream2的api，对于node 0.8，你可以安装 readable-stream 包来支持。 </span></div><div><span style="line-height:22px"><br></span></div><div>domain模块从实验级别提高到了不稳定级别（尼玛还是坑爹），使用了domain模块，我们不再依赖于 process.on(&#39;uncaughtException&#39;) 这样的错误控制了，如果你还没有使用domain来做错误处理，那你就要仔细检查哪些中间件和异步回调了（感觉有点威胁啊~）。</div><div><br></div><div>在0.8以及之前， process.nextTick() 会在当前事件循环结束时调用，这样通常是会在I/O开始前被调用的。所以很多项目都会使用<span style="line-height:22px">process.nextTick()让它晚点做，而在I/O之前，看上去这样是正确的。事实上在大负载的I/O情况下，</span><span style="line-height:22px">nextTick可能工作不正常，出现线程竞争情况。所以在v0.10.0版本 </span><span style="line-height:22px">process.nextTick() 会在js代码执行完成后调用，而不是写入事件循环，可以说变同步了。应该尽量避免使用 </span><span style="line-height:22px"> process.nextTick() 来做递归，如果非要这么做请使用 </span>setImmediate 来代替。</div><div><br></div><div>当事件循环闲置时，node会告诉V8开始做GC。事实上要找到正确的时间GC是非常困难的，当你选错时间GC将会耗费大量时间。在实践中，禁用IdleNotification会得到更好的效果。（他们现在依靠V8的GC了，因为他们觉得V8会很聪明的知道什么时候GC是最合适的，而不去手动的通知了）</div><div><br></div><div>再下面就是一些性能测试了，可以看出我们在响应大数据的字符串时，尽量使用buffer提高性能，v0.10.0在http方面要快于v0.8版本要快7%左右，读写文件性能也是提升显著。所以官方建议大家有条件的一定要升级到v0.10.0。</div><div><br></div><div>PS：当然现在还有使用古董级的0.6.x~</div><div><br></div><div><b>API改变：</b><div><a rel="nofollow" href="https://github.com/joyent/node/wiki/Api-changes-between-v0.8-and-v0.10">https://github.com/joyent/node/wiki/Api-changes-between-v0.8-and-v0.10</a></div><div>大致意思是stream api的改变比较大，</div><div>1、增加了Readable, Writable, Duplex, and Transform的基类，我们可以直接从这些基类继承了</div><div>2、Readable streams 使用一个read方法，代替触发“data”的情况</div><div>3、增加一个"data"的监听器，或者调用“pause()” 和 “resume()” 会切换到旧stream模式</div><div>4、“data”的事件监听器永远不会错过第一个文件块，无论他们是否马上建立，pause 不再是咨询，而可以保证暂停</div><div>5、如果你不消耗数据，stream流永远是处于pause等待状态，而永远不会触发end事件</div><div>6、process.nextTick 会在当前事件结束调用，会在当前堆释放时执行，如果你打算递归的使用，请用setImmediate 代替</div><div>7、url.parse 将返回更多的信息如下：</div><div><pre><p></p><div>// v0.8</div><div>&gt; url.parse(&#39;http://foo&#39;)</div><div>{ protocol: 'http:',</div><div>  slashes: true,</div><div>  host: &#39;foo&#39;,</div><div>  hostname: &#39;foo&#39;,</div><div>  href: &#39;http://foo/&#39;,</div><div>  pathname: &#39;/&#39;,</div><div>  path: &#39;/&#39; }</div><div><br></div><div>// 0.10</div><div>&gt; url.parse(&#39;http://foo&#39;)</div><div>{ protocol: 'http:',</div><div>  slashes: true,</div><div>  auth: null,</div><div>  host: &#39;foo&#39;,</div><div>  port: null,</div><div>  hostname: &#39;foo&#39;,</div><div>  hash: null,</div><div>  search: null,</div><div>  query: null,</div><div>  pathname: &#39;/&#39;,</div><div>  path: &#39;/&#39;,</div><div>  href: &#39;http://foo/&#39; }</div><p></p></pre></div><div>8、<span style="line-height:22px">domain模块对错误对象增加一个属性</span><span style="line-height:22px">camelCase</span><span style="line-height:22px"> 代替</span><span style="line-height:22px">snake_case</span></div><div>9、path.resolve 和 path.join 将会抛出异常，当传递的参数为空字符串时</div><div>10、dgram.Socket #bind() 会是一个异步方法，请在第二个参数增加回调函数</div><div>11、EventEmitter 基类的继承请使用新方法，以下方法将不会被支持：</div><div><pre><p></p><div>function Child() {}</div><div>Child.prototype = new Parent(); // &lt;-- NEVER EVER DO THIS!!</div><p></p></pre></div><div>使用如下的代码代替上面的：（终于js有点像样点的继承了，蛋疼了多少年啊）</div><div><pre><p></p><div>// Correct-Style Inheritance</div><div>function Child() {}</div><div>Child.prototype = Object.create(Parent.prototype, {</div><div>  constructor: {</div><div>    value: Child,</div><div>    enumerable: false,</div><div>    writable: true,</div><div>    configurable: true</div><div>  }</div><div>});</div><div>// "Gee that's a lot of lines! I wish there was a helper method!"</div><div>// There is.  Do this:</div><div>util.inherits(Child, Parent);</div><p></p></pre></div><div><b><br></b></div><div><b>12、增加的一些api</b></div><div>12.1、stream增加<span style="line-height:22px"> Readable, Writable, Duplex, and Transform 基类</span></div><div>12.2、crypto 的api 有stream接口的支持</div><div>12.3、process增加<span style="line-height:22px">getgroups(), setgroups(), initgroups()</span></div><div><span style="line-height:22px">12.4、</span><span style="line-height:22px">crypto增加</span><span style="line-height:22px">getHashes() getCiphers()</span></div><div>12.5、http模块增加<span style="line-height:22px"> </span><span style="line-height:22px">response.headersSent 属性</span></div><div>12.6、增加‘<span style="line-height:22px">removeListener</span><span style="line-height:22px">’这个事件的触发，可以监听这个事件</span></div><div><span style="line-height:22px">12.6、增加</span><span style="line-height:22px">setImmediate() 和 clearImmediate()</span><span style="line-height:22px"> 函数</span></div><div><span style="line-height:22px">12.7、字符串解码器增加  </span><span style="line-height:22px"> </span><span style="line-height:22px">decoder.end() 函数</span></div><div><br></div><div><b>stream2：</b></div><div>最后我们来看一下stream2的一些api和新用法，首先我们要升级node到v0.10.0</div><div><pre><p># node -v<br>v0.10.0</p></pre><div><br></div>stream是一个抽象类，它类继承自EventEmitter，例如http服务器就是一个stream，它是可读可写的，在早期的node版本中，stream类的接口是简单的，但是不够强大，可用性也不好。</div><div>1、不是当你调用read()函数，数据data将会马上接受，如果你想要做一些I/O来决定如何处理这些数据，你不得不建立一个buffer来存储那些数据。</div><div>2、pause()方法只是咨询，不能保证，可能当你调用pause()方法后，你还在接受data。</div><div><br></div><div>很多项目都无须调用data事件来监听，也不调用pause()和resume()方法。</div><div>我们看如下代码：</div><div><pre><p></p><div>// WARNING!  BROKEN!</div><div>net.createServer(function(socket) {</div><div><br></div><div>  // we add an &#39;end&#39; method, but never consume the data</div><div>  socket.on(&#39;end&#39;, function() {</div><div>    // It will never get here.</div><div>    socket.end(&#39;I got your message (but didnt read it)\n&#39;);</div><div>  });</div><div><br></div><div>}).listen(1337);</div><p></p></pre></div><div>在v0.10.0版本之前，发送过来的数据将会丢失，因为我们没有做data事件的监听。在v0.10.0及以后，上面这段代码socket会一直处于暂停状态而接受数据</div><div><br></div><div>解决方法，代码如下：</div><div><div><pre><p></p><div><div>// Workaround</div><div>net.createServer(function(socket) {</div><div><br></div><div>  socket.on(&#39;end&#39;, function() {</div><div>    socket.end(&#39;I got your message (but didnt read it)\n&#39;);</div><div>  });</div><div><br></div><div>  // start the flow of data, discarding it.</div><div>  socket.resume();</div><div><br></div><div>}).listen(1337);</div></div><div></div><p></p></pre></div></div><div><br></div><div>创建一个只读stream类实例：</div><div><b>new stream.Readable([options])</b></div><div>options可配置</div><div>1、<span style="line-height:22px">highWaterMark</span><span style="line-height:22px"> </span><span style="line-height:22px"> </span><span style="line-height:22px">{Number}</span><span style="line-height:22px"> ，这个数字表示read stream 缓冲区，默认16kb</span></div><div><span style="line-height:22px">2、</span><span style="line-height:22px">encoding {String} 表示buffer的类型，默认为null，可以传入字符串的格式，比如utf-8</span></div><div><span style="line-height:22px">3、</span><span style="line-height:22px">objectMode {Boolean}</span><span style="line-height:22px"> 表示是返回一个buffer对象还是值返回这个buffer对象的size n</span></div><div><br></div><div><b>readable._read(size)</b></div><div>这个方法不应该被直接调用，应该被内部的readable class 调用。所有readable的stream都必须提供一个_read的方法从数据源来获取数据。</div><div>size参数是咨询的，可能不是很正确，当使用tcp或者tls时会忽略这个参数。所以没有必要等设定的size的数据都到了，才去调用stream.push(chunk)方法</div><div><br></div><div><b>readable.push(chunk)</b></div><div><span style="line-height:22px">chunk {Buffer | null | String} </span><span style="line-height:22px">将块放入队列</span></div><div><div>return {Boolean}  如果为false则表示没有数据进行push</div></div><div>这个方法不是给readable消费者调用，而是给数据发送者调用，将数据push进队列里，push后，_read()方法就会从队列里读取数据了。</div><div>push方法明确的对readable队列内插入数据，当插入null时，则会发出数据发送完毕的信号</div><div>看一下简单的代码：</div><div><div><pre><p></p><div><div>// source is an object with readStop() and readStart() methods,</div><div>// and an `ondata` member that gets called when it has data, and</div><div>// an `onend` member that gets called when the data is over.</div><div><br></div><div>var stream = new Readable(); //实例化</div><div><br></div><div>source.ondata = function(chunk) {</div><div>  // if push() returns false, then we need to stop reading from source</div><div>  if (!stream.push(chunk))</div><div>    source.readStop();</div><div>};</div><div><br></div><div>source.onend = function() {</div><div>  stream.push(null);</div><div>};</div><div><br></div><div>// _read will be called when the stream wants to pull more data in</div><div>// the advisory size argument is ignored in this case.</div><div>stream._read = function(n) {</div><div>  source.readStart();</div><div>};</div></div><div></div><p></p></pre></div></div><div><br></div><div><b>readable.unshift(chunk)</b></div><div><div style="line-height:22px"><span style="line-height:22px">chunk {Buffer | null | String} </span><span style="line-height:22px">将块从队列头部push</span></div><div style="line-height:22px"><div style="line-height:22px">return {Boolean}  如果为false则表示没有数据进行unshift</div></div></div></div></div><div>看实例代码：</div><div><pre><span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">// A parser for a simple data protocol.</span><br><p>// The "header" is a JSON object, followed by 2 \n characters, and<br>// then a message body.<br>//<br>// Note: This can be done more simply as a Transform stream.  See below.<br><br>function SimpleProtocol(source, options) { //定义一个<span style="line-height:22px">SimpleProtocol 类</span><br>  if (!(this instanceof SimpleProtocol))<br>    return new SimpleProtocol(options);<br><br>  Readable.call(this, options);//执行readable构造函数<br>  this._inBody = false; //_inbody表示是否开始接受body<br>  this._sawFirstCr = false; //表示是否看见第一个换行<br><br>  // source is a readable stream, such as a socket or file<br>  this._source = source; //将数据源赋值到this._source,source是一个readable stream<br><br>  var self = this;<br>  source.on('end', function() { //当数据源 end 事件触发，则 <span style="line-height:22px">SimpleProtocol 实例push一个null，表示没有数据push到队列中</span><br>    self.push(null);<br>  });<br><br>  // give it a kick whenever the source is readable<br>  // read(0) will not consume any bytes<br>  source.on('readable', function() { //read(0) 表示不消费任何字节<br>    self.read(0);<br>  });<br><br>  this._rawHeader = []; //存放待格式化的头部的数组<br>  this.header = null; <br>}<br><br>SimpleProtocol.prototype = Object.create( //<span style="line-height:22px">SimpleProtocol继承readable类</span><br>  Readable.prototype, { constructor: { value: SimpleProtocol }});<br><br>SimpleProtocol.prototype._read = function(n) {<br>  if (!this._inBody) { //如果还没接受body，表示接受head<br>    var chunk = this._source.read(); //从source中读取chunck<br><br>    // if the source doesn't have data, we don't have data yet.</p><p>    //如果source还没有数据，那我们就push空字符串<br>    if (chunk === null)<br>      return this.push('');<br><br>    // check if the chunk has a \n\n <br>    var split = -1;<br>    for (var i = 0; i &lt; chunk.length; i++) { //开始逐个解析chunk中的字符串，查看是否包含2个连续的/n<br>      if (chunk[i] === 10) { // '\n'  //如果发现是/n<br>        if (this._sawFirstCr) { //如果上一个也是 /n 则这边为true<br>          split = i; //找到了连续了/n 表示头部结束了，跳出循环，记录位置<br>          break;<br>        } else { //如果上一个字符不是 /n ，则把 <span style="line-height:22px">_sawFirstCr 设为true</span><br>          this._sawFirstCr = true;<br>        }<br>      } else { //如果本字符不是 /n 则 <span style="line-height:22px">_sawFirstCr 设置为false</span><br>        this._sawFirstCr = false;<br>      }<br>    }<br><br>    if (split === -1) { //如果没有找到2个/n则继续等待，push空字符串，将chunk暂时保存<br>      // still waiting for the \n\n<br>      // stash the chunk, and try again.<br>      this._rawHeader.push(chunk);<br>      this.push('');<br>    } else {  //如果找到2个/n了，则表示以后就开始接受body<br>      this._inBody = true; //将inbody设置为true，表示今后开始接受body<br>      var h = chunk.slice(0, split); //将此次的chunk切分，头部放入待格式化数组<br>      this._rawHeader.push(h); <br>      var header = Buffer.concat(this._rawHeader).toString(); //然后将待格式化数组中的内容组合<br>      try {<br>        this.header = JSON.parse(header); //转化js对象<br>      } catch (er) {<br>        this.emit('error', new Error('invalid simple protocol data'));<br>        return;<br>      }<br>      // now, because we got some extra data, unshift the rest<br>      // back into the read queue so that our consumer will see it.<br>      var b = chunk.slice(split); <br>      this.unshift(b);<span style="line-height:22px">//此时将chunk中取出的b也就是body部分，再塞回队列头部</span><br><br>      // and let them know that we are done parsing the header.<br>      this.emit('header', this.header);  //触发header事件，并且把this.header作为参数传递过去<br>    }<br>  } else { //表示开始接受body<br>    // from there on, just provide the data to our consumer.<br>    // careful not to push(null), since that would indicate EOF.</p><p>    //从这里开始，表示对我们的消费者也就是api使用者提供数据了，注意不要push(null),因为null表示结束<br>    var chunk = this._source.read();<br>    if (chunk) this.push(chunk);<br>  }<br>};<br><br>// Usage:</p><p>var parser = new SimpleProtocol(source);<br>// Now parser is a readable stream that will emit 'header'<br>// with the parsed header data.</p><p>//这样parser就可以解析source的数据了，当header解析完毕，就会触发 <span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">header 事件</span></p></pre><br></div><div><b>readable.wrap(stream)</b></div><div>主要是用来向前兼容的，如果你使用了旧的node库，还使用data事件触发和pause()，则可以使用wrap来创建一个readable stream，这个stream是用旧的的数据源，代码如下：</div><div><pre><p></p><div>var OldReader = require('./old-api-module.js').OldReader;</div><div>var oreader = new OldReader;</div><div>var Readable = require('stream').Readable;</div><div>var myReader = new Readable().wrap(oreader);</div><div><br></div><div>myReader.on('readable', function() {</div><div>  myReader.read(); // etc.</div><div>});</div><p></p></pre></div><div><br></div><div><b>Event: 'readable'</b></div><div>当数据准备好被消费时，这个事件就会被触发，当这个事件触发，调用read()方法去消费数据</div><div><br></div><div><b>Event: 'end'</b></div><div>当stream接受到eof关闭，则会触发此事件，指示没有数据会再发送，如果这个stream是可写的，则可能它还在被写入</div><div><br></div><div><b>Event: 'error'</b></div><div>触发error事件</div><div><br></div><div><b>Event: 'close'</b></div><div>当数据源关闭触发，并不是所有的数据源都会触发</div><div><br></div><div><b>readable.setEncoding(encoding)</b></div><div>设置data事件触发的参数是什么格式的，比如buffer或者utf-8</div><div><br></div><div><b>readable.read([size])</b></div><div><div><span style="line-height:22px">size {Number | null}  定义读取多少数据</span></div><div>Return: {Buffer | String | null} 返回buffer或者string</div></div><div>注意：这个方法是被stream消费者调用的</div><div>size的单位是bytes，如果不设置，则会返回内部buffer的整个内容。如果没有数据或者小于size的值，则null会返回，将来当返回更多了时候，会触发readable事件来让你消费数据</div><div>调用read(0)总是会返回null，并且会触发一次内部buffer的刷新，但是除此之外没有其他操作</div><div><br></div><div><b>readable.pipe(destination, [options])</b></div><div><div>destination {Writable Stream}    目标，一个可写入的stream</div><div>options {Object} Optional          设定参数</div><div>end {Boolean} Default=true       或者是一个布尔值表示是否关闭可写的stream，默认true的话会触发end事件，关闭stream</div></div><div>注意<span style="line-height:22px"> </span><span style="line-height:22px">process.stderr 和 process.stdout</span><span style="line-height:22px"> 除非进程退出，否则不会被关闭</span></div><div><span style="line-height:22px"><br></span></div><div><b>readable.unpipe([destination])</b></div><div><div>destination {Writable Stream}  可选参数</div><div>撤销一个先前建立的pipe，如果参数<span style="line-height:22px">destination</span><span style="line-height:22px"> 没有提供，则先前所有建立的pipe都被移除</span></div></div><div><span style="line-height:22px"><br></span></div><div><div><b>readable.pause()</b></div><div>切换readable stream为旧模式，当data事件触发，则使用一个data事件监听，而不是通过read()方法消费buffer缓存的数据。</div><div>停止数据流，当stream处于paused状态时，没有data事件会被触发</div><div><br></div><div><div><b>readable.resume()</b></div><div><span style="line-height:22px">在执行pause()方法之后，回复接受发送来的数据流</span></div></div><div><br></div></div><div><br></div><div><div><b>Class: stream.Writable</b></div><div>一个可写的流，拥有如下的方法，成员和事件</div><div>注意：可写流是一个抽象类，<span style="line-height:22px"> _write(chunk, encoding, cb) </span>设计是用来扩展底层实现的</div><div><br></div><div><div><b>new stream.Writable([options])</b></div><div><span style="line-height:22px">options {Object}</span></div><div>highWaterMark {Number}   缓冲区，当写入开始后返回false</div><div>decodeStrings {Boolean}    是否将string改写为buffer写入，默认是</div><div>如果要扩展writable 类，确认需要正确调用它的构造函数</div><div><br></div></div></div><div><br></div><div><div><b>writable._write(chunk, encoding, callback)</b></div><div><span style="line-height:22px">chunk {Buffer | String}  写入的chunk一直是buffer，除非在实例化时显示声明 </span><span style="line-height:22px">decodeStrings</span><span style="line-height:22px">  为 false</span></div><div><span style="line-height:22px">encoding {String}    如果chunk是字符串，则设置他的编码，如果chunk是buffer则会忽略此属性，注意chunk一直是buffer，除非显示的将</span><span style="line-height:22px">decodeStrings</span><span style="line-height:22px"> 设置为false</span></div><div><span style="line-height:22px">callback {Function}   此函数拥有一个可选的error参数，当处理完成提供的chunk会调用。</span></div><div><span style="line-height:22px"><br></span></div><div><span style="line-height:22px">所有的可写流实现必须提供一个_write方法来将数据发送给底层实现。</span></div></div><div><span style="line-height:22px"><br></span></div><div><div><b>writable.write(chunk, [encoding], [callback])</b></div><div><span style="line-height:22px">chunk {Buffer | String}   写入的数据</span></div><div>encoding {String} Optional.  如果写入的chunk是string，则encode默认为utf-8</div><div>callback {Function} Optional.  当chunk成功写入后调用</div><div><span style="line-height:22px">Returns {Boolean}  返回布尔值</span></div><div><span style="line-height:22px"><br></span></div><div><span style="line-height:22px">将chunk写入stream，返回true表示数据已经写入底层，放回false表明buffer已经满了，数据将会在将来发送过去，</span><span style="line-height:22px">drain事件会在buffer空了时候触发。什么时候write返回false，这取决于 </span><span style="line-height:22px">highWaterMark</span><span style="line-height:22px">  的设置</span></div><div><br></div></div><div><div><b>writable.end([chunk], [encoding], [callback])</b></div><div><span style="line-height:22px">chunk {Buffer | String} Optional final data to be written</span></div><div>encoding {String} Optional. If chunk is a string, then encoding defaults to 'utf8'</div><div>callback {Function} Optional. Called when the final chunk is successfully written.</div><div>调用这个方法表示最后的data写入了stream</div><div><br></div></div><div><br></div><div><div><b>Event: 'drain'</b></div><div><span style="line-height:22px">当stream的可写缓冲区为空时触发，当stream.write()返回false时监听它</span></div><div><br></div><div>#下面的比较简单不翻译了</div><div><b>Event: 'close'</b></div><div><span style="line-height:22px">Emitted when the underlying resource (for example, the backing file descriptor) has been closed. Not all streams will emit this.</span></div><div><br></div><div><b>Event: 'finish'</b></div><div><span style="line-height:22px">When end() is called and there are no more chunks to write, this event is emitted.</span></div><div><br></div><div><b>Event: 'pipe'</b></div><div><span style="line-height:22px">source {Readable Stream}</span></div><div>Emitted when the stream is passed to a readable stream's pipe method.</div><div><br></div><div><b>Event 'unpipe'</b></div><div><span style="line-height:22px">source {Readable Stream}</span></div><div>Emitted when a previously established pipe() is removed using the source Readable stream's unpipe() method.</div></div><div><br></div><div><div><b>Class: stream.Duplex</b></div><div>duplex stream是一个可读可写流，类似TCP socket链接</div><div><br></div><div><span style="line-height:22px">因为js没有多重继承，所以duplex类继承自readable类，然后寄生在writeable，因此他同时拥有_read()和_write()这2个方法，你可以扩展他们。</span></div><div><span style="line-height:22px"><br></span></div><div><div><b>new stream.Duplex(options)</b></div><div>options {Object}  同上</div><div>allowHalfOpen {Boolean} Default=true. 如果设置为false，则stream会自动将readable stream关闭，当可写流关闭，反之亦然</div><div><br></div></div></div><div><div><b>Class: stream.Transform</b></div><div>transform流是一个duplex流，它对于input和output存在因果关系，比如zlibstream或者一个crypto。</div><div><b><br></b></div><div>对于传入的数据和传出的数据时不同大小的，不同的数据块大小和不同的到达时间。例如：一个hash 流仅会output一个chunk当input输入完毕。一个zlib流可能会将输入流处理为更大或更小</div><div><br></div><div>不用提供 <span style="line-height:22px"> </span><span style="line-height:22px">_read()  和 _write() ，</span><span style="line-height:22px">Transform</span><span style="line-height:22px"> 类必须提供 </span><span style="line-height:22px">_transform() 方法，并且可能有一个可设定的提供</span><span style="line-height:22px">_flush()</span><span style="line-height:22px"> 方法</span></div><div><br></div><div><div><b>new stream.Transform([options])</b></div><div><span style="line-height:22px">options {Object}  同上</span></div><div><br></div></div></div><div><div><b>transform._transform(chunk, encoding, callback)</b></div><div><span style="line-height:22px">chunk {Buffer | String}  </span><span style="line-height:22px">写入的chunk一直是buffer，除非在实例化时显示声明 </span><span style="line-height:22px">decodeStrings</span><span style="line-height:22px">  为 false</span></div><div>encoding {String}<span style="line-height:22px">如果chunk是字符串，则设置他的编码，如果chunk是buffer则会忽略此属性，注意chunk一直是buffer，除非显示的将</span><span style="line-height:22px">decodeStrings</span><span style="line-height:22px"> 设置为false </span><span style="line-height:22px"> </span><span style="line-height:22px">此函数拥有一个可选的error参数，当处理完成提供的chunk会调用。</span></div><div><br></div><div><span style="line-height:22px">所有的</span><span style="line-height:22px">Transform</span><span style="line-height:22px">流实现必须提供一个</span><span style="line-height:22px">_transform </span><span style="line-height:22px">方法来接受输入和输出</span></div><div><br></div><div><span style="line-height:22px">_transform 必须做任何此类特殊</span><span style="line-height:22px">Transform 类的事情，处理字节的写入，然后将他们发送到可读部分的接口。做一些异步I/O，处理事情等等。</span></div><div>调用 <span style="line-height:22px">transform.push(outputChunk)</span><span style="line-height:22px"> 0次或多次，用来生成从输入到输出chunk块，次数是根据你想要对这个chunk输出多少块。</span></div><div>仅会在当前chunk已经完全被消费时才会调用callback函数。注意，可能有些特殊的输入input块没有output结果。</div><div><br></div><div><div><b>transform._flush(callback)</b></div><div><span style="line-height:22px">callback {Function}  这个回调函数会有一个可选的error参数，当你执行完flushing任何其余的数据</span></div><div><br></div><div>在某些情况下，你的 <span style="line-height:22px">transform</span><span style="line-height:22px"> 操作可能需要在流结束时，触发一个大一点的数据。比如zlib的压缩流会保存一些内部状态，所以它能达到最佳压缩状态，尽管到了最后，它还是需要一些数据，这样数据就会完整了。</span></div><div>在这情况，你需要执行 <span style="line-height:22px">_flush 方法，它会被调用在非常后面，在所有数据都被消费掉，但是还没有出发end的信号之前。回调会在flush操作完成之后执行。</span></div><div><span style="line-height:22px"><br></span></div><div><b>Example: SimpleProtocol parser</b></div></div></div><div><div>上面那个<span style="line-height:22px"> </span><span style="line-height:22px">simple protocol parser</span><span style="line-height:22px"> 可以被高级的</span><span style="line-height:22px"> </span><span style="line-height:22px">Transform stream class 更简单的实现出来。</span></div><div>在这个示例中，不用提供input作为参数，他将会通过pipe管道来解析，这将会更加通用的node 流方法。</div></div><div><br></div><div><pre><div><span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">function SimpleProtocol(options) {</span></div><div>  if (!(this instanceof SimpleProtocol))</div><div>    return new SimpleProtocol(options);</div><div><br></div><div>  Transform.call(this, options);</div><div>  this._inBody = false;</div><div>  this._sawFirstCr = false;</div><div>  this._rawHeader = [];</div><div>  this.header = null;</div><div>}</div><div><br></div><div>SimpleProtocol.prototype = Object.create(</div><div>  Transform.prototype, { constructor: { value: SimpleProtocol }});</div><div><br></div><div>SimpleProtocol.prototype._transform = function(chunk, encoding, done) {</div><div>  if (!this._inBody) {</div><div>    // check if the chunk has a \n\n</div><div>    var split = -1;</div><div>    for (var i = 0; i &lt; chunk.length; i++) {</div><div>      if (chunk[i] === 10) { // &#39;\n&#39;</div><div>        if (this._sawFirstCr) {</div><div>          split = i;</div><div>          break;</div><div>        } else {</div><div>          this._sawFirstCr = true;</div><div>        }</div><div>      } else {</div><div>        this._sawFirstCr = false;</div><div>      }</div><div>    }</div><div><br></div><div>    if (split === -1) {</div><div>      // still waiting for the \n\n</div><div>      // stash the chunk, and try again.</div><div>      this._rawHeader.push(chunk);</div><div>    } else {</div><div>      this._inBody = true;</div><div>      var h = chunk.slice(0, split);</div><div>      this._rawHeader.push(h);</div><div>      var header = Buffer.concat(this._rawHeader).toString();</div><div>      try {</div><div>        this.header = JSON.parse(header);</div><div>      } catch (er) {</div><div>        this.emit(&#39;error&#39;, new Error(&#39;invalid simple protocol data&#39;));</div><div>        return;</div><div>      }</div><div>      // and let them know that we are done parsing the header.</div><div>      this.emit(&#39;header&#39;, this.header);</div><div><br></div><div>      // now, because we got some extra data, emit this first.</div><div>      this.push(b);</div><div>    }</div><div>  } else {</div><div>    // from there on, just provide the data to our consumer as-is.</div><div>    this.push(b);</div><div>  }</div><div>  done();</div><div>};</div><div><br></div><div>var parser = new SimpleProtocol();</div><div>source.pipe(parser) //坑爹就是这里改变了</div><div><br></div><div>// Now parser is a readable stream that will emit 'header'</div><div>// with the parsed header data.</div><p></p></pre></div><div><b><br></b></div><div><div style="font-weight:bold">Class: stream.PassThrough</div><div>这是一个对transform的简单实现，他就是简单的将input转为output输出，它的目的是用来做示例和测试的，但是也有偶尔的情况它可以派上用场。</div><div><br></div><div><br></div><div><b>实际使用</b></div><div>stream2类介绍完毕了，我们看一下新的stream2类如何在实际使用，http发送请求，获取yahoo网站</div></div><div><pre><div><div>var http = require("http")</div><div>var options = {</div><div>  hostname: &#39;www.yahoo.com&#39;,</div><div>  port: 80,</div><div>  path: &#39;/&#39;,</div><div>  method: &#39;GET&#39;</div><div>};</div><div>var req = http.request(options, function(res) {</div><div>  //console.log(&#39;STATUS: &#39; + res.statusCode);</div><div>  //console.log(&#39;HEADERS: &#39; + JSON.stringify(res.headers));</div><div>  res.setEncoding(&#39;utf8&#39;);</div><div>  res.on(&#39;readable&#39;, function () {</div><div>      console.log(res.read())//这里就无须监听data事件然后拼字符串buffer之类了，直接监听可读事件，然后调用res.read()</div><div>  });</div><div><span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">});</span></div><div>req.on('error', function(e) {</div><div>  console.log(&#39;problem with request: &#39; + e.message);</div><div>});</div><div>// write data to request body</div><div>req.write('data\n');</div><div>req.write('data\n');</div><div>req.end();</div></div><div style="font-weight:bold"></div><p style="font-weight:bold"></p></pre></div><div><b><br></b></div><div><br></div></div></div>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
