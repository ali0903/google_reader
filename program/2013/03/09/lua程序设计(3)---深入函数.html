<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>lua程序设计(3) - 深入函数</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>lua程序设计(3) - 深入函数</h2>
<p class="meta">2013-03-09 18:04</p>

<div class="post">
<h2>lua程序设计(3) - 深入函数</h2>

<h3>by snoopyxdy</h3>

<h3>at 2013-03-09 10:04:41</h3>

<h3>original <a href="http://snoopyxdy.blog.163.com/blog/static/60117440201312564742232">http://snoopyxdy.blog.163.com/blog/static/60117440201312564742232</a></h3>

<div>1、closure闭包<div>lua也支持类似js的闭包，工作性质和工作流程也一样</div><div><br></div><div><br></div><div>1.1 可变长度参数：</div><div>printResult = ""</div><div><div>function print(...)</div><div>    for i, v in ipairs(arg) do</div><div>        printResult = printResult .. tostring(v) .. &quot;\t&quot;</div><div>    end</div></div><div><div>    printResult = printResult .. &quot;\n&quot;</div><div>end</div></div><div>数参数列表中的三点（...）表示该函数有可变数量的参数。当该函数被调用的时候，它所有的参数会被存入一个表变量，该变量是一个名为arg的隐藏变量，表中除了存储所有的参数之外，还附带一个额外的域n用来存储参数的个数。</div><div><br></div><div><div>function g(a, b, ...)</div><div>end</div><div>CALL PARAMETERS</div><div>g(3) a = 3, b = nil, arg = {n = 0}</div><div>g(3, 4) a = 3, b = 4, arg = {n = 0}</div><div>g(3, 4, 5, 8) a = 3, b = 4, arg = {5, 8; n = 2}</div></div><div><br></div><div><br></div><div>2、用变量定义函数</div><div>local fact</div><div>fact = function(n)</div><div><span style="white-space:pre">   </span>if n==0 then</div><div><span style="white-space:pre">    </span>else return n*fact(n-1)</div><div><span style="white-space:pre"> </span>end</div><div>end</div><div><br></div><div>3、尾调用</div><div>function f(x)</div><div>return g(x)</div><div>end</div><div><br></div><div>尾调用时不耗费任何栈空间，所以尾调用不会溢出</div><div>注意下面这段代码不是尾调用</div><div>function f(x)</div><div>g(x)</div><div>end</div><div><br></div><div>4、loadstring执行字符串代码，使用全局的作用域，这个函数</div><div>f = loadstring(" i = i + 1")</div><div>如果代码中有错误，loadstring会返回nil</div><div><br></div><div>5、if not n then error("invalid input") end 这段代码相当于</div><div>n = assert(io.read("*number"), "invalid input")</div><div><br></div><div>6、assert函数检查其第一个参数是否true，如果为true则返回该参数，否则引发一个错误，抛出第二个参数</div><div><br></div><div>7、pcall()用来做异常控制</div><div>pcall 会以一种保护模式来运行函数，如果没有发生错误，pcall第一个返回true，第二个及以后返回函数返回值，如果出现错误，第一个参数返回false，以后的参数返回错误信息</div><div><br></div><div>8、获得错误的堆栈信息xpcall，该函数可以打印堆栈信息</div><div><div>function f()</div><div>local x;</div><div>error('aaa')</div><div>end</div><div><br></div><div>local s= xpcall(f,function ()</div><div><span style="white-space:pre">  </span>print(debug.traceback())</div><div><span style="white-space:pre">    </span>end</div><div>)</div><div>print(s)</div></div><div><br></div><div>输出：</div><div><div>stack traceback:</div><div><span style="white-space:pre"> </span>lua1.lua:7: in function &lt;lua1.lua:6&gt;</div><div><span style="white-space:pre">  </span>[C]: in function 'error'</div><div><span style="white-space:pre">    </span>lua1.lua:3: in function &lt;lua1.lua:1&gt;</div><div><span style="white-space:pre">  </span>[C]: in function 'xpcall'</div><div><span style="white-space:pre">   </span>lua1.lua:6: in main chunk</div><div><span style="white-space:pre">   </span>[C]: ?</div><div>false</div></div><div><br></div><div>9、协同程序</div><div>协同程序就相当于不能独立运行的线程，与其他协同程序共同享有全局变量，但是同一时刻只能有一个协同程序在工作</div><div><br></div><div>10、创建一个简单的协同程序</div><div>co = coroutine.create(function () print("hi") end)</div><div>print(co)   -- thread: 0081C330</div><div><br></div><div>11、查看一个协同程序的状态</div><div>print(coroutine.status(co))   --suspended</div><div><br></div><div>12、启动或再次启动一个协同程序</div><div><span style="line-height:22px">coroutine.resume(co)</span></div><div><span style="line-height:22px">print(coroutine.status(co))   --dead</span></div><div><br></div><div>13、协同程序可以让一个程序在运行中挂起，然后等待恢复继续执行，比如下面代码：</div><div>co = coroutine.create(function()</div><div><span style="white-space:pre">  </span>for i=0,10 do</div><div><span style="white-space:pre">       </span>print("co",i)</div><div><span style="white-space:pre">       </span>coroutine.yield()</div><div><span style="white-space:pre">   </span>end</div><div><span style="white-space:pre"> </span>end</div><div>)</div><div>coroutine.resume(co)   --co  --1</div><div><span style="line-height:22px">print(coroutine.status(co))   --suspended</span></div><div><span style="line-height:22px"><br></span></div><div><span style="line-height:22px">coroutine.resume(co)   --co  -- 2</span></div><div><span style="line-height:22px">coroutine.resume(co)   --co  -- 3</span></div><div><span style="line-height:22px">coroutine.resume(co)   --co   --4</span></div><div>... ...</div><div><span style="line-height:22px">coroutine.resume(co)   --co   --10</span></div><div><span style="line-height:22px">coroutine.resume(co)   --co   --什么都不打印</span></div><div><span style="line-height:22px">print(coroutine.resume(co))   --false cannot resume dead coroutine</span></div><div><span style="line-height:22px"><br></span></div><div>14、当协同程序发生错误，lua不会显示错误消息，而是将执行权交给resume调用。</div><div><br></div><div>15、当一个协同程序A唤醒另外一个协同程序B，则A就处于一个特殊状态，正常normal</div><div><br></div><div>16、协同程序的返回值</div><div>例1：</div><div>co = coroutine.create(function(a,b)</div><div><span style="white-space:pre">    </span>coroutine.yield(a+b,a-b)</div><div><span style="white-space:pre">    </span>end</div><div>)</div><div>print(coroutine.resume(co,20,10)) -- true 30 10</div><div><br></div><div>例2：</div><div><div style="line-height:22px">co = coroutine.create(function(a,b)</div><div style="line-height:22px"><span style="line-height:22px;white-space:pre">    </span>print(&quot;co&quot;, <span style="line-height:22px">coroutine.yield()</span><span style="line-height:22px">)</span></div><div style="line-height:22px"><span style="line-height:22px;white-space:pre"> </span>end</div><div style="line-height:22px">)</div><div style="line-height:22px"><span style="line-height:22px">print(coroutine.resume(co))    -- true</span></div><div style="line-height:22px">print(coroutine.resume(co,20,10))   --true</div></div><div style="line-height:22px">返回</div><div style="line-height:22px">true</div><div style="line-height:22px">co 20 10</div><div style="line-height:22px">true</div><div style="line-height:22px"><br></div><div style="line-height:22px">例3：</div><div style="line-height:22px"><div style="line-height:22px">co = coroutine.create(function(a,b)</div><div style="line-height:22px"><span style="line-height:22px;white-space:pre"> </span>return 6, 7</div><div style="line-height:22px"><span style="white-space:pre">    </span>end</div><div style="line-height:22px">)</div></div><div><span style="line-height:22px">print(coroutine.resume(co))     -- true  6   7</span></div><div><br></div><div>17、协同程序的经典示例就是生产者-消费者，一个程序不停的生产值，另一个程序不停的消费这个值</div><br><div><br></div><div>18、协同程序的一个例子：http爬虫，可以并发的去爬内容</div><div>page 82</div></div>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
