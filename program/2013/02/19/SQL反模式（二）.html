<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>SQL反模式（二）</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>SQL反模式（二）</h2>
<p class="meta">2013-02-19 22:16</p>

<div class="post">
<h2>SQL反模式（二）</h2>

<h3>by snoopyxdy</h3>

<h3>at 2013-02-19 14:16:00</h3>

<h3>original <a href="http://snoopyxdy.blog.163.com/blog/static/601174402013118112556568">http://snoopyxdy.blog.163.com/blog/static/601174402013118112556568</a></h3>

<div><b>案例1、一对多反范式：</b><div>假设我们正在开发一个bug追踪的系统，每个bug都属于某一个产品，并且为每个产品我们设置了一个字段，存储这个产品的一个联系人。某一天需求改变了，我们需要对某一个产品支持多个联系人。</div><div>此时对数据库中原来存储的单一联系人用户标示改成用逗号分隔的方案似乎是改动最小最简单的解决方案。</div><div><br></div><div><div><img title="SQL反模式（二） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（二） - snoopyxdy - snoopyxdy的博客" style="margin:0 10px 0 0" src="http://img0.ph.126.net/Li3nXr1Xt8ZhszOe6v7DtA==/6598104407098676680.jpg"></div> </div><div><br></div><div><i>很快老板老问你，“工程部那边最多只能添加5个联系人，多了就出错，怎么回事？”</i></div><div><i>你点头说：“是的，只能在项目中加这么多人，就是这么设计，我可以帮您加到5-10人，不过这还根据用户注册的时间早晚决定，因为ID号加上逗号的总长度不能超过字符串长度的最大值。”</i><br><div><i>老板皱起了眉头，你感觉今天又要加班了。。。</i></div></div><div><i><br></i></div><div>程序员通常使用逗号分隔来避免创建关系表，这样看似性能感觉很好，但是真正在使用起来必须面临如下几个问题：</div><div>1、查询指定联系人的产品<br>在mysql中可以用如下语句：</div><div>SELECT * FROM Products WHERE account_id REGEXP &#39;[[:&lt;:]]12[[:&gt;:]]&#39;</div><div>这条语句性能是大问题，而且这条语句只适用于mysql所以无法跨平台</div><div><br></div><div>2、查询指定产品的联系人</div><div>可以使用如下sql语句进行查询</div><div>SELECT * FROM <span style="line-height:22px">Products</span><span style="line-height:22px"> AS p JOIN Accounts AS a ON p.account_id REGEXP &#39;[[:&lt;:]]&#39; || a.account_id || &#39;[[:&gt;:]]&#39; </span></div><div><span style="line-height:22px">WHERE p.product_id = 123;</span></div><div><b style="line-height:22px">mysql中使用concat()函数进行字符串连接</b></div><div>这样的语句将毁掉索引</div><div><br></div><div>3、更新指定产品的联系人</div><div>UPDATE Products SET account_id = account_id || ',' || 12</div><div>WHERE product_id = 123;</div><div>这样更新数据并不能保证顺序，当要删除其中某一个联系人时，不得不借助编程语言来实现，例如：php</div><div><br></div><div>4、其他问题</div><div>对于验证用户id无能为力，可能重复输入用户id或者无效的id。如何保证分隔符不会被联系人的id用到也是一个问题。</div><div>当然就像开始那样列表的长度是一个不得不考虑的问题，如果设置过短，就会发生只能添加5人的尴尬问题。</div><div><br></div><div>并不是完全否定使用逗号分隔存储一对多关系的反范式设计，当然如果考虑这样设计数据库表则必须谨慎在谨慎。</div><div><br></div><div>我们可以创建一张交叉表来解决这个问题</div><div><br></div><div><div><img title="SQL反模式（二） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（二） - snoopyxdy - snoopyxdy的博客" style="margin:0px 10px 0px 0px;width:500px;height:auto" src="http://img7.ph.126.net/ospA3t8wDee1RNyH32MEUQ==/6597740468750091617.jpg"></div> </div><div><div><img title="SQL反模式（二） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（二） - snoopyxdy - snoopyxdy的博客" style="margin:0px 10px 0px 0px;width:500px;height:auto" src="http://img2.ph.126.net/aDcBICDb-Q5YLaqYHay1WQ==/6597545855191976042.jpg"></div> </div><div>查询指定联系人的产品：</div><div>SELECT p.* FROM Products AS p JOIN Contacts as c ON (p.account_id = c.account_id)</div><div>WHERE c.account_id = 123;</div><div><br></div><div>更新指定产品的联系人：</div><div>INSERT INTO Contacts (product_id, account_id) VALUES (123, 56);</div><div><br></div><div>DELETE FROM Contacts WHERE product_id = 123 AND account_id = 56;</div><div><br></div><div>增加了联系表同时取消了长度的限制，而且设置了外键验证了不存在的account_id。</div><div><br></div><div><b>案例2、树</b></div><div>百度贴吧，或者网易评论都可以叠楼，就是对回复进行回复，这是很常见的一个需求，我们一般的解决方案是建立一个评论表Comments，将评论或者回复保存在里面，然后设置一个parent_id来表述他们之间的父子关系，如下图：</div><div><div><img title="SQL反模式（二） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（二） - snoopyxdy - snoopyxdy的博客" style="margin:0px 10px 0px 0px;width:500px;height:auto" src="http://img0.ph.126.net/qAAqNCo0OD2HdzI3GSpjUA==/6597712980959395340.jpg"></div> 数据库中的表如下：</div><div><div><img title="SQL反模式（二） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（二） - snoopyxdy - snoopyxdy的博客" style="margin:0 10px 0 0" src="http://img7.ph.126.net/kFMNMsp0WUXdx1BmBTUQoA==/6597379828937460057.jpg"></div> </div><div>可能我们还有一个主题的id，theme_id用来区分不同的帖子或者留言主题，这里无关紧要，我们用下图表示的更加清晰一点：</div><div><br></div><div><div><img title="SQL反模式（二） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（二） - snoopyxdy - snoopyxdy的博客" style="margin:0px 10px 0px 0px;width:500px;height:auto" src="http://img9.ph.126.net/TPDzI9-BCLq6iQH1A71r_w==/6597430406470753369.jpg"></div> </div><div>这种表设计我们称为邻接表，但是它无法完成树操作的最普通一项，无法查询一个节点的所有后台，只能使用一个关联查询知道节点的直接后台。</div><div><br></div><div>1、增加一个子节点非常方便</div><div>INSERT INTO Comments (bug_id, parent_id, author, comment) VALUES (1234,7,'kkk','thanks')</div><div><br></div><div>2、删除一个节点就比较麻烦了，执行多次来找到所有的后台节点，然后删除这些节点</div><div><br></div><div>3、删除一个叶子节点并且提升它的子节点也是比较麻烦的一件事情，必须先修改子节点的parent_id字段，然后才能删除改叶子节点，必须一些额外的代码</div><div><br></div><div>警示：不要过度设计，如果只有父子嵌套，没有深层嵌套，并且这些关系并不会频繁的变更，那么邻接表方法是很不错的选择。</div><div><br></div><div>解决方案1、使用路径枚举</div><div>邻接表的缺点之一是从树中获取一个给定节点的所有祖先开销很大，路径枚举的设计通过将所有祖先的信息联合成一个字符串，并保存为每一个节点的一个属性，巧妙的解决了这个问题。</div><div><div><img title="SQL反模式（二） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（二） - snoopyxdy - snoopyxdy的博客" style="margin:0 10px 0 0" src="http://img4.ph.126.net/JWOrwRpa8skgsq9hmVIUwQ==/6598294622610289134.jpg"></div>例如我们要找评论id为7的所有祖先，可以用如下sql：</div><div>SELECT * FROM Comments AS c WHERE ‘1/4/6/7/’ LIKE c.path || '%';</div><div>这条语句会去查找所有path为 1/4/6/% 或 1/4/% 或 1/% 的节点，这些节点都是7的祖先。</div><div><br></div><div>同样我们可以很方便的查找id为4的所有后代：</div><div>SELECT * FROM Comments AS c WHERE c.path LIKE '1/4/' || '%';</div><div>这条语句能查出 1/4/5/ 、1/4/6/ 以及 1/4/6/7/</div><div><br></div><div>我们还可以方便的计算出某一个叶子节点下的每个用户的所有评论数，这在邻接表设计是很复杂的：</div><div>SELECT COUNT(*) FROM <span style="line-height:22px"> </span><span style="line-height:22px">Comments AS c WHERE </span><span style="line-height:22px">c.path LIKE '1/4/' || '%' GROUP BY c.author;</span></div><div><span style="line-height:22px"><br></span></div><div>插入一个节点有点麻烦，需要先插入记录，然后查询处此回复的comment_id然后修改path字段</div><div>枚举方法还可以根据path字符串的分隔符数量来知道子节点的深度</div><div><br></div><div>路径枚举方法也有它的缺陷，无论将path字段设置为多大，都面临多长的风险。而且不能保证所有path上的路径都是有效，可能被误删了某一条记录</div><div><br></div><div>解决方案2、闭包表</div><div>闭包表是解决分级存储的一个简单而优雅的方案，它记录了树中所有节点间的关系，而不是仅仅的父子关系。我们不再使用comments表来保存树结构，而是使用TreePath表的一行来表示</div><div><br></div><div><div><img title="SQL反模式（二） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（二） - snoopyxdy - snoopyxdy的博客" style="margin:0px 10px 0px 0px;width:500px;height:auto" src="http://img4.ph.126.net/mWK1Om-U5kTgqNrxEbHcPQ==/6597777852145441354.jpg"></div> </div><div><div><img title="SQL反模式（二） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（二） - snoopyxdy - snoopyxdy的博客" style="margin:0 10px 0 0" src="http://img2.ph.126.net/HeW0xNN2fUs-_Wo6IBKiPQ==/6597501874726561572.jpg"></div> </div><div><br></div><div><br></div><div><span style="line-height:22px">通过treepath表来获取一个id为4的后代：</span></div><div>SELECT c.* FROM <span style="line-height:22px">Comments AS c JOIN TreePaths AS t ON c.comment_id = t.descendart WHERE t.ancestor = 4;</span></div><div><span style="line-height:22px">获取id为4的祖先</span></div><div><span style="line-height:22px">SELECT c.* FROM </span><span style="line-height:22px">Comments AS c JOIN TreePaths AS t ON c.comment_id = t.</span><span style="line-height:22px">ancestor </span><span style="line-height:22px">WHERE t.</span><span style="line-height:22px">descendart </span><span style="line-height:22px">= 4;</span></div><div><span style="line-height:22px"><br></span></div><div><span style="line-height:22px">插入一个新的叶子节点，须先插入自己到自己的关系，然后增加该节点的祖先-后代的关系，比如要删除一个叶子节点id为7的内容，需要删除所有后代id为7的记录即可。</span></div><div><span style="line-height:22px"><br></span></div><div><span style="line-height:22px">闭包表通过存储空间来减少操作过程中的冗余计算造成的消耗。</span></div><div><span style="line-height:22px"><br></span></div><div><span style="line-height:22px"><br></span></div></div>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
