<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>SQL反模式（三）</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>SQL反模式（三）</h2>
<p class="meta">2013-02-19 01:20</p>

<div class="post">
<h2>SQL反模式（三）</h2>

<h3>by snoopyxdy</h3>

<h3>at 2013-02-18 17:20:31</h3>

<h3>original <a href="http://snoopyxdy.blog.163.com/blog/static/60117440201311823734902">http://snoopyxdy.blog.163.com/blog/static/60117440201311823734902</a></h3>

<div><div><b>案例3、主键</b></div><i>最近一个程序员问我：“如何阻止表中的重复项”，一开始我认为是他的表中缺少主键，后来发现不是那样。他的内容管理数据库存储了一个网站上所发表的文章，然后他使用交叉表来存储文章和标签之间多对多的关系。</i><br><div><img title="SQL反模式（三） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（三） - snoopyxdy - snoopyxdy的博客" style="margin:0px 10px 0px 0px;width:500px;height:auto" src="http://img8.ph.126.net/NNGFt53LZYZDchqsAOhrrQ==/6597903196471013628.jpg"></div>在数据表中出现了如下的记录：<div><div><img title="SQL反模式（三） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（三） - snoopyxdy - snoopyxdy的博客" style="margin:0px 10px 0px 0px;width:500px;height:auto" src="http://img2.ph.126.net/TJ9xHiKJqIPlxc5gwT-6TQ==/6598286926028889082.jpg"></div> 所以出现了重复项</div><div><br></div><div>解决方案是对另外两列进行UNIQUE约束，但是这样，作为主键的id有些多余。</div><div><br></div><div>每个了解数据库的程序员都知道主键对于一张表来说是一个很重要的甚至必要的部分，主键是好的设计的一部分。难点是选择哪一列作为主键，大多数表中的每个属性的值都可能被很多行使用，引入一个无意义的新列作为主键这种类型的主键称为伪主键和代理键。</div><div><br></div><div>真的需要主键吗？</div><div>1、主键能确保一张表中不会出现重复行</div><div>2、在查询中应用单行的记录</div><div>3、支持外键</div><div>一个没有主键的表就好像MP3听歌，没有歌名一样，无法找到想听的歌，也无法保证歌曲不重复。</div><div><br></div><div>意义不明的关键字，我们非常习惯在数据表中添加一个名为id的字段作为自然增长的主键，但是列名id不会使查询更加清晰。如果在bug表增加bug_id或者在用户表，使用account_id事情就会变得很简单。</div><div><br></div><div>我们使用sql来join两张表的查询：</div><div>SELECT * FROM Bugs AS b JOIN BugsProducts AS bp ON (b.bug_id = bp.bug_id);</div><div>如果列名相同可以更简洁的使用using</div><div><span style="line-height:22px">SELECT * FROM Bugs JOIN BugsProducts USING (bug_id);</span></div><div><br></div><div>解决方案，使用组合主键：</div><div><div><img title="SQL反模式（三） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（三） - snoopyxdy - snoopyxdy的博客" style="margin:0px 10px 0px 0px;width:500px;height:auto" src="http://img4.ph.126.net/3xO_zM7LoW-QHPBGARR6Ig==/6597584338098945454.jpg"></div>数据库会自动将重复项帮我们屏蔽</div><div><br></div><div><br></div><div><b>案例4、引用完整性：</b></div><div>关系型数据库的设计基本上可以说就是每张独立表之间的关系设计，引用完整性是合理的数据库设计和操作的重要一部分。当一列声明了外键约束之后，这些列中的数据必须在其父表的主键或者唯一字段的列存在。</div><div><br></div><div>可能有如下几点不使用外键的原因：</div><div>1、数据更新可能和约束有冲突</div><div>2、数据库使用外键会影响性能</div><div>3、当前数据库不支持外键</div><div>4、定义外键的语法不简单，需要查阅</div><div><br></div><div>省略外键能使数据库设计更加简单灵活或者高效，但是你不得不在其他地方付出代价，必须用额外的代码来维护引用完整性。</div><div><br></div><div>每次插入数据时要确保所引用的值在对应表中是存在的，每次删除时要保证所有相关表都要及时更新。要避免没有外键约束的情况下插入一条数据就要执行一次额外的select查询，检查被引用记录是否存在。要删除时要多次查询确认没有其他记录引用了该条记录。</div><div><br></div><div>解决方案，支持同步修改：</div><div><div><img title="SQL反模式（三） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（三） - snoopyxdy - snoopyxdy的博客" style="margin:0px 10px 0px 0px;width:500px;height:auto" src="http://img9.ph.126.net/fhvKtjwDDKPYuFqeIBq6VQ==/6597537059098955519.jpg"></div> 不需要在更新或者删除前执行select检查、不需要在同步时锁住整张表，也不需要定期执行脚本来清理一些孤立的数据</div><div><br></div><div><br></div><div><br></div><div><b>案例4、取整错误：</b></div><div><i>老板要求你根据每个程序员修复每个bug所花费的时间，来计算出关于项目开发的时间成本表，每个在accounts表中的程序员都有不同的时薪，因此你统计出每个程序员花在修复每个bug上的时间，然后乘以他们的时薪。</i></div><div><i>要实现这样的功能，需要新建开销的列，精确的统计这些开销，你决定将这些定义为FLOAT。</i></div><div><i>第二天老板对你说，这些数字不正确！</i></div><div> </div><div>大多数编程语言都支持float和double，sql也是用相同的关键字支持类似的数据类型。很多程序员很自然的会在需要使用浮点数的地方使用sql的float类型。</div><div>就算我们再提高精度也不能将3个1/3的浮点数加起来达到1，只能无限接近1，比如</div><div>0.333333 + 0.333333 + 0.333333 = 0.999999</div><div><br></div><div>我们在数据库插入如下数据和表设计：</div><div><div><img title="SQL反模式（三） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（三） - snoopyxdy - snoopyxdy的博客" style="margin:0px 10px 0px 0px;width:500px;height:auto" src="http://img5.ph.126.net/5_7fRE7B_1fy0hXYfMcrkA==/6597739369238467475.jpg"></div> </div><div><div><img title="SQL反模式（三） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（三） - snoopyxdy - snoopyxdy的博客" style="margin:0px 10px 0px 0px;width:500px;height:auto" src="http://img0.ph.126.net/xDGYl_H8kgXwYT9RQWKUNw==/6598111004168445750.jpg"></div> </div><div>你会发现执行上述sql语句，什么都没有返回，我们需要在数据库设计时将精度也设置进去：</div><div><br></div><div><div><img title="SQL反模式（三） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（三） - snoopyxdy - snoopyxdy的博客" style="margin:0 10px 0 0" src="http://img4.ph.126.net/AGBjKhCBa1zMqLeEXUBEZg==/6597749264843116374.jpg"></div> </div><div>然后我们再执行sql语句：</div><div><div><img title="SQL反模式（三） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（三） - snoopyxdy - snoopyxdy的博客" style="margin:0 10px 0 0" src="http://img4.ph.126.net/gONYJdTnNwldCZQbixPSlw==/6598065924191704154.jpg"></div> </div><div>就可以查到结果了，sql server 2010 这个问题已经不存在了</div><div><br></div><div><span style="line-height:22px"><br></span></div></div>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
