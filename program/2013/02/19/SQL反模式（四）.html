<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>SQL反模式（四）</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>SQL反模式（四）</h2>
<p class="meta">19 Feb 2013</p>

<div class="post">
<h2>SQL反模式（四）</h2>

<h3>by snoopyxdy</h3>

<h3>at 2013-02-19 13:49:00</h3>

<h3>original <a href="http://snoopyxdy.blog.163.com/blog/static/601174402013119102751228">http://snoopyxdy.blog.163.com/blog/static/601174402013119102751228</a></h3>

<div><b>案例5、乱用索引</b><br>当我们通过猜测来选择索引时，不可避免的会犯一些错误，对何时使用索引的误解可能会导致如下的问题：<div>1、不适用索引或者索引不足</div><div>2、使用了太多的索引或者使用了一些无效的索引</div><div>3、执行一些让索引无能为力的查询</div><div><br></div><div>数据库在保持索引同步的时候会有额外的开销，我们每次使用INSERT、UPDATE或者DELETE时，数据库就不得不更新索引的数据结构。我们已经习惯的将额外的开销视作浪费，一些开发人员的结论是不适用索引，但是索引能够给你带来的好处是更多的。</div><div><br></div><div>CREATE TALBE Bugs(</div><div>   bug_id     SERIAL PRIMARY KEY</div><div>   date_report<span style="line-height:22px"> </span><span style="line-height:22px">   </span><span style="line-height:22px"> DATE NOT NULL</span></div><div><span style="line-height:22px">   summary</span><span style="line-height:22px"> </span><span style="line-height:22px">   </span><span style="line-height:22px"> VARCHAR(80) NOT NULL</span></div><div><span style="line-height:22px">   status</span><span style="line-height:22px"> </span><span style="line-height:22px">   </span><span style="line-height:22px"> VACHAR(10) NOT NULL</span></div><div><span style="line-height:22px">   hours</span><span style="line-height:22px"> </span><span style="line-height:22px">   </span><span style="line-height:22px"> NUMBERIC(9,2)</span></div><div><span style="line-height:22px">   INDEX(bug_id)   --1</span></div><div><span style="line-height:22px">   INDEX(summary)   --2</span></div><div><span style="line-height:22px">   INDEX(hours)   --3</span></div><div><span style="line-height:22px">   INDEX(bug_id, date_report, status)  --4</span></div><div>)</div><div>bug_id：大多数数据库都会自动为主键建立索引，一般再定义一个索引就是一个冗余操作</div><div>summary：对于长字符串，比如VARCHAR(80)这种类型的索引要比更为紧凑的数据类型大很多。同样你也不大会对长字符串进行全匹配查找。</div><div>hours：这是另外一个你不太可能按照特定值搜索的列</div><div>bug_id, date-report, status 组合索引是一个不错的选择，索引顺序也很重要</div><div><br></div><div>我们建立如下索引，然后试着使用索引：</div><div>CREATE INDEX TelephoneBook ON Accounts(last_name, first_name)</div><div>下面的这些查询都无法享受索引</div><div>1、SELECT * FROM Accounts ORDER BY first_name, last_name</div><div>我们在上面先创建了last_name再创建了first_name顺序的联合索引，所以索引帮不上忙</div><div>2、SELECT * FROM Bugs WHERE  MONTH(date_reported) = 4</div><div>即使为date_reported列创建了索引，这个索引时无法帮你按照月份查询的。</div><div>3、SELECT * FROM Bugs WHERE description LIKE ‘%crash%’</div><div>由于这个查询断言的匹配子串可能出现在该字段的任何部分，因此即使经过排序的索引结构也帮不上忙。</div><div><br></div><div>分离率是衡量数据库索引的一个重要指标，它表示一张表中所有不重复的值的数量和总记录条数之比。</div><div>SELECT COUNT(DISTINCT status) / COUNT(status) AS selectivity FROM Bugs;</div><div>分离率越低说明改列的索引效率越低。</div><div><br></div><div><b>案例6、NULL！</b></div><div>不可避免的，数据库中总会有一些字段是没有值的，不管插入一个不完整的行，还是有些列可以合法的拥有一些无效值。SQL支持一个特殊的空值，我们所熟悉的NULL。</div><div><br></div><div><br></div><div>我们如下这张表，记录了bug数和tag标签，现在我们查找tag3不为NULL的记录：</div><div><div><img title="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" style="margin:0 10px 0 0" src="http://img8.ph.126.net/mKqGRpha58K9247qry3upA==/6597996654959387218.jpg"></div>我们先运行如下程序，发现没有找到数据，于是请教了另外一位同事，同事告诉我说要给NULL增加引号就可以了，果然增加了单引号数据查询出来就正确了：</div><div><img title="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" style="margin:0 10px 0 0" src="http://img7.ph.126.net/fdMbsIypk_oUV3RLc5_sXA==/6597663502936161627.jpg"></div> <div><br><div><img title="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" style="margin:0 10px 0 0" src="http://img3.ph.126.net/3gxKlU6bJSs71z2K0Etywg==/6597785548726846813.jpg"></div><div><span style="line-height:22px"> </span></div><div><span style="line-height:22px">于是需求又来了，我们要查找tag3是NULL的数据，但是这次无论我们怎么修改sql语句都查不出来了</span></div><div><div><img title="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" style="margin:0 10px 0 0" src="http://img9.ph.126.net/Sq_OB3TY9umnS6e-TTrAFQ==/6598100009052173649.jpg"></div> <div><img title="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" style="margin:0 10px 0 0" src="http://img6.ph.126.net/_IVZr8XdXMyZolPtCIRjEQ==/6597737170215220166.jpg"></div> </div><div>下面是另外2个直接和NULL比较可能出现的错误：</div><div><br></div><div>1、SELECT hours + 10 FROM Bugs;</div><div>如果hours默认值NULL，则NULL + 10还是NULL，所以这句话程序可能会出错</div><div>2、<span style="line-height:22px">SELECT* FROM Bugs hours &lt;&gt; 10 </span></div><div>如果hours是NULL，则NULL &lt;&gt; 10 也不是true，所以程序可能漏掉某些数据</div><div><br></div><div>下面是<span style="line-height:22px"> </span><span style="line-height:22px">NULL的比较表</span></div><div><span style="line-height:22px"><br></span></div><div><img title="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" src="http://img7.ph.126.net/eOp9a4lXJ-FzIqb8ADMO0A==/6597586537122216217.jpg" style="line-height:22px;margin:0px 10px 0px 0px;width:750px;height:auto"></div><div><br></div><div><br></div><div><span style="line-height:22px">令人痛恨的NULL，</span>我痛恨NULL！</div><div>NULL会导致程序出错，<span style="line-height:22px">使用默认值就可以了，</span><span style="line-height:22px">但是无论使用何种默认值都需要程序做特殊处理。</span></div><div>我们将assigned_to和hours这一列设置为NOT NULL,</div><div><div><img title="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" style="margin:0px 10px 0px 0px;width:500px;height:auto" src="http://img3.ph.126.net/R5auEE9_uBWAJemUmMY0SA==/564075853345999323.jpg"></div>假设我们使用-1作为默认值，于是我们插入记录</div><div>INSERT TO Bugs (assigned_to, hours) VALUES(-1,-1) </div><div>但是当-1在执行SUM或者AVG的时候会导致计算结果错误，所以必须在计算时使用另外一个判断去除这些数据，这些额外的工作都是要避免使用NULL所带来的</div><div>再来看assigned_to列，这是一个指向Accounts表的外键，表示将bug指派给某某某，但是当一个bug录入进系统还没指派给任何人去处理的时候，这个非NULL的值应该是谁呢？任何一个非NULL的值都必须指向Accounts表中的一条记录，因此你不得不在accounts表中插入一条记录，表示”没有此人“或”未指派“，然后让它作为默认值，这个帐号看上去非常可笑。</div><div>当你声明一列为NOT NULL时，也就是说这一列必须有一个值，因为每个bug都是由某个人报告的，但是一个bug暂时没有指派给任何人，悬空值应该为NULL。</div><div><br></div><div><br></div><div><div style="line-height:22px">下列可能用到NULL值的情况</div><div style="line-height:22px">1、一个在职员工的离职时间，不能确定，所以只能设置为NULL</div><div style="line-height:22px">2、一辆完全靠电池驱动的汽车，他的燃油消耗就是NULL</div><div style="line-height:22px">3、在外联查询中，NULL被用来当做匹配的列的占位符</div></div><div><br></div><div><span style="line-height:22px">大多数SQL将NULL当做一个特殊值，不同于0，false或者空字符串等，其实sql有一个IS NULL断言可以帮助我们判断数据是否NULL值。</span></div><div><div><img title="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" style="margin:0 10px 0 0" src="http://img0.ph.126.net/wQxuPN8XzTP8Lyvh1w6P_A==/6597769056052438170.jpg"></div> <div><img title="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" style="margin:0 10px 0 0" src="http://img0.ph.126.net/ZdmC1tymUSdx1zHGU3jxGg==/6597694289261738050.jpg"></div> </div><div><br></div></div><div><b>案例7、表继承</b></div><div>有这样的需求，我们需要开发一个评论系统，评论有2种类型，bug和featureRequest，一个给定的评论只能是一种类型，但是我用如下代码似乎是无效的：</div><div>CREATE TABALE Comments(</div><div><span style="white-space:pre"> </span>comment_id<span style="white-space:pre"> </span>SERIAL PRIMARY KEY,</div><div><span style="white-space:pre"> </span>bug_id<span style="white-space:pre"> </span>BIGINT UNSIGNED NOT NULL,</div><div><span style="white-space:pre"> </span>author_id      BIGINT NOT NULL,</div><div><span style="white-space:pre"> </span>comment_date       DATETIME NOT NULL,</div><div><span style="white-space:pre"> </span>comment       TEXT NOT NULL,</div><div><span style="white-space:pre"> </span>FOREIGN KEY  (author_id)  REFERNCES  Accounts(account_id),</div><div><span style="white-space:pre"> </span><span style="line-height:22px">FOREIGN KEY  (issue_id)  REFERNCES  bugs(issue_id) OR FeatureRequest(issue_id)</span></div><div>)</div><div>我们不能不明确的引用外键，那么我们可以使用2个明确的外键，分别指向不同的外表，然后通过type列来区分，看上去是这样的：</div><div><div><img title="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" style="margin:0 10px 0 0" src="http://img2.ph.126.net/D-6xKG_6Q8hZeK2Mmv6OKw==/6597344644565369972.jpg"></div> </div><div>最高效的解决方法似乎可以套用面向对象中的多态和继承，我们去除issue_type这个列，这样创建4张表：</div><div><div><img title="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" style="margin:0px 10px 0px 0px;width:500px;height:auto" src="http://img3.ph.126.net/NMe18OCtuA5bu9ABXMyQgw==/6598257239214945703.jpg"></div> </div><div>各个数据表的创建语句：</div><div>CREATE TABLE Issues(</div><div><span style="white-space:pre"> </span>issue_id   SERIAL PRIMARY KEY</div><div>)</div><div><br></div><div>CREATE TABLE Bugs(</div><div><span style="white-space:pre"> </span>issue_id<span style="white-space:pre"> </span>BIGINT UNSIGNED PRIMARY KEY</div><div><span style="white-space:pre"> </span><span style="line-height:22px">FOREIGN KEY  (issue_id)  REFERNCES  Issues(issue_id)</span><span style="line-height:22px"> </span></div><div><span style="line-height:22px"><span style="white-space:pre"> </span>... //BUGS表的其他列</span></div><div>)</div><div><br></div><div><div style="line-height:22px">CREATE TABLE FeatureRequsets(</div><div style="line-height:22px"><span style="line-height:22px;white-space:pre"> </span>issue_id<span style="line-height:22px;white-space:pre"> </span>BIGINT UNSIGNED PRIMARY KEY</div><div style="line-height:22px"><span style="line-height:22px;white-space:pre"> </span><span style="line-height:22px">FOREIGN KEY  (issue_id)  REFERNCES  Issues(issue_id)</span><span style="line-height:22px"> </span></div><div style="line-height:22px"><span style="line-height:22px"><span style="line-height:22px;white-space:pre"> </span>... //Feature表的其他列</span></div><div style="line-height:22px">)</div></div><div style="line-height:22px"><br></div><div style="line-height:22px"><div style="line-height:22px">CREATE TABLE Comments(</div><div style="line-height:22px"><span style="white-space:pre"> </span>comment_id    SERIAL PRIMARY KEY,</div><div style="line-height:22px"><span style="line-height:22px;white-space:pre"> </span>issue_id<span style="line-height:22px;white-space:pre"> </span>BIGINT UNSIGNED NOT NULL,</div><div style="line-height:22px"><span style="white-space:pre"> </span>author     BIGINT UNSIGNED NOT NULL,</div><div style="line-height:22px"><span style="white-space:pre"> </span>comment_date   DATETIME,</div><div style="line-height:22px"><span style="white-space:pre"> </span>comment   TEXT,</div><div style="line-height:22px"><span style="white-space:pre"> </span><span style="line-height:22px">FOREIGN KEY  (issue_id)  REFERNCES  Issues(issue_id)</span><span style="line-height:22px"> ,</span></div><div style="line-height:22px"><span style="line-height:22px"><span style="white-space:pre"> </span></span><span style="line-height:22px">FOREIGN KEY  (author)  REFERNCES  Accounts(account_id)</span><span style="line-height:22px"> </span></div><div style="line-height:22px">)</div></div><div style="line-height:22px"><br></div><div style="line-height:22px">注意bugs和featureRequest表的主键也同时是外键，它们引用了Issues表所维护的代理主键，而不用自己创建它们，更重要的这样可以保证数据的完整性。</div><div style="line-height:22px">对于一个指定的bug，我们可以找到它的评论：</div><div style="line-height:22px"><div><img title="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" style="margin:0px 10px 0px 0px;width:auto;height:auto" src="http://img7.ph.126.net/DUcxvfVYkWR_gm7efHxr9Q==/6597664602447790307.jpg"></div>对于一个评论，我们可以查询他的bug和request属性：</div><div><img title="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" style="margin:0 10px 0 0" src="http://img1.ph.126.net/PqAHzNgtZ60jtLMyckiDmg==/6597573342982681921.jpg"></div><div style="line-height:22px"><span style="line-height:22px"> </span></div><div style="line-height:22px"><span style="line-height:22px"><br></span></div><div style="line-height:22px"><span style="line-height:22px"><b>其他警示：</b></span></div><div style="line-height:22px"><span style="line-height:22px">1、并不是素有表都必需要有id这一列的</span></div><div style="line-height:22px"><span style="line-height:22px">2、数据表的水平分区和垂直分区</span></div><div style="line-height:22px"><span style="line-height:22px">3、float类型可能带来错误</span></div><div style="line-height:22px"><span style="line-height:22px">4、使用数据库BLOB类型存储文件有时候比存在系统更靠谱</span></div><div style="line-height:22px"><span style="line-height:22px">5、切勿乱世用索引</span></div><div style="line-height:22px"><span style="line-height:22px">6、正确判断NULL值</span></div><div style="line-height:22px"><span style="line-height:22px">7、使用GROUP BY避免违反单值规则</span></div><div style="line-height:22px"><span style="line-height:22px">比如如下sql语句：</span></div><div style="line-height:22px"><div><img title="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" style="margin:0px 10px 0px 0px;width:500px;height:auto" src="http://img1.ph.126.net/EsrusFX6eZ4-rvuHb625Uw==/6597279773377565381.jpg"></div> 跟在select之后的选择列表中的每一项，对于每个分组来说都必须仅返回一个值，这就称为单值规则。MAX()表达式也能够保证每组都返回单一的值，然后下面的这段sql就违反了单值规则：</div><div style="line-height:22px"><div><img title="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" alt="SQL反模式（四） - snoopyxdy - snoopyxdy的博客" style="margin:0px 10px 0px 0px;width:500px;height:auto" src="http://img3.ph.126.net/RMk__vGX4X1mKxjLGxVAYQ==/6597999953494271553.jpg"></div> 一个给定的product_id可能有很多不同的bug_id所以数据库没办法在查询结果中表示所有的bug_id。一般数据库会在这样的sql语句抛出一个错误，但是mysql和sqlite这方面不同。在mysql中返回值是这一组第一个记录，而sqlite是最后一个，当然如果分组的product_id都是对应一样的bug_id，在mysql中我们倒是可以利用这个技巧</div><div style="line-height:22px"><span style="line-height:22px"><br></span></div><div style="line-height:22px"><span style="line-height:22px">8、高效的获取sql的随机数，避免产生性能瓶颈</span></div><div style="line-height:22px"><span style="line-height:22px">SELECT * FROM Bugs ORDER BY RAND() LIMIT 1;</span></div><div style="line-height:22px">以上这段sql是流行的获取数据库表中随即一条记录的解决方案，但是弱点也很鲜明。使用了RAND()是无法利用索引的，而且当数据库表持续增长后速度回越来越慢。</div><div style="line-height:22px">如果是连续的，我们可以利用程序来生成随机数</div><div style="line-height:22px">也可以先count数据库长度，然后使用偏移量来获取随机值</div><div style="line-height:22px"><br></div><div style="line-height:22px">9、全文检索尽量不要使用like，用第三方库解决</div><div style="line-height:22px">10、不要老是想着用一个sql语句做所有事情，有时候分几步反而更高效简单</div><div style="line-height:22px">11、不要使用select * from db，通配符*可能会隐藏很多bug和潜在的错误，而且对于网络传输也存在浪费</div><div style="line-height:22px">12、一般不要明文保存用户名密码在数据库中</div><div style="line-height:22px">13、注意sql注入，记住一点，让用户输入内容，别让用户输入代码</div><div style="line-height:22px">14、不要有伪键洁癖，因为有时候自然增长的主键可能就是有断档的</div><div style="line-height:22px"><br></div><div style="line-height:22px">结束了~</div><div style="line-height:22px"><br></div></div>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
