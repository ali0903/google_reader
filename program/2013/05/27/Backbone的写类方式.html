<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Backbone的写类方式</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>Backbone的写类方式</h2>
<p class="meta">27 May 2013</p>

<div class="post">
<h2>Backbone的写类方式</h2>

<h3>by snandy</h3>

<h3>at 2013-05-27 08:01:00</h3>

<h3>original <a href="http://www.cnblogs.com/snandy/archive/2013/05/27/3097429.html">http://www.cnblogs.com/snandy/archive/2013/05/27/3097429.html</a></h3>

<p>从两个角度去讨论Backbone的写类方式</p>


<p><br><ol style="margin-left:0"><br><li>Backbone内部的写类方式，Backbone自身的类如Model、Collection、View等是如何定义的</li><br><li>Backbone外部的写类方式，如何使用Backbone提供的类来定义自己的类</li><br></ol><br><p> </p><br><h3><a name="inner"></a>一、Backbone内部的写类方式</h3><br><p>Backbone提供给客户端程序员的类都是通过 <a href="http://www.cnblogs.com/snandy/archive/2011/03/06/1971764.html#combination">构造函数+原型</a> 的方式写的，Backbone.Model的代码大致如下</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>// 定义构造器<br>var Model = Backbone.Model = function(attributes, options) {<br>    // ...<br>    this.set(attrs, options);<br>    this.changed = {};<br>    this.initialize.apply(this, arguments);<br>};<br><br>// 扩展原型，往原型上添加了很多方法，如Events<br><em>.extend(Model.prototype, Events, {<br>    // ...<br>});<br></pre><br></div><br><p>这种写法很传统，Backbone.Collection / Backbone.View / Backbone.Router / Backbone.History 都是通过这种方式定义的。</p><br><p> </p><br><h3><a name="outer"></a>二、Backbone的外部写类方式</h3><br><p>说外部的写类方式，不得不提 extend 方法，该方法定义在Backbone.js的底部。不到30行代码，它是私有的，外部并不能访问。<br>也就是说，这个方法只在Backbone内部使用，为其它模块服务。</p><br><p> </p><br><p>其实这个说法不严谨，虽然extend不能直接访问，但它通过仅一行代码</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;<br></pre><br></div><br><p><br>转身变为以下方法</p><br><ul style="margin-left:0"><br><li>Backbone.Model.extend</li><br><li>Backbone.Collection.extend</li><br><li>Backbone.View.extend</li><br><li>Backbone.Router.extend</li><br><li>Backbone.History.extend</li><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></ul><br><p>这时，外部还是可以访问得到。</p><br><p> </p><br><p>在一个闭包内，写一个私有的函数，然后把该函数赋值给多个类或类原型。这些写法并不少见，这样写节省了内存，函数实例其实只有一份。</p><br><p>此外，不要把这里的extend 和 <a href="http://documentcloud.github.io/underscore/#extend"></em>.extend</a> 搞混了。<em>.extend是underscore提供的较底层的方法，用来<a href="http://www.cnblogs.com/snandy/archive/2013/05/24/3086663.html">Mixin对象</a>。这里的extend则是用来写类。</p><br><p> </p><br><p>介绍下extend</p><br><ol style="margin-left:0"><br><li>它接受两个参数，都是对象类型</li><br><li>它返回一个类（构造器，函数），怎么叫都行</li><br><li>第一个参数的所有属性、方法都会拷贝到类的原型上（实例对象上）</li><br><li>第二个参数的所有属性、方法都会拷贝的类上（类静态属性、方法）</li><br><li>第一个参数中如果有constructor属性，那么最后就返回它，否则返回内部提供的child</li><br><li>返回的类有个特殊属性 <strong>super</strong>。</li><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></ol><br><p>上面的第六点，使用它很方便的取得父类原型，进而取到父类构造器，进而<a href="http://www.cnblogs.com/snandy/archive/2011/03/23/1992080.html">在子类中去调用父类</a>，这类似于Java里的super关键字。</p><br><p> </p><br><p>拿示例详细说说</p><br><p>1. 两个参数，都是对象类型，第一个扩展为原型方法，第二个扩展为类方法</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>var instanceObj = {<br>name: '',<br>getName: function() {},<br>setName: function(name) {}<br>}<br>var classObj = {<br>trim: function(str) {},<br>mix: function() {}<br>}<br><br>// 生成一个新类CustomModel，它具有Backbone.Model的所有方法<br>var CustomModel = Backbone.Model.extend(instanceObj, classObj)<br><br>// instanceObj属性都拷贝到了CustomModel.prototype 上<br></em>.each(['name','getName', 'setName'], function(attr) {<br>console.log(attr in CustomModel.prototype)<br>})<br><br>// classObj属性都拷贝到了 CustomModel 上<br>_.each(['trim','mix'], function(attr) {<br>console.log(attr in CustomModel)<br>})<br></pre><br></div><br><p> </p><br><p>2. 参数中如果有constructor属性，那么最后就返回它，否则返回内部提供的child</p><br><p>这实际上告诉使用者可以自定义构造器，而不使用内部的child。</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>function MyConstructor(name, age) {<br>this.name = name;<br>this.age  = age;<br>}<br>var CustomModel = Backbone.Model.extend({<br>constructor: MyConstructor,<br>getName: function(){},<br>setName: function(){}<br>})<br><br>var m1 = new CustomModel('John', 30)<br>console.log(m1.constructor === MyConstructor) // true<br></pre><br></div><br><p> </p><br><p>3. 返回的类有个特殊属性 <strong>super</strong>，用它很方便的取得父类原型，进而取到父类构造器，最后<a href="http://www.cnblogs.com/snandy/archive/2011/03/23/1992080.html">在子类中去调用父类</a>。</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>function Person(name, age) {<br>this.name = name<br>this.age = age<br>}<br>Person.extend = Backbone.Model.extend // 把Backbone的extend拿出来用，O(∩_∩)O~<br><br>function ManConstructor(name, age) {<br>ManConstructor.<strong>super</strong>.constructor.call(this, name, age) // 调用父类构造器<br>this.gender = 'male'<br>}<br>var Man = Person.extend({<br>constructor: ManConstructor<br>})<br>var man = new Man('John', 30)<br>console.log(man) // ManConstructor { name="John", age=30, gender="male"}<br></pre><br></div><br><p> </p><br><p>总结下Backbone的写类方式</p><br><p>Backbone内部的写类方式是 构造函数+原型。外部写类则是通过extend，写类和继承同时存在。</p><br><p>1. 通过Model(View/Router等)的extend方法写类，产生的类直接继承了Model(View/Router等)<br>2. 如果写的类不是Backbone提供的类，那么可以象3那样，把extend方法拿出来</p><br><p> </p><br><p>使用Backbone开发，多数时候都采用方式1，它强制要求把代码分为了几层，一些实用工具函数由underscore提供。</p><br><p>如果是浏览器端开发，DOM及HTTP通讯操作一般由jQuery或zepto等提供。你写的代码几乎都集中在业务处理，无非就是模型(Model)、集合(Collection)、视图(View)、路由(Router)、历史管理(History)。</p><br><p> </p><br><p> </p><br><p>相关：</p><br><p><a href="http://www.cnblogs.com/snandy/archive/2011/03/06/1971764.html">JavaScript的写类方式</a></p><br><p><a href="http://www.cnblogs.com/snandy/archive/2011/03/09/1977804.html">JavaScript的继承方式</a></p><br><p> </p><img src="http://www.cnblogs.com/snandy/aggbug/3097429.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/snandy/archive/2013/05/27/3097429.html">本文链接</a></p></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
