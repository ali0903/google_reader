<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>浅析node的buffer模块（二写入）</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>浅析node的buffer模块（二写入）</h2>
<p class="meta">2013-05-08 18:48</p>

<div class="post">
<h2>浅析node的buffer模块（二写入）</h2>

<h3>by snoopyxdy</h3>

<h3>at 2013-05-08 10:48:20</h3>

<h3>original <a href="http://snoopyxdy.blog.163.com/blog/static/6011744020134731114493">http://snoopyxdy.blog.163.com/blog/static/6011744020134731114493</a></h3>

<div>好久没更新博客了，本文继续上篇介绍nodejs的buffer类的写入和操作机制。<div>相关buffer类的写入和操作方法大致有如下几个：</div><div><div><pre><p></p><div><span style="line-height:22px">Class Method: Buffer.concat(list, [totalLength])</span></div><div><span style="line-height:22px;font-family:Arial,Helvetica,sans-serif;white-space:normal"><span style="line-height:22px;font-family:monospace;white-space:pre">new Buffer(str, [encoding])</span></span></div><div><span style="line-height:22px">buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])</span></div><div><span style="line-height:22px">buf.write(string, [offset], [length], [encoding])</span></div><div><span style="line-height:22px">buf.fill(value, [offset], [end])</span></div><div><span style="line-height:22px">还有各种wrtieInt16等方法</span></div><p></p></pre></div><div><b><span style="line-height:22px">1、</span><span style="line-height:22px;font-family:monospace;white-space:pre">Class Method: Buffer.concat(list, [totalLength])</span></b></div><div><span style="line-height:22px;font-family:monospace;white-space:pre">源码在lib/buffer.js#473行（node v0.10.4）</span></div><div><span style="line-height:22px;font-family:monospace;white-space:pre">大致工作流程：</span></div><div><span style="line-height:22px;font-family:monospace;white-space:pre">1.判断list参数是否是数组</span></div><div><span style="line-height:22px;font-family:monospace;white-space:pre">2.判断list数组的长度，如果是0则返回空buffer，如果是1则直接返回list的一个内容，这里要保证list中保存的数据类型都是buffer实例</span></div><div><span style="line-height:22px;font-family:monospace;white-space:pre">3.如果</span><span style="line-height:22px;font-family:monospace;white-space:pre">totalLength参数不是数字，则循环list数组将list数组中的每项的字符长度加起来，所以api上说如果提供了正确的</span><span style="font-family:monospace;line-height:22px;white-space:pre">totalLength</span><span style="line-height:22px;font-family:monospace;white-space:pre">将会加快concat的速度</span></div><div><span style="line-height:22px;font-family:monospace;white-space:pre">4.得到</span><span style="line-height:22px;font-family:monospace;white-space:pre">totalLength之后，创建一个临时的buffer实例，大小为</span><span style="line-height:22px;font-family:monospace;white-space:pre">totalLength。</span></div><div><span style="line-height:22px;font-family:monospace;white-space:pre">5.循环遍历list数组，调用list数组中成员的copy方法，将内容拷贝到目标临时buffer中去，然后记录位置，下次循环从记录的那个位置开始拷贝</span></div><div><span style="line-height:22px;font-family:monospace;white-space:pre">6.最后返回这个临时buffer的引用</span></div><div><br></div><div><br></div><div><b><font face="monospace"><span style="white-space:pre">2、</span></font><span style="line-height:22px;font-family:monospace;white-space:pre">new Buffer(str, [encoding])</span></b></div><div><span style="line-height:22px">当我们创建一个string的buffer实例时，将会去写入字符串，我们看下代码：</span></div><div><pre><p></p><div>if (type === 'string') {</div><div>        // We are a string</div><div>        this.length = this.write(subject, 0, encoding);</div><div>      // if subject is buffer then use built-in copy method</div><div>      } </div><p></p></pre></div><div><span style="line-height:22px">subject参数表示的就是传入的参数string，调用的是buffer实例的write方法</span></div><div><span style="line-height:22px"><br></span></div><div><span style="line-height:22px"><br></span></div><div><b><span style="line-height:22px">3、</span><span style="line-height:22px;font-family:monospace;white-space:pre">buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])</span></b></div><div>buffer实例的copy方法代码如下：</div><div><pre><p>// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)<br>Buffer.prototype.copy = function(target, target_start, start, end) {<br>  // set undefined/NaN or out of bounds values equal to their default</p><p>  //各种参数的合理化<br>  if (!(target_start &gt;= 0)) target_start = 0;<br>  if (!(start &gt;= 0)) start = 0;<br>  if (!(end &lt; this.length)) end = this.length;<br><br>  // Copy 0 bytes; we're done<br>  if (end === start ||  //如果源的开始 等于 源的结束 <br>      target.length === 0 || //如果目标的buffer大小为0，<br>      this.length === 0 ||  //如果源的大小为0，<br>      start &gt; this.length) //如果源开始的位置大于源的buffer大小<br>    return 0; //<span style="line-height:22px">即拷贝0，则返回0</span><br><br>  if (end &lt; start)//如果源的起始位置大于结束位置<br>    throw new RangeError(&#39;sourceEnd &lt; sourceStart&#39;);<br><br>  if (target_start &gt;= target.length) //如果目标的其实拷贝位置大于目标的大小<br>    throw new RangeError('targetStart out of bounds');<br><br>  if (target.length - target_start &lt; end - start) //如果目标的剩余大小小于要拷贝入的大小<br>    end = target.length - target_start + start; //调整end的位置</p><p><br>  return this.parent.copy(target.parent || target, //最后调用buffer实例的parent的copy方法来进行拷贝，这里的parent属性就对应着slowbuffer对象，所以这个copy方法也是对应它的<br>                          target_start + (target.offset || 0),<br>                          start + this.offset,<br>                          end + this.offset);<br>};</p></pre>我们看一下node_buffer.cc中是如何实现copy操作的：</div><div><pre><div><div>// var bytesCopied = buffer.copy(target, targetStart, sourceStart, sourceEnd);</div><div>Handle&lt;Value&gt; Buffer::Copy(const Arguments &amp;args) {</div><div>  HandleScope scope;</div><div><br></div><div>  Buffer *source = ObjectWrap::Unwrap&lt;Buffer&gt;(args.This()); //将buffer实例解除对象的包装</div><div><br></div><div>  if (!Buffer::HasInstance(args[0])) { //检查第一个参数是否是Buffer类的实例</div><div>    return ThrowTypeError(&quot;First arg should be a Buffer&quot;);</div><div>  }</div><div><br></div><div>  Local&lt;Value&gt; target = args[0];</div><div>  char* target_data = Buffer::Data(target); //根据inline的两个 <span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">Buffer::Data 获得源的内容</span></div><div>  size_t target_length = Buffer::Length(target);  //根据inline的两个Buffer::Length函数得到目标buffer的大小</div><div>  size_t target_start = args[1]-&gt;IsUndefined() ? 0 : args[1]-&gt;Uint32Value(); //获得目标buffer写入位置</div><div>  size_t source_start = args[2]-&gt;IsUndefined() ? 0 : args[2]-&gt;Uint32Value(); //获得读取其实位置</div><div>  size_t source_end = args[3]-&gt;IsUndefined() ? source-&gt;length_  //获得源的读取结束位置</div><div>                                              : args[3]-&gt;Uint32Value();</div><div><br></div><div>  if (source_end &lt; source_start) { //和buffer.js一样进行合法性验证，不多解释，下同</div><div>    return ThrowRangeError(&quot;sourceEnd &lt; sourceStart&quot;);</div><div>  }</div><div><br></div><div>  // Copy 0 bytes; we&#39;re done</div><div>  if (source_end == source_start) {</div><div>    return scope.Close(Integer::New(0));</div><div>  }</div><div><br></div><div>  if (target_start &gt;= target_length) {</div><div>    return ThrowRangeError(&quot;targetStart out of bounds&quot;);</div><div>  }</div><div><br></div><div>  if (source_start &gt;= source-&gt;length_) {</div><div>    return ThrowRangeError(&quot;sourceStart out of bounds&quot;);</div><div>  }</div><div><br></div><div>  if (source_end &gt; source-&gt;length_) {</div><div>    return ThrowRangeError(&quot;sourceEnd out of bounds&quot;);</div><div>  }</div><div>  </div><div>  <span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">//执行两次MIN方法，第一次返回源的开始到结束的空间 和 目标的开始到结束的空间的 想比较小的数值</span></div><div><span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">   //第二次比较上述的值和源的长度到起始值的值的较小值，保证将拷贝的数值安全值</span></div><div>  size_t to_copy = MIN(MIN(source_end - source_start, </div><div>                           target_length - target_start),</div><div>                           source-&gt;length_ - source_start);</div><div><br></div><div>  // need to use slightly slower memmove is the ranges might overlap</div><div>  //需要使用稍微慢的memove，因为返回可能重叠</div><div>  memmove((void *)(target_data + target_start), //传入指向目标buffer的开始位置之后的指针</div><div>          (const void*)(source-&gt;data_ + source_start), //传入指向源的开始位置之后的指针</div><div>          to_copy); //传入需要拷贝的长度</div><div><br></div><div>  return scope.Close(Integer::New(to_copy)); //最后返回整形的拷贝了多少长度</div><div>}</div></div><div></div><p></p></pre></div><div>注：strcpy只能处理字符串；如果拷贝带有特殊字符的串，就只能用memcpy或memmove。memcpy和memmove功能基本上差不多，但是当源串和目标串有Overlap时，memmove可以正确处理，memcpy则不行，声明如下：</div><div><div><pre><p></p><div><div>void *memcpy(void *dst, const void *src, size_t count);</div><div>void *memmove(void *dst, const void *src, size_t count);</div></div><div></div><p></p></pre></div></div><div>它们都是从src所指向的内存中复制count个字节到dst所指内存中，并返回dst的值。</div><div><br></div><div><b>4、<span style="line-height:22px;font-family:monospace;white-space:pre">buf.write(string, [offset], [length], [encoding])</span></b></div><div>这个方法是写入字符串的方法，代码如下：</div><div><pre><p>// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')<br>Buffer.prototype.write = function(string, offset, length, encoding) {<br>  // Support both (string, offset, length, encoding)<br>  // and the legacy (string, encoding, offset, length)</p><p>  //对参数的各种支持<br>  if (isFinite(offset)) { //如果偏移位置不是数字<br>    if (!isFinite(length)) { //写入buffer的长度如果是数字<br>      encoding = length; //则将参数encoding编码改为长度<br>      length = undefined; //将参数length改为未定义<br>    }<br>  } else {  // legacy<br>    var swap = encoding;<br>    encoding = offset;<br>    offset = length;<br>    length = swap;<br>  }<br><br>  offset = +offset || 0; //初始化offset<br>  var remaining = this.length - offset; <br>  if (!length) {<br>    length = remaining;<br>  } else {<br>    length = +length;<br>    if (length &gt; remaining) {<br>      length = remaining;<br>    }<br>  }<br>  encoding = String(encoding || 'utf8').toLowerCase();</p><p>var ret;<br>  switch (encoding) {<br>    case 'hex':<br>      ret = this.parent.hexWrite(string, this.offset + offset, length);<br>      break;<br><br>    case 'utf8':<br>    case 'utf-8':<br>      ret = this.parent.utf8Write(string, this.offset + offset, length); //如果是utf-8则调用utf-8的接口<br>      break;<br><br>    case 'ascii':<br>      ret = this.parent.asciiWrite(string, this.offset + offset, length);<br>      break;<br><br>    case 'binary':<br>      ret = this.parent.binaryWrite(string, this.offset + offset, length);<br>      break;<br><br>    case 'base64':<br>      // Warning: maxLength not taken into account in base64Write<br>      ret = this.parent.base64Write(string, this.offset + offset, length);<br>      break;<br><br>    case 'ucs2':<br>    case 'ucs-2':<br>    case 'utf16le':<br>    case 'utf-16le':<br>      ret = this.parent.ucs2Write(string, this.offset + offset, length);<br>      break;<br><br>    default:<br>      throw new TypeError('Unknown encoding: ' + encoding);<br>  }<br><br>  Buffer._charsWritten = SlowBuffer._charsWritten; //同步记录多少字符被写入了<br><br>  return ret;</p><p>};</p></pre><span style="font-family:monospace;line-height:22px;white-space:pre">utf8Write的代码如下，其实其他write代码都大同小异的</span></div><div><pre><p></p><div>// var charsWritten = buffer.utf8Write(string, offset, [maxLength]);</div><div>Handle&lt;Value&gt; Buffer::Utf8Write(const Arguments &amp;args) {</div><div>  HandleScope scope;</div><div>  Buffer *buffer = ObjectWrap::Unwrap&lt;Buffer&gt;(args.This());</div><div><br></div><div>  if (!args[0]-&gt;IsString()) { //有效性检查</div><div>    return ThrowException(Exception::TypeError(String::New(</div><div>            &quot;Argument must be a string&quot;)));</div><div>  }</div><div><br></div><div>  Local&lt;String&gt; s = args[0]-&gt;ToString();</div><div><br></div><div>  size_t offset = args[1]-&gt;Uint32Value();</div><div><br></div><div>  int length = s-&gt;Length();</div><div><br></div><div>  if (length == 0) {</div><div>    constructor_template-&gt;GetFunction()-&gt;Set(chars_written_sym,</div><div>                                             Integer::New(0)); //将写入的字符数设置为0</div><div>    return scope.Close(Integer::New(0)); //返回0</div><div>  }</div><div><br></div><div>  if (length &gt; 0 &amp;&amp; offset &gt;= buffer-&gt;length_) { //如果偏移大于等于整个buffer的长度则抛出错误</div><div>    return ThrowTypeError(&quot;Offset is out of bounds&quot;);</div><div>  }</div><div><br></div><div>  size_t max_length = args[2]-&gt;IsUndefined() ? buffer-&gt;length_ - offset</div><div>                                             : args[2]-&gt;Uint32Value(); //设置最大写入字符大小</div><div>  max_length = MIN(buffer-&gt;length_ - offset, max_length); //取 写入buffer的剩余值 和 用户传入的maxlength的小的一个值</div><div><br></div><div>  char* p = buffer-&gt;data_ + offset;//将指针偏移到写入的位置</div><div><br></div><div>  int char_written;</div><div><br></div><div>  <span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">//调用V8的writeUTF-8写入buffer的接口，返回写入的字符大小</span><span style="line-height:22px;font-family:Arial,Helvetica,sans-serif"> </span></div><div>  //V8EXPORT int WriteUtf8 (char *buffer, int length=-1, int *nchars_ref=NULL, int options=NO_OPTIONS) const</div><div>  int written = s-&gt;WriteUtf8(p, </div><div>                             max_length,</div><div>                             &amp;char_written,</div><div>                             (String::HINT_MANY_WRITES_EXPECTED |</div><div>                              String::NO_NULL_TERMINATION));</div><div><br></div><div>  constructor_template-&gt;GetFunction()-&gt;Set(chars_written_sym,</div><div>                                           Integer::New(char_written));</div><div><br></div><div>  return scope.Close(Integer::New(written)); //返回写入的字符数</div><div>}</div><p></p></pre></div><div><br></div><div><b>5、<span style="line-height:22px;font-family:monospace;white-space:pre">buf.fill(value, [offset], [end])</span></b></div><div>向buffer中填充value，和write有点像，不过区别是fill会将整个范围填入相同的内容，会是value字符串的第一个字符的Unicode 编码。</div><div><pre><p>// fill(value, start=0, end=buffer.length)<br>Buffer.prototype.fill = function fill(value, start, end) {<br>//初始化参数</p><p>  value || (value = 0);<br>  start || (start = 0);<br>  end || (end = this.length); </p><p><br>//校验字符串有效性<br>  if (typeof value === 'string') {<br>    value = value.charCodeAt(0); //获取字符串第一个Unicode 编码<br>  }</p><p><br></p><p>//下面各种合法性检查<br>  if (typeof value !== 'number' || isNaN(value)) { <br>    throw new TypeError('value is not a number');<br>  }<br><br>  if (end &lt; start) throw new RangeError(&#39;end &lt; start&#39;);<br><br>  // Fill 0 bytes; we're done<br>  if (end === start) return 0;<br>  if (this.length == 0) return 0;<br><br>  if (start &lt; 0 || start &gt;= this.length) {<br>    throw new RangeError('start out of bounds');<br>  }<br><br>  if (end &lt; 0 || end &gt; this.length) {<br>    throw new RangeError('end out of bounds');<br>  }<br><br>  //调用slowerbuffer的fill方法，传入参数</p><p>  //这里的offset还记得吗？就是当前buffer如果共享则会记录offset共享内存的便宜量<br>  return this.parent.fill(value,<br>                          start + this.offset,<br>                          end + this.offset);<br>};</p></pre>最后我们看下Buffer::fill方法：</div><div><br><pre><p>// buffer.fill(value, start, end);<br>Handle&lt;Value&gt; Buffer::Fill(const Arguments &amp;args) {<br>  HandleScope scope;</p><p><br><span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">  //参数检查</span></p><p>  if (!args[0]-&gt;IsInt32()) {<br>    return ThrowException(Exception::Error(String::New(<br>            "value is not a number")));<br>  }<br>  int value = (char)args[0]-&gt;Int32Value();<br><br>  Buffer *parent = ObjectWrap::Unwrap&lt;Buffer&gt;(args.This());</p><p>  //合法性检查<br>  SLICE_ARGS(args[1], args[2])<br> </p><p>  //memset:作用是在一段内存块中填充某个给定的值，它对较大的结构体或数组进行清零操作的一种最快方法。</p><p>  //void *memset(void *s,  int c, size_t n);<br>  memset( (void*)(parent-&gt;data_ + start),<br>          value,<br>          end - start);<br><br>  return Undefined();<br>}<br></p><div><br></div></pre><br></div><div><b>6、总结</b></div><div>其实node的buffer写入主要是用char * 指针来完成的，我们在使用这些接口时要注意一下小问题：</div><div>1、Buffer.concat，第二个参数totallength是所有list数组中的buffer实例的大小总和，不是list的长度</div><div>2、最快刷新清零一块buffer的方法是buffer.fill()</div><div>其他好像没什么要注意的了，api接口做的很完善了</div><div>最后一篇buffer的读取稍后献上</div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div><br></div></div>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
