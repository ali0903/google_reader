<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>掺合模式（Mixin）</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>掺合模式（Mixin）</h2>
<p class="meta">2013-05-25 01:41</p>

<div class="post">
<h2>掺合模式（Mixin）</h2>

<h3>by snandy</h3>

<h3>at 2013-05-24 17:41:00</h3>

<h3>original <a href="http://www.cnblogs.com/snandy/archive/2013/05/24/3086663.html">http://www.cnblogs.com/snandy/archive/2013/05/24/3086663.html</a></h3>

<p>Mixin是JavaScript中用的最普遍的模式，几乎所有流行类库都会有Mixin的实现。</p>


<p><br><p>Mixin是掺合，混合，糅合的意思，即可以就任意一个对象的全部或部分属性拷贝到另一个对象上。</p><br><p>从提供的接口来看，有的是对对象的操作，有的是对类的操作。对类的操作又称为掺元类（Mixin classes）</p><br><p> </p><br><h2>一、掺合对象 (Mixin object)</h2><br><p>先看最简单的mixin实现</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>function mixin(dest, src) {<br>for (var key in src) {<br>dest[key] = src[key]<br>}<br>}<br></pre><br></div><br><p>使用下</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>var person = {name: 'John', age: 29}<br>var obj = {}<br>mixin(obj, person)<br>console.log(obj) // {name: 'John', age: 29}<br></pre><br></div><br><p>可看到，已经将person的所有属性拷贝到obj上了。 有个缺点，如果obj上已经有了name: 'Jack'，那么会被person覆盖。因此需要加个判断，如果dest上已经存在了，就不拷贝。</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>function mixin(dest, src) {<br>for (var key in src) {<br>if (!dest[key]) {<br>dest[key] = src[key]<br>}<br>}<br>}<br>var person = {name: 'John', age: 29}<br>var obj = {name: 'Jack'}<br>mixin(obj, person)<br>console.log(obj) // Object { name="Jack", age=29}<br></pre><br></div><br><p> </p><br><p>当然，你可以提供更强大，灵活的Mixin，比如可以将任意多个对象掺合到目标对象</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>function mixin(dest /<em>, Any number of objects </em>/) {<br>var sources = Array.prototype.slice.call(arguments, 1)<br>for (var i=0; i&lt;sources.length; i++) {<br>var src = sources[i]<br>for (var key in src) {<br>if (!dest[key]) {<br>dest[key] = src[key]<br>}<br>}<br>}<br>}<br>var person = {name: 'John', age: 29, toString: function(){return 'aa'}}<br>var permission = {open: 1}<br>var obj = {name: 'Jack'}<br>mixin(obj, person, permission)<br>console.log(obj) // Object { name="Jack", age=29, open=1}<br></pre><br></div><br><p> </p><br><p>以下类库都是对对象的掺合</p><br><ul style="margin-left:0"><br><li>jQuery的<a href="http://www.cnblogs.com/snandy/archive/2011/06/03/2070483.html">$.extend</a> 操作对象，将其它对象的属性方法拷贝到目标对象。</li><br><li>RequireJS的私有的mixin 操作对象，将其它对象的属性方法拷贝到目标对象。</li><br><li>ExtJS的<a href="http://www.cnblogs.com/snandy/archive/2012/04/23/2461256.html">Ext.apply</a> 也是操作对象，它还提供了一个defaults参数。</li><br><li>Underscore.js 的 <a href="http://documentcloud.github.io/underscore/#extend"><em>.extend</a>，把第二个参数起的所有对象都拷贝到第一个参数</li><br></ul><br><p> </p><br><h2>二、掺和类（Mixin Classes）</h2><br><p>有的翻译过来叫做掺元类，它是一种不需要用到严格的继承就可以复用代码的一种技术。如果多个类想用到某个类的某个方法，可以通过扩充这些类的原型已达到共享该方法。比如先创建一个包含各种通用方法的类，然后让其它类扩充于它。这个包含通用方法的类就叫掺元类。多数时候它不会直接实例化或调用，而是作为其它类的模板用于扩充。</p><br><p>先看最简单的实现</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>// 工具方法，实现mixin<br>function augment(destClass, srcClass) {<br>var destProto = destClass.prototype<br>var srcProto  = srcClass.prototype<br>for (var method in srcProto) {<br>if (!destProto[method]) {<br>destProto[method] = srcProto[method]<br>}<br>}<br>}<br><br>function Person() {} // 具有两个方法的类，用于mixin<br>Person.prototype.getName = function() {}<br>Person.prototype.getAge  = function() {}<br><br>function Student() {} // 没有任何方法的类<br><br>augment(Student, Person) // 调用，拷贝<br><br>var s1 = new Student()<br>console.log(s1) // Student { getName=function(), getAge=function()}<br></pre><br></div><br><p>工具函数augment接受两个参数，都是函数类型（类），第一个类会从第二个类的原型上继承其方法。即使用Person类扩充了Student类。</p><br><p>我们知道，某些语言如C++/Python允许子类继承多个父类，但在JavaScript中是不允许的，因为一个构造器只有一个原型对象，不过这可以通过多个掺元类的方式实现扩充，这实际是一种变相多继承的实现。和mixin方法类似，修改下augment方法。</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>function augment(destClass, /<em>, Any number of classes </em>/) {<br>var classes = Array.prototype.slice.call(arguments, 1)<br>for (var i=0; i&lt;classes.length; i++) {<br>var srcClass = classes[i]<br>var srcProto  = srcClass.prototype<br>var destProto = destClass.prototype<br>for (var method in srcProto) {<br>if (!destProto[method]) {<br>destProto[method] = srcProto[method]<br>}<br>}<br>}<br>}<br></pre><br></div><br><p>这样就实现了多继承。</p><br><p> </p><br><p>有时不想继承所有的方法，指向拷贝指定的方法，增加一个参数methods</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>function augment(destClass, srcClass, methods) {<br>var srcProto  = srcClass.prototype<br>var destProto = destClass.prototype<br>for (var i=0; i&lt;methods.length; i++) {<br>var method = methods[i]<br>if (!destProto[method]) {<br>destProto[method] = srcProto[method]<br>}<br>}<br>}<br>function Person() {}<br>Person.prototype.getName = function() {}<br>Person.prototype.setName  = function() {}<br>Person.prototype.getAge  = function() {}<br>Person.prototype.setAge  = function() {}<br><br>function Student() {}<br><br>augment(Student, Person, ['getName', 'setName'])<br>var s1 = new Student()<br>console.log(s1) // Student { getName=function(), setName=function()}<br></pre><br></div><br><p> </p><br><p>Backbone是广泛使用掺元类的库</p><br><p>首先，Backbone库自身就采用Mixin classes方式组织，如Backbone.Events是最底层的掺元类，它的方法（on/off/trigger...）都被Backbone.Model/Backbone.Collection/Backbone.View等继承。代码片段如下</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre></em>.extend(Model.prototype, Events, {<br>...<br>})<br><em>.extend(Collection.prototype, Events, {<br>...<br>})<br></em>.extend(View.prototype, Events, {<br>...<br>})<br></pre><br></div><br><p>它这里使用<em>.extend来扩充Model，Collection，View的原型，把Events的方法都拷贝到原型。即Event就是一个掺元类(虽然被实现为一个对象)</p><br><p> </p><br><p>其次，我们使用Backbone开发时，你写的模型会用Backbone.Model去扩充，视图会用Backbone.View去扩充。如</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>var MyModel = Backbone.Model.extend({<br>instanceProp: xx<br>},{<br>classProp: yy<br>})<br><br>var MyView = Backbone.Model.extend({<br>instanceProp: xx<br>},{<br>classProp: yy<br>})<br></pre><br></div><br><p>这时，Backbone.Model/Backbone.View等就是掺元类了。当然，你还可以把underscore当做掺元对象，因为Backbone的很多类都继承了</em>.extend方法，如Backbone.Events/Backbone.Model等。</p><br><p> </p><br><p> </p><img src="http://www.cnblogs.com/snandy/aggbug/3086663.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/snandy/archive/2013/05/24/3086663.html">本文链接</a></p></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
