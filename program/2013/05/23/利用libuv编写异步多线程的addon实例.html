<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>利用libuv编写异步多线程的addon实例</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>利用libuv编写异步多线程的addon实例</h2>
<p class="meta">23 May 2013</p>

<div class="post">
<h2>利用libuv编写异步多线程的addon实例</h2>

<h3>by snoopyxdy</h3>

<h3>at 2013-05-23 00:20:31</h3>

<h3>original <a href="http://snoopyxdy.blog.163.com/blog/static/601174402013422103614385">http://snoopyxdy.blog.163.com/blog/static/601174402013422103614385</a></h3>

<div>最近cnode上很多TX在问关于node的异步回调以及单线程的事情，今天看了libuv的一些api和demo，自己简单写了一个利用libuv实现异步多线程的<span style="line-height:22px">addon的</span>例子，真心希望大牛指正啊。<div><br></div><div><div style="line-height:22px">demo例子的地址：</div><div style="line-height:22px"><a style="line-height:22px" rel="nofollow" href="https://github.com/DoubleSpout/libuv_ex">https://github.com/DoubleSpout/libuv_ex</a></div><div style="line-height:22px">也可以</div><div style="line-height:22px">npm install libuv_ex</div><div style="line-height:22px">请保证您的node版本在0.10.x</div></div><div><br></div><div>首先介绍下libuv，libuv 是一个高性能事件驱动的程序库，封装了 Windows 和 Unix 平台一些底层特性，为开发者提供了统一的 API。libuv 采用了 异步 (asynchronous), 事件驱动 (event-driven)的编程风格, 其主要任务是为开人员提供了一套事件循环和基于I/O(或其他活动)通知的回调函数, libuv 提供了一套核心的工具集, 例如定时器, 非阻塞网络编程的支持, 异步访问文件系统, 子进程以及其他功能。</div><div>可见nodejs的一切异步操作都是基于libuv来实现的，有了它的这些api我们也就可以编写出异步的nodejs模块了。</div><div><br></div><div>最好结合github上的test和liuv.h来看，更加容易弄懂</div><div><span style="line-height:22px">中文版的libuv手册：</span><a rel="nofollow" href="http://forhappy.github.io/uvbook/index.html">http://forhappy.github.io/uvbook/index.html</a></div><div>libuv项目地址：<a style="line-height:22px" rel="nofollow" href="https://github.com/joyent/libuv">https://github.com/joyent/libuv</a></div><div><br></div><div><span style="line-height:22px">简单介绍一下这个demo实例把，我在demo里写了5个例子，分别用了不同的技术，执行了10次fibo(40)，最后所得到的结果也各不相同。</span></div><div><div style="line-height:22px">c++代码都在 ./src  文件夹中，Asyn类中定义了下述5种不同情况的方法和一些libuv的api所需要的回调函数，<span style="line-height:22px">在job类中，定义了执行fibo的任务函数，和一些相关设置，在线程中或者异步回调中传递的都是job类的指针。</span></div></div><div>例子执行代码如下：</div><div><div><pre><div><span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">//do fibo 10 times</span></div><div>var i = 40;</div><div>var times = 10;</div><div><br></div><div>asyn.sync(times,i,function(err, result){ //1、这里执行10次fibo(40)的函数，分别用不同的技术</div><div><span>   </span>console.log('fibo('+i+'):' + result)</div><div>})</div><div><br></div><div>var d1 = Date.now();</div><div>while(Date.now() - d1 &lt;= 1000*1){ //2、这里将主线程sleep 1秒，模拟js的执行工作</div><div><span> </span>//sleeping 10sec simulate the js work</div><div>}</div><div><br></div><div></div><p></p></pre></div><div>我们分别以5种不同的方式执行10次fibo(40)，看看测试结果会是什么样子的，我们主要记录全部执行任务的时间和模拟的js任务执行的时间。</div><div><br></div><div><b style="line-height:22px">1、完全同步，在c++代码中直接10次循环执行fibo(40)</b></div><div>执行测试代码：</div><div><a rel="nofollow" href="https://github.com/DoubleSpout/libuv_ex/blob/master/test/sync.js">https://github.com/DoubleSpout/libuv_ex/blob/master/test/sync.js</a></div><div><pre><p>main_thread_js_work: 4568ms<br>sync_all_the_work: 4568ms</p></pre>可见js执行完毕和所有任务执行完成是同一时间的，这个结果合情合理</div><div><br></div><div><br></div><div><b>2、使用libuv创建同步线程来计算fibo，然后将结果回调主线程</b></div><div>执行测试代码：</div><div><a rel="nofollow" href="https://github.com/DoubleSpout/libuv_ex/blob/master/test/sync_thread.js">https://github.com/DoubleSpout/libuv_ex/blob/master/test/sync_thread.js</a></div><div><pre><p>main_thread_js_work: 4595ms<br>sync_thread_all_the_work: 4595ms</p></pre>由于整个程序都是同步的，所以和之前一样，同步的多线程没有明显提升结果</div><div><br></div><div><br></div><div><b>3、使用libuv的async异步回调方式，将所有任务注册到事件循环中，这样将先执行js的sleep，然后在主线程中分别计算fibo的结果，这种情况有点像我们使用process.nextTick来让一个计算异步执行，保证当前主线程的工作不被阻塞，最后进行耗时计算。</b></div><div><span style="line-height:22px">执行测试代码：</span></div><div><a rel="nofollow" href="https://github.com/DoubleSpout/libuv_ex/blob/master/test/asyn.js">https://github.com/DoubleSpout/libuv_ex/blob/master/test/asyn.js</a></div><div><pre><p>main_thread_js_work: 1003ms</p><p>asyn_all_the_work: 4457ms</p></pre>因为我们将fibo放在了异步去执行，所以js的任务将被先执行，js任务执行了1秒（我们模拟sleep了1秒）之后就是fibo的任务，总时间和上面两种情况大致相同。</div><div><span style="line-height:22px"><br></span></div><div><br></div><div><b>4、使用libuv的async异步回调的方式，我们先注册fibo执行完毕的异步回调函数，然后<span style="line-height:22px">创建异步的线程去执行fibo，这样js的任务将和fibo线程同时进行工作.</span></b></div><div>执行测试代码：<a style="line-height:22px" rel="nofollow" href="https://github.com/DoubleSpout/libuv_ex/blob/master/test/asyn_thread.js">https://github.com/DoubleSpout/libuv_ex/blob/master/test/asyn_thread.js</a></div><div><pre><p>main_thread_js_work: 1017ms</p><p>asyn_thread_all_the_work: 1897ms</p></pre><span style="line-height:22px">因为js任务</span><span style="line-height:22px">抢占着主线程，同时也是因为js任务执行时间比较短，所以js任务结束提示先打印到了屏幕上，然后各异步线程也执行完毕，总耗时1897ms，比上面几种情况要快一倍，这主要归功于多核CPU的同时计算</span></div><div><span style="line-height:22px"><br></span></div><div><span style="line-height:22px"><br></span></div><div><span style="line-height:22px"><b>5、使用libuv自带的线程池进行异步计算fibo，我们先向线程池注册工作回调，然后再注册主线程的完成回调</b></span></div><div>执行测试代码：<a style="line-height:22px" rel="nofollow" href="https://github.com/DoubleSpout/libuv_ex/blob/master/test/asyn_pool.js">https://github.com/DoubleSpout/libuv_ex/blob/master/test/asyn_pool.js</a></div><div><pre><p></p><div>main_thread_js_work: 1002ms</div><div>asyn_pool_all_the_work: 2382ms</div><p></p></pre></div><div>这种情况和上述情况一样，不过我们不是为每个计算生成一个线程，而是使用了libuv内部的线程池，所以制约了并行计算的能力，但是这样更加安全，不容易因为不可控的线程数量导致程序崩溃，事实上libuv为我们提供了4个线程的线程池。</div><div><br></div><div>总结一下，使用libuv我们最好采用可控的异步线程配合异步回调来做一些事情，这样可以不阻塞主的js线程，还能并行执行任务，当任务结束后记得一定要回调主线程去执行js的回调函数，不能在其他线程去执行js的回调，因为在v8的一个isolate中，不可以多个线程同时操作一个isolate。<span style="line-height:22px">当我们在线程中操作共享变量时记得加锁和解锁。在异步任务执行完毕后记得执行uv_close，将其关闭，同时因为我们都是将指针作为参数传递的，不要忘记delete掉之前new的指针，这样</span><span style="line-height:22px">通过libuv的异步多线程api，我们就可以很轻松的为nodejs编写一些跨平台非阻塞扩展了。</span></div><div>PS，经过在win8 64位 和 linux 2.6.4 32bit虚拟机的测试中，我发现win8真是弱爆了，linux虚拟机执行上述任务的所消耗时间比我真机win8还要少一些。</div></div></div>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
