<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Backbone事件模块</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>Backbone事件模块</h2>
<p class="meta">2013-05-28 16:13</p>

<div class="post">
<h2>Backbone事件模块</h2>

<h3>by snandy</h3>

<h3>at 2013-05-28 08:13:00</h3>

<h3>original <a href="http://www.cnblogs.com/snandy/archive/2013/05/28/3074346.html">http://www.cnblogs.com/snandy/archive/2013/05/28/3074346.html</a></h3>

<p>事件模块Backbone.Events是Backbone的核心，Model、Collection、View都依赖它。</p>


<p><br><p>此外，事件模块的所有方法都挂在了全局的Backbone上，如果你的代码中需要用到<a href="http://www.cnblogs.com/snandy/archive/2011/05/30/2062990.html">自定义事件</a>(实现观察者模式)，可以直接使用它。</p><br><p> </p><br><p><a href="http://www.cnblogs.com/snandy/archive/2011/03/01/1967806.html">标示符</a>Events是内部的一个引用，为讨论方便，这里也省去了前缀Backbone，这篇文章会从以下几个点分析</p><br><ul style="margin-left:0"><br><li>Events API</li><br><li>Events的用法</li><br><li>Events内部数据结构 (<em>events/</em>listeners)</li><br><li>特殊事件: “all”</li><br><li>Events与Model、Collection、View、Router、History的关系</li><br></ul><br><p> </p><br><h3>一、Events API</h3><br><p>1.0之前只提供了三个基本方法 on/once/off/trigger，1.0开始增加了几个实用方法 listenTo/listenToOnce/stopListening。</p><br><p><img src="http://images.cnitblog.com/blog/114013/201305/19174311-923af809a9ab4f2fb9cbd03576496a44.png" alt="" width="500"></p><br><p>以下是各个方法的意义</p><br><ul style="margin-left:0"><br><li>on 添加自定义事件</li><br><li>off 删除自定义事件</li><br><li>trigger 派发自定义事件</li><br><li>once 添加只执行一次的自定义事件 （内部依赖于<em>.once）</li><br><li>listenTo 添加一个观察对象</li><br><li>listenToOnce 添加一个仅执行一次的观察对象</li><br><li>stopListening 删除添加的观察对象</li><br></ul><br><p> </p><br><h3>二、Events的代码鸟瞰</h3><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>var Events = Backbone.Events = {<br>    on: function(name, callback, context) {<br>// ...<br>    },<br>    once: function(name, callback, context) {<br>// ...<br>    },<br>    off: function(name, callback, context) {<br>// ...<br>    },<br>    trigger: function(name) {<br>    // ...<br>    },<br>    stopListening: function(obj, name, callback) {<br>// ...<br>    }<br>};<br><br>var eventSplitter = /\s+/;<br>var eventsApi = function(obj, action, name, rest) {<br>// ...<br>};<br>var triggerEvents = function(events, args) {<br>// ...<br>};<br>var listenMethods = {listenTo: 'on', listenToOnce: 'once'};<br><br></em>.each(listenMethods, function(implementation, method) {<br>    Events[method] = function(obj, name, callback) {<br>    // ...<br>    };<br>});<br><br>Events.bind   = Events.on;<br>Events.unbind = Events.off;<br><br><em>.extend(Backbone, Events);<br></pre><br></div><br><p>1. 先定义了一个对象（单例），直接挂上了接口方法on/once/off/trigger/stopListening，注意虽然Events头字母大写，这里不是定义一个类或构造器，而是一个<a href="http://www.cnblogs.com/snandy/archive/2011/04/07/2007717.html">单例对象</a>。</p><br><p>    剩下的变量和函数都是辅助这个对象的，它们都在闭包空间里，外部不可访问如eventSplitter、eventsApi等</p><br><p>2. eventSplitter用来实现空格间隔一次添加多个事件，如 .on('event1 event2', handler)</p><br><p>3. eventsApi实现的很巧妙，它辅助on/once、off、trigger完成事件的添加、删除、派发。你会发现这里是一个递归调用，来实现一些批量添加事件。如</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>// 空格间隔批量添加多个事件<br>.on('event1 event2', handler)<br><br>// 哈希对象批量添加<br>var obj = {<br>    event1: handler1,<br>    event2: handler2,<br>    event3: handler3<br>}<br>.on(obj)</pre><br></div><br><p>4. triggerEvent辅助trigger方法实现派发事件，它的实现有些特殊，见 <a href="http://www.cnblogs.com/snandy/archive/2013/05/23/3091258.html">冗余换性能</a></p><br><p>5. 后面的listenMethod和一个each迭代，会给Events添加两个新方法listenTo和listenToOnce</p><br><p>6. 再下面两行给on/off分别取了别名bind/unbind。其实这也是为了兼容老版本，最早的版本添加/删除事件为bind/unbind。</p><br><p>7. 最后一行把Events掺合到全局的Backbone对象上了</p><br><p>拓扑图如下</p><br><p><img src="http://images.cnitblog.com/blog/114013/201305/19185551-2eb314def71e441e90510ec8e2147af3.png" alt="" width="600"></p><br><p> </p><br><p> </p><br><h3>三、Events内部数据结构 (</em>events/<em>listeners)</h3><br><p>相对来说，目前的内部数据结构<a href="http://www.cnblogs.com/snandy/archive/2011/05/30/2062990.html">比较简单</a>。采用传统的先哈希，后数组存储事件处理器对象，处理器对象上有callback和context及ctx。其内部有两个关键对象</em>eventshe <em>listeners，都以下划线开头，说明这是私有的(并非真正私有，一种语法约定，真正私有可使用<a href="http://www.cnblogs.com/snandy/archive/2011/04/07/2007717.html#p2">闭包实现</a>)，仅供内部使用。</p><br><p></em>events 这个哈希是默认是挂在Backbone.Events上，由于Events是一个对象，所以很容易被Mix到任何想增加自定义事件的类或对象上。此时<em>events则挂在该对象上。如Backbone.Model，Backbone.Collection，Backbone.View，当给其实例添加自定义事件时，</em>events则挂在它们的实例对象上。</p><br><p> </p><br><p><em>events的结构如下</p><br><p><img src="http://images.cnitblog.com/blog/114013/201305/22073944-6220da14714144aba3e7a0a314e367b0.png" alt="" width="550"></p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre></em>.extend(Backbone, Events);</pre><br></div><br><p> </p><br><p><em>listeners 和 </em>events一样默认也是挂在Backbone.Events上。顾名思义，它是一个监听器，即可以为其它对象(具有Backbone.Events的所有方法的对象)被添加事件。它的key是以字母“l”开头后跟递增的数字组成，value是一个 “a mixin of Backbone.Events”。</p><br><p> </p><br><p><em>listeners的结构如下</p><br><p><img src="http://images.cnitblog.com/blog/114013/201305/22080348-d33f023fad3a4c0480d7178a3495c707.png" alt="" width="550"></p><br><p> </p><br><p>最后又把Events上的所有方法都拷贝到标示符Backbone这个全局对象上，即给Backbone添加了如下方法。这时可以很方便的使用它给自己的类添加自定义事件。</p><br><p><img src="http://images.cnitblog.com/blog/114013/201305/22072508-40f73c5e0dce41a5a1958ec41735c53a.png" alt="" width="250"></p><br><p> </p><br><h3>四、 特殊事件“all”</h3><br><p>事件名“all”，在trigger方法中，仔细看代码，你会发现trigger方法中调用了两次triggerEvents，一次是通过参数传进来的事件，另一次则固定为“all”事件。</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>var events = this.</em>events[name];<br>var allEvents = this.<em>events.all;<br>if (events) triggerEvents(events, args);<br>if (allEvents) triggerEvents(allEvents, arguments);<br></pre><br></div><br><p>trigger的通常实现只需把事件名，参数传进来，取哈希(这里是</em>events)上取该事件的所有handlers(存在在数组里)，挨个执行。但这里为什么每一次trigger调用还要单独取下all事件，然后执行呢？</p><br><p>如果只看Backbone.Events模块，是很难理解的。那么就搜索下整个Backbone.js，看“all”事件在哪些地方使用到。最后发现只在Backbone.Collection中用到，且仅一处。</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>model.on('all', this.<em>onModelEvent, this);<br></pre><br></div><br><p>只看这一行代码，还是难以理解。需要结合Backbone.Model和Backbone.Collection一起看。</p><br><p>这里先简单说下，我们知道这行代码所在方法是Collection.add，在往collection中添加model时执行的，即添加的model都会注册一个“all”事件。而当model自身销毁(destroy)或修改(change)的时候，需要通知其所在Collection。</p><br><p> </p><br><p>例如，model销毁后，Collection需要在集合中把它删除，Collection的长度也需要减一。model修改后，也需要通知Collection，这样给Collection添加的change事件也会触发。</p><br><p>这就是“all”事件的真正用途，以前曾想既然Backbone的View和通信都依赖于jQuery，那么事件模块也完全可以使用<a href="http://www.cnblogs.com/snandy/archive/2012/11/15/2770237.html">$.Callbacks</a>。不曾想到还有一个特殊的“all”事件。</p><br><p> </p><br><h3>五、Events与Model、Collection、View、Router、History的关系</h3><br><p>来看下代码</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre></em>.extend(Model.prototype, Events, {<br><br>})<br><em>.extend(Collection.prototype, Events, {<br><br>})<br></em>.extend(View.prototype, Events, {<br><br>})<br>_.extend(Router.prototype, Events, {<br><br>})<br></pre><br></div><br><p>把事件模块mixin到这几个类的原型上去了。一句话，这些类都具有Pub/Sub的功能，即都可以实现自定义事件，它们之间也就可以通过事件很方便的降低耦合。如果在加上数据、视图、逻辑的分层效果，这就是整个Backbone的精华了。</p><br><p> </p><br><p>相关：</p><br><p><a href="http://www.cnblogs.com/snandy/archive/2013/05/23/3091258.html">冗余换性能-从Backbone的triggerEvents说开了去</a></p><img src="http://www.cnblogs.com/snandy/aggbug/3074346.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/snandy/archive/2013/05/28/3074346.html">本文链接</a></p></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
