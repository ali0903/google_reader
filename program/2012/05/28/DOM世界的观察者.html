<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>DOM世界的观察者</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>DOM世界的观察者</h2>
<p class="meta">2012-05-28 18:03</p>

<div class="post">
<h2>DOM世界的观察者</h2>

<h3>by 司徒正美</h3>

<h3>at 2012-05-28 10:03:00</h3>

<h3>original <a href="http://www.cnblogs.com/rubylouvre/archive/2012/05/28/2520721.html">http://www.cnblogs.com/rubylouvre/archive/2012/05/28/2520721.html</a></h3>

<p>浏览器自带的观察者实在太多了。经典的不用说，就是onclick, attachEvent, addEventListner，可惜它们只是监听用户的行为。不过这当中有个特例是propertychange，当元素的属性，不管是自定义还是原生，只要发生改变，就会触发回调。我们还可以通过它的事件对象的propertyName知道那个元素发生改变。标准浏览器有个弱化版oninput,只能检测value值！</p>


<p>FF则有个__noSuchMethod__，只在用户调用方法时纠错用。后来，又搞出个逆天的Object.prototype.watch，由于元素节点在FF中也是Object的实例，其威力可想而已。但也有美中不足，我们不知道究竟是哪一个属性发生变化。 </p>


<p>但这一状况随着浏览器对setter,getter的强力介入得到改善。早在Firefox 2.0+, Safari 3.0+, Chrome 1.0+ 与 Opera 9.5+，他们就口径一致地添加以下方法，支持这种新语法： </p>


<p><br>var lost = {<br>loc : "Island",<br>get location () {<br>                //这里可以添加回调<br>return this.loc;<br>},<br>set location(val) {<br>                 //这里也可以搞小动作<br>this.loc = val;<br>}<br>};<br>lost.location = "Another island";<br><p>但这种新语法在IE8以下是会报致命错误，连try catch也挡不住，因此对这种兼容性极差的东西，程序员们不埋单，于是浏览器商又推销另一种新产品：</p><br><br>Object.defineProperty(document.body, "description", {<br>get : function () {<br>return this.desc;<br>},<br>set : function (val) {<br>this.desc = val;<br>}<br>});<br>document.body.description = "Content container";<br><p>著名的例子是在FF模拟outerHTML，不过这东西最终在FF11上实现了。</p><br>//http://stackoverflow.com/questions/1700870/how-do-i-do-outerhtml-in-firefox<br>            if (typeof (HTMLElement) != &quot;undefined&quot; &amp;&amp; !window.opera)  <br>            {  <br>                HTMLElement.prototype.<strong><strong><em>defineGetter</em></strong></strong>("outerHTML", function()  <br>                {  <br>                    var a = this.attributes, str = &quot;&lt;&quot; + this.tagName, i = 0; for (; i &lt; a.length; i++)  <br>                        if (a[i].specified)  <br>                            str += " " + a[i].name + '="' + a[i].value + '"';  <br>                    if (!this.canHaveChildren)  <br>                        return str + &quot; /&gt;&quot;;  <br>                    return str + &quot;&gt;&quot; + this.innerHTML + &quot;&quot;;  <br>                });  <br>                HTMLElement.prototype.<strong><strong><em>defineSetter</em></strong></strong>("outerHTML", function(s)  <br>                {  <br>                    var r = this.ownerDocument.createRange();  <br>                    r.setStartBefore(this);  <br>                    var df = r.createContextualFragment(s);  <br>                    this.parentNode.replaceChild(df, this);  <br>                    return s;  <br>                });  <br>                HTMLElement.prototype.<strong><strong><em>defineGetter</em></strong></strong>("canHaveChildren", function()  <br>                {  <br>                    return !/^(area|base|basefont|col|frame|hr|img|br|input|isindex|link|meta|param)$/.test(this.tagName.toLowerCase());   <br>                });  <br>            } <br><p>IE自有自己一套算盘，它使用Object.DefineProperty数据描述符实现 setter与getter。不过这东西在IE8有BUG，只能用于元素节点</p><br>//bug的详解见这里http://www.cnblogs.com/_franky/archive/2011/04/27/2030766.html<br>            Object.defineProperty(document.body, "description", {<br>                get : function () {<br>                    return this.desc;<br>                },<br>                set : function (val) {<br>                    this.desc = val;<br>                }<br>            });<br>            document.body.description = "Content container";<br><br>            // document.body.description will now return "Content container"<br><p>但setter,getter就是setter,getter，我们不应该在这里掺和，于是W3C提供了一系列高级的变动事件：</p><ul> <li><code>DOMAttrModified</code></li>  <li><code>DOMAttributeNameChanged</code></li> <li><code>DOMCharacterDataModified</code></li> <li><code>DOMElementNameChanged</code></li> <li><code>DOMNodeInserted</code></li> <li><code>DOMNodeInsertedIntoDocument</code></li>  <li><code>DOMNodeRemoved</code></li>  <li><code>DOMNodeRemovedFromDocument</code></li>  <li><code>DOMSubtreeModified</code></li></ul><p>这下好了，无论是你是元素做增删改操作，还是元素的孩子们做增删改操作，还是对它的innerHTML或是属性进行增删改操作，它都提供监听。早期jQuery的Sizzle就是利用过DOMAttrModified清查调缓存的。我们可以在<a href="http://dev.w3.org/2006/webapi/DOM-Level-3-Events/tests/framework/">这里</a>查到它们的用法。但一个问题是，<a href="https://developer.mozilla.org/en/DOM/Mutation_events">浏览器商对此不怎么热衷</a>，太复杂了，有太多了，太麻烦了，而且这类事件也不好用JS检测是否支持。</p><p>在ecma262v6中， FF开始推销它的一个好东西，<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>!它相当于ecma262v5的数据描述符的强化版，但暂时没有其他浏览器商埋单。搞不好像IE8实现setter，getter那样，换个名字上场。</p><p>不过像propertychange这样的东西太重要了，老麻烦setInterval太不意思了。现在onhashchange, oninput都出来了，总有人干这事。时代在招唤！MutationObserver终于应运而生！而且MutationObserver是出乎意料的强大，把上面一系列Mutation Event的活都干了，而且出身好了，已列入W3C草案，MDC的文档，FF14说好会支持它，而chrome18已实现了。</p><p><a href="http://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/">DOM MutationObserver – reacting to DOM changes without killing browser performance.</a>给出一个例子实现即时编辑：</p><br>&lt;!doctype html&gt;<br>&lt;html&gt;<br>    &lt;head&gt;<br>        &lt;title&gt;mass Framework&lt;/title&gt;<br>        &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt;<br>    &lt;/head&gt;<br>    &lt;body&gt;<br><br>        &lt;ol contenteditable oninput=&quot;&quot;&gt;<br>            &lt;li&gt;Press enter&lt;/li&gt;<br>        &lt;/ol&gt;<br>        &lt;script&gt;<br>            window.onload = function(){<br>                var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;<br>                var list = document.querySelector('input');<br><br>                var observer = new MutationObserver(function(mutations) {<br>                    mutations.forEach(function(mutation) {<br>                        if (mutation.type === 'childList') {<br>                            var list_values = [].slice.call(list.children)<br>                            .map( function(node) { return node.innerHTML; })<br>                            .filter( function(s) {<br>                                if (s === &#39;&lt;br&gt;&#39;) {<br>                                    return false;<br>                                }<br>                                else {<br>                                    return true;<br>                                }<br>                            });<br>                            console.log(list_values);<br>                        }<br>                    });<br>                });<br><br>                observer.observe(list, {<br>                    attributes: true,<br>                    childList: true,<br>                    characterData: true,<br><br>                });<br>    <br>            }<br><br>        &lt;/script&gt;<br>    &lt;/body&gt;<br>&lt;/html&gt;<br><p>如果翻看W3C， 我们可以找到更多用法：</p><br><br>&lt;!doctype html&gt;<br>&lt;html&gt;<br>    &lt;head&gt;<br>        &lt;title&gt;mass Framework&lt;/title&gt;<br>        &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt;<br><br><br>    &lt;/head&gt;<br>    &lt;body&gt;<br><br>        &lt;input value=&quot;aaa&quot;&gt;<br>        &lt;script&gt;<br>            window.onload = function(){<br>                var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;<br>                var list = document.querySelector('input');<br>                var observer = new MutationObserver(function(mutations) {<br>                    console.log(mutations)<br>                    mutations.forEach(function(record) {<br>                        if(record.attributeName == "value"){<br>                            console.log(record.target)<br>                            console.log(record.oldValue)<br>                        }<br>                    });<br>                });<br>                observer.observe(list, {<br>                    attributes: true,<br>                    childList: true,<br>                    characterData: true,<br>                    attributeOldValue :true,<br>                    attributeFilter:["value"]//只监听value属性,提高性能<br>                });<br>                list.setAttribute("value","bbb")<br>                list.setAttribute("value","ccc")<br>            }<br><br>        &lt;/script&gt;<br>    &lt;/body&gt;<br>&lt;/html&gt;<br><p><img src="http://images.cnblogs.com/cnblogs_com/rubylouvre/250668/o_MutationObserver.jpg"></p><p>如此一来我们就可以轻松实现propertychange的功能，也不用趟setter, getter的浑水了。现在它对前端实现MVC非常重要，负责对视图的变化进行监听，再配合已存的事件系统，形成一个密不透风的网，监听与揣测着用户的一举一动，堪比国安局啊，就像每家兰州拉面旁边必有个沙县小吃！</p><img src="http://www.cnblogs.com/rubylouvre/aggbug/2520721.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/rubylouvre/archive/2012/05/28/2520721.html">本文链接</a></p></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
