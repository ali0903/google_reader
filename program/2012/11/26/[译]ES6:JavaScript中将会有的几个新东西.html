<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>[译]ES6:JavaScript中将会有的几个新东西</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>[译]ES6:JavaScript中将会有的几个新东西</h2>
<p class="meta">2012-11-26 06:14</p>

<div class="post">
<h2>[译]ES6:JavaScript中将会有的几个新东西</h2>

<h3>by 紫云飞</h3>

<h3>at 2012-11-25 22:14:00</h3>

<h3>original <a href="http://www.cnblogs.com/ziyunfei/archive/2012/11/25/2784392.html">http://www.cnblogs.com/ziyunfei/archive/2012/11/25/2784392.html</a></h3>

<p>原文:<a href="http://addyosmani.com/blog/a-few-new-things-coming-to-javascript/">http://addyosmani.com/blog/a-few-new-things-coming-to-javascript/</a></p>


<hr><p>我相信,在ECMAScript.next到来的时候,我们现在每天都在写的JavaScript代码将会发生巨大的变化.接下来的一年将会是令JavaScript开发者们兴奋的一年,越来越多的特性提案将被最终敲定,新一版本的JavaScript将会慢慢得到普及.</p><p>本文中,我将会讲几个我个人很期待的,希望能在2013年或者更晚一点使用上的新特性.</p><p><img src="http://pic002.cnblogs.com/images/2012/116671/2012112319294364.jpg" alt=""></p><p><strong>ES.next目前的实现情况</strong></p><p>可以通过查看Juriy Zaytsev总结的<a href="http://kangax.github.com/es5-compat-table/es6/">ECMAScript 6兼容性表格</a>,和Mozilla的ES6<a href="https://developer.mozilla.org/en-US/docs/JavaScript/ECMAScript_6_support_in_Mozilla">实现情况</a>页面以及通过使用现代浏览器的最新版本(比如<a href="https://tools.google.com/dlpage/chromesxs">Chrome Canary</a>, <a href="http://www.mozilla.org/en-US/firefox/aurora/">Firefox Aurora</a>),来了解目前有哪些已经实现了的ES.next特性.</p><p>在Canary中,记得要进入<code>chrome:flags</code>打开'<span><span>启用实验</span>性JavaScript</span>'选项以激活所有最新的的JavaScript特性.</p><p>另外,许多ES.next特性还可以通过使用Google的<a href="https://code.google.com/p/traceur-compiler/">Traceur</a>转换编译器(<a href="http://code.google.com/p/traceur-compiler/source/browse/#git%2Ftest%2Ffeature">这里</a>有一些单元测试的例子)来体验,以及一些shim项目比如<a href="https://github.com/paulmillr/es6-shim">ES6-Shim</a>和<a href="https://github.com/Benvie/harmony-collections">Harmony Collections</a>,也实现了不少新特性.</p><p>在Node.js(V8)中使用<code>--harmony</code>命令行选项可以开启一些试验性质的ES.next特性,包括块级作用域,WeakMap等等.</p><p><strong>模块</strong></p><p>我们已经习惯了将我们的代码分割成为更加便于管理的功能块.在ES.next中,一个模块(module)是就是一个<code>module</code>声明,以及包含在该声明中的一组代码.模块可以用内联方式(inline)声明,也可以引入一个外部的模块文件.一个名为Car的内联模块的写法大致如下:</p><div><ol><li><span><span>module Car {  </span></span></li><li><span>  <span>// 导入 …</span><span>  </span></span></li><li><span>  <span>// 导出 …</span><span>  </span></span></li><li><span>}  </span></li></ol></div><p>一个模块实例就是一个被求过值的模块,它已经被链接到了其他的模块身上或者已经有了词法上的封装数据.下面是一个模块实例的例子:</p><div><ol><li><span><span>module myCar at </span><span>"car.js"</span><span>;  </span></span></li></ol></div><p><code>module</code>声明可以使用在如下上下文中:</p><div><ol><li><span><span>module UniverseTest {};  </span></span></li><li><span>module Universe { module MilkyWay {} };  </span></li><li><span>module MilkyWay = <span>'Universe/MilkyWay'</span><span>;  </span></span></li><li><span>module SolarSystem = Universe.MilkyWay.SolarSystem;  </span></li><li><span>module MySystem = SolarSystem;  </span></li></ol></div><p>一个<code>export</code>声明声明了一个可以被其他模块看到的局部函数或变量.</p><div><ol><li><span><span>module Car {  </span></span></li><li><span>  <span>// 内部变量</span></span></li><li><span>  <span>var</span><span> licensePlateNo = </span><span>'556-343'</span><span>;  </span></span></li><li><span>  <span>// 暴露到外部的变量和函数</span></span></li><li><span>  <span>export</span><span> </span><span>function</span><span> drive(speed, direction) {  </span></span></li><li><span>    console.log(<span>'details:'</span><span>, speed, direction);  </span></span></li><li><span>  }  </span></li><li><span>  <span>export</span><span> module engine{  </span></span></li><li><span>    <span>export</span><span> </span><span>function</span><span> check() { }  </span></span></li><li><span>  }  </span></li><li><span>  <span>export</span><span> </span><span>var</span><span> miles = 5000;  </span></span></li><li><span>  <span>export</span><span> </span><span>var</span><span> color = </span><span>'silver'</span><span>;  </span></span></li><li><span>};  </span></li></ol></div><p>一个模块可以使用<code>import</code>导入任何它所需要的其他模块.导入模块会读取被导入模块的所有可导出数据(比如上面的<code>drive()</code>, <code>miles</code>等),但不能修改它们.导出的变量或函数可以被重命名.</p><p>再次用到上面导出相关的例子,我们现在可以有选择性的导入一些模块中的功能.</p><p>比如我们可以导入<code>drive()</code>:</p><div><ol><li><span><span>import</span><span> drive from Car;  </span></span></li></ol></div><p>还可以可以同时导入<code>drive()</code>和<code>miles</code>:</p><div><ol><li><span><span>import</span><span> {drive, miles} from Car;  </span></span></li></ol></div><p>下面,我们要讲一下模块加载器API的概念.模块加载器能够让我们动态的加载所需要的脚本.类似于<code>import</code>, 我们可以使用被导入模块中的所有用<code>export</code>声明过的东西.</p><div><ol><li><span><span>// Signature: load(moduleURL, callback, errorCallback)</span><span>  </span></span></li><li><span>Loader.load(<span>'car.js'</span><span>, </span><span>function</span><span>(car) {  </span></span></li><li><span>  console.log(car.drive(500, <span>'north'</span><span>));  </span></span></li><li><span>}, <span>function</span><span>(err) {  </span></span></li><li><span>  console.log(<span>'Error:'</span><span> + err);  </span></span></li><li><span>});  </span></li></ol></div><p><code>load()</code>接受三个参数:</p><ul><li><code>moduleURL</code>: 表示一个模块URL的字符串 (比如 "car.js")</li><li><code>callback</code>: 一个回调函数,接受模块加载,编译,以及执行后的输出结果</li><li><code>errorCallback</code>: 一个回调函数,在加载或编译期间发生错误时调用</li></ul><p><strong>关于类(class)</strong></p><p>我不打算在本文中过多的讲ES.next中的<a href="http://infrequently.org/2012/04/class-warfare/">类</a>,如果你想知道类和模块将会有什么联系,Alex Russell曾经写过一个很好的<a href="http://infrequently.org/2011/09/why-class-doesnt-mean-what-you-think-it-means/">例子</a>来说明这件事.</p><p>JavaScript中有了类,并不意味着要把JavaScript变成Java.ES.next中的类只是我们已经熟悉的语义(比如函数,原型)的另外一种声明方式</p><p>下面是用来定义一个widget的ES.next代码:</p><div><ol><li><span><span>module widgets {  </span></span></li><li><span>  <span>// ...</span><span>  </span></span></li><li><span>  <span>class</span><span> DropDownButton </span><span>extends</span><span> Widget {  </span></span></li><li><span>    constructor(attributes) {  </span></li><li><span>      <span>super</span><span>(attributes);  </span></span></li><li><span>      <span>this</span><span>.buildUI();  </span></span></li><li><span>    }  </span></li><li><span>    buildUI() {  </span></li><li><span>      <span>this</span><span>.domNode.onclick = </span><span>function</span><span>(){  </span></span></li><li><span>        <span>// ...</span><span>  </span></span></li><li><span>      };  </span></li><li><span>    }  </span></li><li><span>  }  </span></li><li><span>}  </span></li></ol></div><p>下面是去糖(de-sugared)后的做法,也就是我们目前正在使用的方法:</p><div><ol><li><span><span>var</span><span> widgets = (</span><span>function</span><span>(global) {  </span></span></li><li><span>  <span>// ...</span><span>  </span></span></li><li><span>  <span>function</span><span> DropDownButton(attributes) {  </span></span></li><li><span>    Widget.call(<span>this</span><span>, attributes);  </span></span></li><li><span>    <span>this</span><span>.buildUI();  </span></span></li><li><span>  }  </span></li><li><span>  DropDownButton.prototype = Object.create(Widget.prototype, {  </span></li><li><span>    constructor: { value: DropDownButton },  </span></li><li><span>    buildUI:     {  </span></li><li><span>      value: <span>function</span><span>(e) {  </span></span></li><li><span>        <span>this</span><span>.domNode.onclick = </span><span>function</span><span>(e) {  </span></span></li><li><span>          <span>// ...</span><span>  </span></span></li><li><span>        }  </span></li><li><span>      }  </span></li><li><span>    }  </span></li><li><span>  });  </span></li><li><span>})(<span>this</span><span>);  </span></span></li></ol></div><p>ES.next的写法的确让代码变的更可读.这里的<code>class</code>也就相当于是<code>function</code>,至少是做了目前我们用<code>function</code>来做的一件事.如果你已经习惯并且也喜欢用JavaScript中的函数和原型,这种未来的语法糖也就不用在意了.</p><p><strong>这些模块如何和AMD配合使用?</strong></p><p>ES.next中的模块是朝着正确的方向走了一步吗?也许是吧.我自己的看法是:看相关的规范文档是一码事,实际上使用起来又是另一码事.在<a href="https://github.com/jdiamond/harmonizr">Harmonizr</a>,<a href="https://github.com/jrburke/require-hm">Require HM</a>和<a href="http://addyosmani.com/blog/a-few-new-things-coming-to-javascript/traceur-compiler.googlecode.com">Traceur</a>中可以体验新的模块语法,你会非常容易的熟悉这些语法,该语法可能会觉得有点像Python的感觉(比如<code>import</code>语句).</p><p>我认为,如果一些功能有足够广泛的使用需求(比如模块),那么平台(也就是浏览器)就应该原生支持它们.而且,并不是只有我一个人这么觉得. James Burke,发明了AMD和RequireJS的人,也曾经说过:</p><blockquote><p>我想,AMD和RequireJS应该被淘汰了.它们的确解决了一个实际存在的问题,但更理想的情况是,语言和运行环境应该内置类似的功能.模块的原生支持应该能够覆盖RequireJS 80%的使用需求,从这一点上说,我们不再需要使用任何用户态(userland)的模块加载库了,至少在浏览器中是这样.</p></blockquote><p>不过James的质疑是ES.next的模块是否是一个足够好的解决方案,他曾在六月份谈到过自己关于ES.next中模块的一些想法 <a href="http://tagneto.blogspot.co.uk/2012/06/es-modules-suggestions-for-improvement.html">ES6 Modules: Suggestions for improvement</a>以及再后来的一篇文章<a href="http://tagneto.blogspot.co.uk/2011/11/why-not-amd.html">Why not AMD?</a>.</p><p>Isaac Schlueter前段时间也写过一些自己的想法,讲到了ES6的模块有哪些<a href="http://blog.izs.me/post/25906678790/on-es-6-modules">不足</a>.尝试一下下面这些选项,看看你的想法如何.</p><p><strong>兼容目前引擎的Module实现</strong></p><ul><li><a href="http://bit.ly/Tg5Ytz">Traceur demo</a></li><li><a href="https://github.com/jdiamond/harmonizr">Harmonizr</a></li><li><a href="https://github.com/jrburke/require-hm">Require HM</a></li><li><a href="https://github.com/addyosmani/es6-module-loader">ES6 Module Loader</a></li></ul><p><strong>Object.observe()</strong></p><p>通过<a href="http://wiki.ecmascript.org/doku.php?id=harmony:observe"><code>Object.observe</code></a>,我们可以观察指定的对象,并且在该对象被修改时得到通知.这种修改操作包括属性的添加,更新,删除以及重新配置.</p><p>属性观察是我们经常会在MVC框架中看到的行为,它是数据绑定的一个重要组件,AngularJS和Ember.js都有自己的解决方案.</p><p>这是一个非常重要的新功能,它不仅比目前所有框架的同类实现性能要好,而且还能更容易的观察纯原生对象.</p><div><ol><li><span><span>// 一个简单的对象可以作为一个模块来使用</span><span>  <br></span></span></li><li><span><span>var</span><span> todoModel = {  </span></span></li><li><span>    label: <span>'Default'</span><span>,  </span></span></li><li><span>    completed: <span>false</span><span>  </span></span></li><li><span>};  </span></li><li><span><span>// 我们观察这个对象</span><span> <br></span></span></li><li><span>Object.observe(todoModel, <span>function</span><span>(changes) {  </span></span></li><li><span>    changes.forEach(<span>function</span><span>(change, i) {  </span></span></li><li><span>        console.log(change);  </span></li><li><span>        <span>/*</span> </span></li><li><span><span>            哪个属性被改变了? change.name</span> </span></li><li><span><span>            改变类型是什么? change.type</span> </span></li><li><span><span>            新的属性值是什么? change.object[change.name]</span> </span></li><li><span><span>        */</span><span>  </span></span></li><li><span>    });  </span></li><li><span>});  </span></li><li><span><span>// 使用时:</span></span></li><li><span>todoModel.label = <span>&#39;Buy some more milk&#39;</span><span>;  </span></span></li><li><span><span>/*</span> </span></li><li><span><span>    label属性被改变了</span> <br></span></li><li><span><span>    改变类型是属性值更新</span> <br></span></li><li><span><span>    当前属性值为&#39;Buy some more milk&#39;</span> </span></li><li><span><span>*/</span><span>  </span></span></li><li><span>todoModel.completeBy = <span>'01/01/2013'</span><span>;  </span></span></li><li><span><span>/*</span> </span></li><li><span><span>    completeBy属性被改变了</span> <br></span></li><li><span><span>    改变类型是属性被添加</span> <br></span></li><li><span><span>    当前属性值为&#39;01/01/2013&#39;</span> </span></li><li><span><span>*/</span><span>  </span></span></li><li><span><span>delete</span><span> todoModel.completed;  </span></span></li><li><span><span>/*</span> </span></li><li><span><span>    completed属性被改变了</span> <br></span></li><li><span><span>    改变类型是属性被删除</span> <br></span></li><li><span><span>    当前属性值为undefined</span> </span></li><li><span><span>*/</span><span>  </span></span></li></ol></div><p>Object.observe马上将会在Chrome Canary中实现(需要开启"<span><span>启用实验</span>性JavaScript</span>"选项).</p><p><strong>兼容目前引擎的Object.observe()实现</strong></p><ul><li><a href="http://github.com/rafaelw/v8">Chromium特殊版本</a></li><li><a href="https://github.com/melanke/Watch.JS">Watch.JS</a> 可以实现类似的功能,但它并不是实现<code>Object.observe</code>的polyfill或shim</li></ul><p>Rick Waldron的<a href="http://weblog.bocoup.com/javascript-object-observe/">这篇文章</a>有关于<code>Object.observe</code>更详细的介绍.</p><blockquote><p>译者注:Firefox很早就有了一个类似的东西:<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Object/watch">Object.prototype.watch</a>.</p></blockquote><p><strong>默认参数值</strong></p><p><a href="http://tc39wiki.calculist.org/es6/default-parameter-values/">默认参数值</a>(Default parameter values)的作用是:在一些形参没有被显式传值的情况下,使用默认的初始化值来进行初始化.这就意味着我们不再需要写类似<code>options = options || {};</code>这样的语句了.</p><p>该语法形式就是把一个初始值赋值给对应的形参名:</p><div><ol><li><span><span>function</span><span> addTodo(caption = </span><span>&#39;Do something&#39;</span><span>) {  </span></span></li><li><span>    console.log(caption);  </span></li><li><span>}  </span></li><li><span>addTodo(); <span>// Do something</span><span>  </span></span></li></ol></div><p>拥有默认参数值的形参只能放在形参列表的最右边:</p><div><ol><li><span><span>function</span><span> addTodo(caption, order = 4) {}  </span></span></li><li><span><span>function</span><span> addTodo(caption = </span><span>&#39;Do something&#39;</span><span>, order = 4) {}  </span></span></li><li><span><span>function</span><span> addTodo(caption, order = 10, other = </span><span>this</span><span>) {}  </span></span></li></ol></div><p>已经实现该特性的浏览器: Firefox 18+</p><blockquote><p>译者注:Firefox 15就已经实现了默认参数值,作者所说的18只是说18支持,并不是说18是第一个支持的版本.包括本文下面将要提到的chrome 24+等等,都有这个问题.</p></blockquote><p><strong>块级作用域</strong></p><p>块级作用域引入了两种新的声明形式,可以用它们定义一个只存在于某个语句块中的变量或常量.这两种新的声明关键字为:</p><ul><li><code>let</code>: 语法上非常类似于<code>var</code>, 但定义的变量只存在于当前的语句块中</li><li><code>const</code>: 和<code>let</code>类似,但声明的是一个只读的常量</li></ul><p>使用<code>let</code>代替<code>var</code>可以更容易的定义一个只在某个语句块中存在的局部变量,而不用担心它和函数体中其他部分的同名变量有冲突.在<code>let</code>语句内部用<code>var</code>声明的变量和在<code>let</code>语句外部用<code>var</code>声明的变量没什么差别,它们都拥有函数作用域,而不是块级作用域.</p><blockquote><p>译者注:以防读者看不懂,我用一个例子解释一下上面的这句话,是这样的:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">let(var1 = 1<span style="color:#000000">) {<br>    alert(var1);      </span><span style="color:#008000">//</span><span style="color:#008000">弹出1,var1是个块级作用域变量</span><br>    <span style="color:#0000ff">var</span> var2 = 2<span style="color:#000000">;<br>}<br></span><span style="color:#0000ff">var</span> var3 = 3<span style="color:#000000">;<br>alert(var2);          </span><span style="color:#008000">//</span><span style="color:#008000">弹出2,虽然var2是在let语句内部声明的,但它仍然是个函数作用域内的变量,因为使用的是var声明</span><br>alert(var3);          <span style="color:#008000">//</span><span style="color:#008000">弹出3</span><br>alert(var1);          <span style="color:#008000">//</span><span style="color:#008000">抛出异常</span></div></blockquote><div><ol><li><span><span>var</span><span> x = 8;  </span></span></li><li><span><span>var</span><span> y = 0;  </span></span></li><li><span>let (x = x+10, y = 12) {  </span></li><li><span>  console.log(x+y); <span>// 30</span><span>  </span></span></li><li><span>}  </span></li><li><span>console.log(x + y); <span>// 8</span><span>  </span></span></li></ol></div><p>实现<code>let</code>的浏览器: Firefox 18+, Chrome 24+</p><p>实现<code>const</code>的浏览器: Firefox 18+, Chrome 24+,  Safari 6+, WebKit, Opera 12+</p><blockquote><p>译者注:Firefox很久以前就支持了<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Statements/let">let</a>和<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Statements/const">const</a>,但这两个旧的实现都是依据了当年的<a href="https://wiki.mozilla.org/User:Shaver/ES4_FAQ">ES4</a>草案.和目前的ES6草案有些区别,比如ES4中用const声明的常量并没有块级作用域(和var一样,只是值不可变),let也有一些细微差别,就不说了.由于很少人使用旧版的Firefox(但我的主浏览器是FF3.6!),即使未来ES6和ES4中的一些东西有冲突,我们基本也可以忽略.</p></blockquote><p><strong>Map</strong></p><p>我想大部分读者已经熟悉了映射的概念,因为我们过去一直都是用纯对象来实现映射的.<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Map">Map</a>允许我们将一个值映射到一个唯一的键上,然后我们就可以通过这个键获取到对应的值,而不需要担心用普通对象实现映射时因原型继承而带来的问题.</p><p>使用<code>set()</code>方法,可以在map中添加一个新的键值对,使用<code>get()</code>方法,可以获取到所存储的值.Map对象还有其他三个方法:</p><ul><li><code>has(key)</code> : 一个布尔值,表明某个键是否存在于map中</li><li><code>delete(key)</code> : 删除掉map中指定的键</li><li><span style="text-decoration:line-through"><code>size()</code> : 返回map中键值对的个数</span></li></ul><div><ol><li><span><span>let m = </span><span>new</span><span> Map();  </span></span></li><li><span>m.set(<span>'todo'</span><span>, </span><span>'todo'</span><span>.length);  </span><span>// &quot;todo&quot; → 4</span><span>  </span></span></li><li><span>m.get(<span>'todo'</span><span>);                 </span><span>// 4</span><span>  </span></span></li><li><span>m.has(<span>'todo'</span><span>);                 </span><span>// true</span><span>  </span></span></li><li><span>m.<span>delete</span><span>(</span><span>'todo'</span><span>);              </span><span>// true</span><span>  </span></span></li><li><span>m.has(<span>'todo'</span><span>);                 </span><span>// false</span><span>  </span></span></li></ol></div><p>已经实现Map的浏览器: Firefox 18+</p><p>Nicholas Zakas的<a href="http://www.nczonline.net/blog/2012/10/09/ecmascript-6-collections-part-2-maps/">这篇文章</a>有关于Map更详细的介绍.</p><p><strong>兼容目前引擎的Map实现</strong></p><ul><li><a href="https://github.com/paulmillr/es6-shim">ES6 Shim</a></li><li><a href="https://github.com/Benvie/harmony-collections">Harmony Collections</a></li></ul><blockquote><p>译者注:我翻译过尼古拉斯的这篇文章:<a href="http://www.cnblogs.com/ziyunfei/archive/2012/10/10/2717754.html">[译]ECMAScript 6中的集合类型,第二部分:Map</a>.</p><p>作者可能不知道,10月份的ES6草案中,<code>Map.prototype.size</code>和<code>Set.prototype.size</code>都从size()方法改成size访问器属性了.同时Map对象新添加的方法还有很多,clear()用来清空一个map,forEach用来遍历一个map,还有items(),keys(),values()等.Set对象也类似,有不少作者没提到的方法,下面的Set小节我就不指出了.</p><p>另外,在ES5中,在把对象当成映射来使用的时候,为了防止原型继承带来的问题(比如在twitter中,@__proto__能让浏览器卡死),可以用var hash = Object.create(null)代替var hash = {};</p></blockquote><p><strong>Set</strong></p><p>正如Nicholas Zakas在他的文章中所说,对于那些接触过Ruby和Python等其他语言的程序员来说,<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Set">Set</a>并不是什么新东西,但它的确是在JavaScript中一直都缺少的特性.</p><p>任何类型的数据都可以存储在一个set中,但每个值只能存储一次(不能重复).利用Set可以很方便的创建一个不包含任何重复值的有序列表.</p><ul><li><code>add(value)</code> – 向set中添加一个值.</li><li><code>delete(value)</code> – 从set中删除value这个值.</li><li><code>has(value)</code> – 返回一个布尔值,表明value这个值是否存在于这个set中.</li></ul><div><ol><li><span><span>let s = </span><span>new</span><span> Set([1, 2, 3]);  </span><span>// s有1, 2, 3三个元素.</span><span>  </span></span></li><li><span>s.has(-Infinity);            <span>// false</span><span>  </span></span></li><li><span>s.add(-Infinity);            <span>// s有1, 2, 3, -Infinity四个元素.</span><span>  </span></span></li><li><span>s.has(-Infinity);            <span>// true</span><span>  </span></span></li><li><span>s.<span>delete</span><span>(-Infinity);         </span><span>// true</span><span>  </span></span></li><li><span>s.has(-Infinity);            <span>// false</span><span>  </span></span></li></ol></div><p>Set对象的一个作用是用来降低过滤操作(<span><span>filter</span></span>方法)的复杂度.比如:</p><div><ol><li><span><span>function</span><span> unique(array) {  </span></span></li><li><span>    <span>var</span><span> seen = </span><span>new</span><span> Set;  </span></span></li><li><span>    <span>return</span><span> array.filter(</span><span>function</span><span> (item) {  </span></span></li><li><span>        <span>if</span><span> (!seen.has(item)) {  </span></span></li><li><span>            seen.add(item);  </span></li><li><span>            <span>return</span><span> </span><span>true</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>    });  </span></li><li><span>}  </span></li></ol></div><p>这个利用Set来进行数组去重的函数的复杂度为O(n).而其他现有数组去重方法的复杂度几乎都为O(n^2).</p><p>已经实现Set的浏览器: Firefox 18, Chrome 24+.</p><p>Nicholas Zakas的<a href="http://www.nczonline.net/blog/2012/09/25/ecmascript-6-collections-part-1-sets/">这篇文章</a>有关于Set更详细的介绍.</p><p><strong>兼容目前引擎的Set实现</strong></p><ul><li><a href="https://github.com/paulmillr/es6-shim">ES6 Shim</a></li><li><a href="https://github.com/Benvie/harmony-collections">Harmony Collections</a></li></ul><blockquote><p>译者注:我翻译过尼古拉斯的这篇文章:<a href="http://www.cnblogs.com/ziyunfei/archive/2012/09/26/2703484.html">[译]ECMAScript 6中的集合类型,第一部分:Set</a>.</p><p>如果让我来实现一个ES6下的数组去重函数的话,我会这么写:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> unique(array) {   <br>    </span><span style="color:#0000ff">return</span> [v <span style="color:#0000ff">for</span><span style="color:#000000">(v of Set(array))]<br>}  </span></div><p>该函数使用到了ES6中的<a href="http://tc39wiki.calculist.org/es6/for-of/">for-of</a>遍历,以及<a href="http://tc39wiki.calculist.org/es6/array-comprehensions/">数组推导式</a>.不过效率比上面使用<span><span>filter</span></span>去重的方法稍微差点.Firefox最新版中已经可以执行这个函数.</p><p>另外,借助于下面将会提到的Array.from方法,还有更简单高效的写法:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt;Array.from(<span style="color:#0000ff">new</span> Set([ 1, 1, 2, 2, 3, 4<span style="color:#000000"> ]));<br>[</span>1,2,3,4]</div><p>甚至,借助于ES6中的<a href="http://tc39wiki.calculist.org/es6/spread/">展开</a>(spread)操作,还有可能这样实现:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt;[ ... <span style="color:#0000ff">new</span> Set([ 1, 1, 2, 2, 3, 4<span style="color:#000000"> ]) ];<br>[</span>1,2,3,4]</div></blockquote><p><strong>WeakMap</strong></p><p><a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/WeakMap">WeakMap</a>的键只能是个对象值,而且该键持有了所引用对象的弱引用,以防止内存泄漏的问题.这就意味着,如果一个对象除了WeakMap的键以外没有任何其他的引用存在的话,垃圾回收器就会销毁这个对象.</p><p>WeakMap的另外一个特点是我们不能遍历它的键,而Map可以.</p><div><ol><li><span><span>let m = </span><span>new</span><span> WeakMap();  </span></span></li><li><span>m.set(<span>'todo'</span><span>, </span><span>'todo'</span><span>.length);  </span><span>// 异常,键必须是个对象值!</span><span>  </span></span></li><li><span><span>// TypeError: Invalid value used as weak map key</span><span>  </span></span></li><li><span>m.has(<span>'todo'</span><span>);                 </span><span>// 同样异常!</span><span>  </span></span></li><li><span><span>// TypeError: Invalid value used as weak map key</span><span>  </span></span></li><li><span>let wmk = {};  </span></li><li><span>m.set(wmk, <span>'thinger'</span><span>);  </span><span>// wmk → &#39;thinger&#39;</span><span>  </span></span></li><li><span>m.get(wmk);             <span>// &#39;thinger&#39;</span><span>  </span></span></li><li><span>m.has(wmk);             <span>// true</span><span>  </span></span></li><li><span>m.<span>delete</span><span>(wmk);          </span><span>// true</span><span>  </span></span></li><li><span>m.has(wmk);             <span>// false</span><span>  </span></span></li></ol></div><p>已经实现WeakMap的浏览器: Firefox 18+, Chrome 24+.</p><p><strong>兼容目前引擎的WeakMap实现</strong></p><ul><li><a href="https://github.com/Benvie/harmony-collections">Harmony Collections</a></li></ul><p>Nicholas Zakas的<a href="http://www.nczonline.net/blog/2012/11/06/ecmascript-6-collections-part-3-weakmaps/">这篇文章</a>有关于WeakMap更详细的介绍.</p><blockquote><p>译者注:我翻译过尼古拉斯的这篇文章:<a href="http://www.cnblogs.com/ziyunfei/archive/2012/11/07/2758200.html">[译]ECMAScript 6中的集合类型,第三部分:WeakMap</a></p></blockquote><p><strong>代理</strong></p><p>代理(Proxy)API允许你创建一个属性值在运行期间动态计算的对象.还可以利用代理API"钩入"其他的对象,实现例如打印记录和赋值审核的功能.</p><div><ol><li><span><span>var</span><span> obj = {foo: </span><span>"bar"</span><span>};  </span></span></li><li><span><span>var</span><span> proxyObj = Proxy.create({  </span></span></li><li><span>  get: <span>function</span><span>(obj, propertyName) {  </span></span></li><li><span>    <span>return</span><span> </span><span>&#39;Hey, &#39;</span><span>+ propertyName;  </span></span></li><li><span>  }  </span></li><li><span>});  </span></li><li><span>console.log(proxyObj.Alex); <span>// &quot;Hey, Alex&quot;</span><span>  </span></span></li></ol></div><p>可以看看Nicholas Zakas的<a href="http://www.nczonline.net/blog/2011/09/15/experimenting-with-ecmascript-6-proxies/">这篇文章</a>和<a href="https://gist.github.com/1212121">这个例子</a>.</p><p>实现代理API的浏览器: Firefox 18+, Chrome 24+</p><blockquote><p>译者注:作者不知道的是,一共有过两个代理API的提案,一个是旧的<a href="http://wiki.ecmascript.org/doku.php?id=harmony:proxies">Catch-all Proxies</a>,一个是新的<a href="http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies">直接代理</a>(Direct Proxies).前者已被废弃.两者的区别在<a href="http://wiki.ecmascript.org/doku.php?id=strawman:direct_proxies">这里</a>.V8(Chrome和Node.js)实现的是前者,Firefox18及之后版本实现的是<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Proxy">后者</a>(17及之前版本实现的是<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Old_Proxy_API">前者</a>).尼古拉斯在2011年写的文章也应该是过时的.</p></blockquote><p><strong>一些新的API</strong></p><p><strong>Object.is</strong></p><p><code>Object.is</code>是一个用来比较两个值是否相等的函数.该函数和<code>===</code>最主要的区别是在对待特殊值<code>NaN</code>与自身以及正零与负零之间的比较上.<code>Object.is</code>的判断结果是:<code>NaN</code>与另外一个<code>NaN</code>是相等的,以及+0和-0是不等的.</p><div><ol><li><span><span>Object.is(0, -0); </span><span>// false</span><span>  </span></span></li><li><span>Object.is(NaN, NaN); <span>// true</span><span>  </span></span></li><li><span>0 === -0; <span>// true</span><span>  </span></span></li><li><span>NaN === NaN; <span>// false</span><span>  </span></span></li></ol></div><p>实现了Object.is的浏览器: Chrome 24+</p><p><strong>兼容目前引擎的Object.is实现</strong></p><ul><li><a href="https://github.com/paulmillr/es6-shim">ES6 Shim</a></li></ul><blockquote><p>译者注:Object.is方法和严格相等===运算符的区别体现在ES标准内部就是<a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-9.2.3">SameValue算法</a>和<a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-11.9.1">严格相等比较算法</a>的区别.</p></blockquote><blockquote><p>译者注:如果我没有理解错这条<a href="http://twitter.com/BrendanEich/status/272222102021623809">BE的推特</a>的话,Object.is要改名成为Object.sameValue了.</p></blockquote><p><strong>Array.from</strong></p><p><code>Array.from</code>: 将参数中的类数组(array-like)对象(比如arguments, NodeList, DOMTokenList (classList属性就是这个类型), NamedNodeMap (attributes属性就是这个类型))转换成数组并返回,比如转换一个纯对象:</p><div><ol><li><span><span>Array.from({  </span></span></li><li><span>    0: <span>&#39;Buy some milk&#39;</span><span>,  </span></span></li><li><span>    1: <span>&#39;Go running&#39;</span><span>,  </span></span></li><li><span>    2: <span>&#39;Pick up birthday gifts&#39;</span><span>,  </span></span></li><li><span>    length: 3  </span></li><li><span>});  </span></li></ol></div><p>再比如转换一个DOM节点集合:</p><div><ol><li><span><span>var</span><span> divs = document.querySelectorAll(</span><span>'div'</span><span>);  </span></span></li><li><span>Array.from(divs);  </span></li><li><span><span>// [&lt;div class=&quot;some classes&quot; data-info=&quot;12&quot;&gt;&lt;/div&gt;, &lt;div data-info=&quot;10&quot;&gt;&lt;/div&gt;]</span><span>  </span></span></li><li><span>Array.from(divs).forEach(<span>function</span><span>(node) {  </span></span></li><li><span>    console.log(node);  </span></li><li><span>});  </span></li></ol></div><p><strong>兼容目前引擎的Array.from实现</strong></p><ul><li><a href="https://github.com/paulmillr/es6-shim">ES6 Shim</a></li></ul><blockquote><p>译者注:从作者举的两个例子可以看出,Array.from基本相当于目前使用的[].prototype.slice.call.</p><p>目前的草案也的确是这样规定的,但从Rick Waldron(TC39成员)在原文评论中<a href="http://addyosmani.com/blog/a-few-new-things-coming-to-javascript/comment-page-1/#comment-18882">给出的代码</a>可以看出,也许Array.from未来也能将Set对象(非类数组对象,但可迭代)转换成数组.</p></blockquote><blockquote><p>译者注:除了这两个API,还有很多个新添加的API,比如</p><p>Number.<a href="http://wiki.ecmascript.org/doku.php?id=harmony:number.isfinite" rel="nofollow">isFinite</a>, <a href="http://wiki.ecmascript.org/doku.php?id=harmony:number.isnan" rel="nofollow">isNaN</a>, <a href="http://wiki.ecmascript.org/doku.php?id=harmony:number.isinteger" rel="nofollow">isInteger</a>, <a href="http://wiki.ecmascript.org/doku.php?id=harmony:number.tointeger" rel="nofollow">toInteger</a></p><p>String.prototype.<a href="http://wiki.ecmascript.org/doku.php?id=harmony:string.prototype.repeat" rel="nofollow">repeat</a>, <a href="http://wiki.ecmascript.org/doku.php?id=harmony:string_extras" rel="nofollow">startsWith, endsWith, contains, toArray</a></p><p>下面给出两个很有用的链接:</p><p>Mozilla正计划实现的ES6特性<a href="https://wiki.mozilla.org/ES6_plans">https://wiki.mozilla.org/ES6_plans</a>.</p><p>ES6目前的所有特性提案<a href="http://wiki.ecmascript.org/doku.php?id=harmony:proposals">http://wiki.ecmascript.org/doku.php?id=harmony:proposals</a></p></blockquote><p><strong>总结</strong></p><p>ES.next中添加了许多被认为是JavaScript中缺失已久的新特性.虽然ES6规范计划在2013年年底发布,不过浏览器们已经开始实现其中的一些特性了,这些特性被广泛使用也只是时间问题了.</p><p>在ES6完全实现之前,我们可以使用一些转换编译器(transpiler)或者shim来体验其中一些特性.</p><blockquote><p>译者注:目前最强大的ES6实现应该是Brandon Benvie写的<a href="https://github.com/Benvie/continuum">continuum</a>,这是一个JavaScript虚拟机,也就是用JavaScript(ES3)实现的JavaScript(ES6)引擎,它未来甚至可以工作在IE6上.目前实现的ES6特性有:模块以及模块加载器API,直接代理,生成器,解构,@symbols(我翻译成标志,这是一个不可能通过shim方式实现的语法)等等.<strong><strong><br></strong></strong></p></blockquote><p>想要查看更多的例子和了解最新的信息,可以去<a href="http://tc39wiki.calculist.org/">TC39 Codex Wiki</a>,该站点由Dave Herman和其他一些EC39成员维护(译者注:该新站仍在建设中,应该访问<a href="http://wiki.ecmascript.org/doku.php">旧站</a>).其中包含了下一代JavaScript中将要有的所有新特性.</p><p><span>激动人心</span><span>的</span><span>时刻</span><span>马上就要到来了!</span></p><blockquote><p><span>译者注:文本中提到的知识点仅仅是ES6中新知识的一小部分,而且明显作者自己也有点赶不上草案的快速变化(本文中提到的所有知识点都有可能在明天就发生变化).所以本文的内容仅仅是个开始,原文中的外部连接加上我给出的外部链接才是最需要你关注的.<br></span></p></blockquote><img src="http://www.cnblogs.com/ziyunfei/aggbug/2784392.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/ziyunfei/archive/2012/11/25/2784392.html">本文链接</a></p>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
