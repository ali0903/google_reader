<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>javascript 堆栈与列队</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>javascript 堆栈与列队</h2>
<p class="meta">24 Nov 2012</p>

<div class="post">
<h2>javascript 堆栈与列队</h2>

<h3>by 司徒正美</h3>

<h3>at 2012-11-23 21:08:00</h3>

<h3>original <a href="http://www.cnblogs.com/rubylouvre/archive/2012/11/23/2785051.html">http://www.cnblogs.com/rubylouvre/archive/2012/11/23/2785051.html</a></h3>

<p>javascript数组是一个逆天的存在，到了ecma262v5，它已经是堆栈，列队及迭代器的合体。有时候我们不需要这么强大的东西，这只要考虑到for循环太麻烦了，我们只需要非常简单的遍历，于是想用普通对象模拟一个就是。</p>


<p>首先是堆栈，先进后出</p>


<p><br>              function Stack(){   }<br>              Stack.prototype = {<br>                  add: function(el, pt){<br>                      this.<em>first =  pt = {//</em>first是不断变的<br>                          <em>next:this.</em>first,<br>                          el: el<br>                      }<br>                      if (pt.<em>next) {<br>                          pt.</em>next.<em>prev = pt;<br>                      }<br>                      return this;<br>                  }<br>              }<br>              var s = new Stack;<br><br>              s.add("1").add("2").add("3")<br>             <br>              var pt = s.</em>first;<br>              while (pt) {<br>                  alert(pt.el)<br>                  pt = pt.<em>next;<br>              }<br><p>接着是列队,先进先出：</p><br><br>              function Queue(){   }<br>              Queue.prototype = {<br>                  add: function(el){<br>                      if( this.</em>last ){ <br>                          this.<em>last =  this.</em>last.<em>next = {//</em>last是不断变的<br>                              el: el,<br>                              <em>next: null//设置</em>last属性表示最后一个元素，并且让新增元素成为它的一个属性值<br>                          }<br>                      }else{<br>                          this.<em>last = this.</em>first = {//我们要设置一个<em>first属性表示第一个元素<br>                              el: el,<br>                              </em>next: null<br>                          }<br>                      }<br>                      return this;<br>                  }<br>              }<br>              var q = new Queue<br>              q.add("1").add("2").add("3")<br>              var pt = q.<em>first;<br>              while (pt) {<br>                  console.log(pt.el)<br>                  pt = pt.</em>next;<br>              }<br><br><p>由于这两种结构的每个结点都是对象，因此它可以一直循环下去，直接_next为null。这样就避免[1,0,null,2]这样的集合遇假值中断的麻烦。</p><img src="http://www.cnblogs.com/rubylouvre/aggbug/2785051.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/rubylouvre/archive/2012/11/23/2785051.html">本文链接</a></p></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
