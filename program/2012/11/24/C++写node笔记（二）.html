<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>C++写node笔记（二）</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>C++写node笔记（二）</h2>
<p class="meta">2012-11-24 01:09</p>

<div class="post">
<h2>C++写node笔记（二）</h2>

<h3>by snoopyxdy</h3>

<h3>at 2012-11-23 17:09:47</h3>

<h3>original <a href="http://snoopyxdy.blog.163.com/blog/static/60117440201210233473129">http://snoopyxdy.blog.163.com/blog/static/60117440201210233473129</a></h3>

<div>上一学习笔记我们了解到了如何简单的编写一个c++的node模块，由于是新手，于是我就对照着node.js的api上的例子，再参考V8的接口文档，摸索着深入了解如何灵活编写c++的node模块，V8真的很好玩，接口写的很简单，调用方便，感觉已经陷进去了。<div><br><div><br><div>我们先简单解释一下简单的hello world的例子：</div></div><div><pre>#include &lt;node.h&gt;<br><p>#include &lt;v8.h&gt;<br><br>using namespace v8; //使用命名空间v8,不用在代码中写v8::XXXX<br><br>Handle&lt;Value&gt; Method(const Arguments&amp; args) { //定义一个function，返回Handle&lt;Value&gt;类的值<br>  HandleScope scope;     //实例化scope，用来存放返回值<br>  return scope.Close(String::New("world")); //将返回值丢入scope.close中<br>}<br><br>void init(Handle&lt;Object&gt; target) { //接受参数 <span style="line-height:22px">Handle&lt;Object&gt;类型，注意，这里target是指针</span><br>  target-&gt;Set(String::NewSymbol(&quot;hello&quot;),  //调用Set方法，对这个对象增加key和value</p>      FunctionTemplate::New(Method)-&gt;GetFunction()); //调用类<span style="line-height:22px">FunctionTemplate的静态成员New方法，传入</span><span style="line-height:22px">Handle&lt;Value&gt;类型的Method，然后调用GetFunction方法生成node函数，具体v8参考手册上有说明</span><p>}<br>NODE_MODULE(hello, init)  //固定将文件名hello，和init初始化函数丢入<span style="line-height:22px">NODE_MODULE</span></p></pre>官网有这段话：所有的node的插件必须输出一个初始化的函数，也就是说如下代码是在每个模块都必须有的，固定格式。</div><div><pre><p>void Initialize (Handle&lt;Object&gt; target);<br>NODE_MODULE(module_name, Initialize)</p></pre><div><br></div>接下来我们看官网的第二段例子：</div><div>官网的第二段例子是调用add方法可以实现2个整数相加</div><div><pre> <p>#define BUILDING_NODE_EXTENSION<br>#include &lt;node.h&gt;<br><br>using namespace v8;<br><br>Handle&lt;Value&gt; Add(const Arguments&amp; args) {<br>  HandleScope scope;<br><br>  if (args.Length() &lt; 2) { //如果args的长度小于2，则抛出错误，从下面代码我们知道如何抛出一个错误，以后照搬就行<br>    ThrowException(Exception::TypeError(String::New("Wrong number of arguments")));<br>    return scope.Close(Undefined());//返回Udefined<br>  }<br><br>  if (!args[0]-&gt;IsNumber() || !args[1]-&gt;IsNumber()) {//判断2个参数是否是number<br>    ThrowException(Exception::TypeError(String::New("Wrong arguments")));<br>    return scope.Close(Undefined());<br>  }<br><br>  Local&lt;Number&gt; num = Number::New(args[0]-&gt;NumberValue() + args[1]-&gt;NumberValue());//将参数转化成C++可用的double型相加，然后再转化成输出给node的Number型，最后赋值给 <span style="line-height:22px">Local&lt;Number&gt; 类型的变量 num，返回给用户</span><br>  return scope.Close(num);<br>}<br><br>void Init(Handle&lt;Object&gt; target) {<br>  target-&gt;Set(String::NewSymbol(&quot;add&quot;),<br>      FunctionTemplate::New(Add)-&gt;GetFunction());<br>}<br><br>NODE_MODULE(addon, Init)</p></pre>代码例子很简单，我们主要看到了几个新东西：</div><div><pre><p>String::New("Wrong arguments")</p></pre></div><div>这表示将C++字符串转化成js字符串对象</div><div><pre><p><span style="line-height:22px">args[0]-&gt;NumberValue()</span></p></pre>这表示将js传递过来的Number型变为C++可用的double型</div><div>具体在v8参考手册上有更多的类型变化，<a rel="nofollow" href="http://bespin.cz/~ondras/html/classv8_1_1Value.html">链接地址</a></div><div>V8的接口Local&lt;xxx&gt; 这种类型都是用来将C++的数据传输给js的</div><div>V8命名空间下的一些类，比如String，Date等都是用来将c++的数据转换为输出给js用的，当然这些类都继承自value类</div><div>感觉模块工作流程是这样的，接受node端的参数，如果要运算则变成c++类型的数据，进行运算，然后再将计算完成的数据转化成js的数据类型返回给js端。</div><div><br></div><div>上面c++模块js调用代码</div><div><pre><p>var addon = require('./build/Release/addon');<br><br>console.log( 'This should be eight:', addon.add(3,5) );</p></pre><br></div><div><br></div><div>我们继续看官网给出的下一个例子代码：</div><div>实现一个js回调函数，参数为"hello wrold"</div><div><pre><p>#define BUILDING_NODE_EXTENSION<br>#include &lt;node.h&gt;<br><br>using namespace v8;<br><br>Handle&lt;Value&gt; RunCallback(const Arguments&amp; args) {<br>  HandleScope scope;<br><br>  Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[0]); //将参数第一个也就是js传递过来的回调函数转化成c++的function<br>  const unsigned argc = 1; //定义无符号int argc为1<br>  Local&lt;Value&gt; argv[argc] = { Local&lt;Value&gt;::New(String::New(&quot;hello world&quot;)) };//创建一个数组，长度为1,<br>  cb-&gt;Call(Context::GetCurrent()-&gt;Global(), argc, argv);//利用local&lt;function&gt;的call方法然后将上下文，参数长度，以及参数数组传入call方法，即调用js端的回调<br><br>  return scope.Close(Undefined()); //返回undeined，无返回值<br>}<br><br>void Init(Handle&lt;Object&gt; target) {<br>  target-&gt;Set(String::NewSymbol(&quot;runCallback&quot;),<br>      FunctionTemplate::New(RunCallback)-&gt;GetFunction());<br>}<br><br>NODE_MODULE(addon, Init)</p></pre>js端调用代码：</div><div><pre><p>var addon = require('./build/Release/addon');<br><br></p><p>addon.runCallback(function(msg){<br>  console.log(msg); // 'hello world'<br>});</p></pre><br></div><div>最后一个例子：</div><div>用c++创建一个js的对象，我就不多说了，会在最后一个例子体现，接下来我们简单做一个测试</div><div>有如下node代码：</div><div><pre><p>console.time('for');<br><br>var ary = [];<br>for(var i=0;i&lt;10000000;i++){<br> ary.push({"aaa":123})<br>}</p><p><br>console.timeEnd('for');</p></pre>我们向一个数组push对象1千万个，输出时间为：</div><div><pre><p>for: 3972ms</p></pre>我们编写一个同样功能的c++代码：</div><div><pre><p>#define BUILDING_NODE_EXTENSION<br>#include &lt;node.h&gt;<br><br>using namespace v8;<br><br>Handle&lt;Value&gt; CreateObject(const Arguments&amp; args) {<br>  HandleScope scope;<br><br>  Handle&lt;Value&gt; k = args[0]-&gt;ToString(); //将传递的第一个参数转化为String类型<br>  Local&lt;Object&gt; obj = Object::New();//创建一个js的空对象<br><br>  if(args[1]-&gt;IsBoolean()){ //如果第二个参数是布尔值，则转化为布尔型<br> obj-&gt;Set(k, args[1]-&gt;ToBoolean());<br>  }<br>  else if(args[1]-&gt;IsNumber()){ <span style="line-height:22px">//如果第二个参数是数值，则转化为整形</span><br> obj-&gt;Set(k, args[1]-&gt;ToNumber());<br>  }<br>  else obj-&gt;Set(k, args[1]-&gt;ToString()); //否则转化为字符串<br><br>  int n = args[2]-&gt;NumberValue(); //将第三个参数转化为double</p><p><br>  Handle&lt;Array&gt; ary =  Array::New(n); //构建js数组，长度为n<br>  for(int i=0;i&lt;n;i++){<br> ary-&gt;Set(Integer::New(i), obj); //循环的往js数组内插入obj对象<br>  }<br><br>  return scope.Close(ary); //将数组输出给node端<br>}<br><br>void Init(Handle&lt;Object&gt; target) {<br>  target-&gt;Set(String::NewSymbol(&quot;createObject&quot;),<br>      FunctionTemplate::New(CreateObject)-&gt;GetFunction());<br>}<br><br>NODE_MODULE(object, Init)</p></pre>node端的代码：</div><div><pre><p>console.time('for');<br><br>var cr= require('./addon/build/Release/object.node').createObject;<br>var ary = cr("aaa",123,10000000);<br><br>console.timeEnd('for');</p></pre><p>执行时间：</p><p></p><pre><p>for: 2114ms</p></pre><br></div><div>个人感觉在处理一些大数据量的时候使用c++的模块可以大大的提升速度，比如去数据库获取大量数据进行筛选重组，然后传递给node，其他应用场景有待研究</div><br></div></div>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
