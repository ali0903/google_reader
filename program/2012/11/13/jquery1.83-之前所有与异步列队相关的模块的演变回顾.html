<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>jquery1.83 之前所有与异步列队相关的模块的演变回顾</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>jquery1.83 之前所有与异步列队相关的模块的演变回顾</h2>
<p class="meta">2012-11-13 16:47</p>

<div class="post">
<h2>jquery1.83 之前所有与异步列队相关的模块的演变回顾</h2>

<h3>by 司徒正美</h3>

<h3>at 2012-11-13 08:47:00</h3>

<h3>original <a href="http://www.cnblogs.com/rubylouvre/archive/2012/11/13/2765576.html">http://www.cnblogs.com/rubylouvre/archive/2012/11/13/2765576.html</a></h3>

<p title="司徒正美 Deferred">jQuery在<a href="https://github.com/jquery/jquery/blob/1.5/src/core.js" title="司徒正美 Deferred">1.5</a>引入了Deferred对象（异步列队），当时它还没有划分为一个模块，放到核心模块中。直到<a href="https://github.com/jquery/jquery/blob/1.5.2/src/deferred.js">1.52</a>才分割出来。它拥有三个方法:_Deferred， Deferred与when。</p>


<p>出于变量在不同作用域的共用，jQuery实现异步列队时不使用面向对象方式，它把_Deferred当作一个工厂方法，返回一个不透明的函数列队。之所以说不透明，是因为它的状态与元素都以闭包手段保护起来，只能通过列队对象提供的方法进行操作。这几个方法分别是done(添加函数)，resolveWith（指定作用域地执行所有函数），resolve（执行所有函数），isResolved（判定是否已经调用过resolveWith或resolve方法），cancel（中断执行操作）。但_Deferred自始至终都作为一个内部方法，从没有在文档中公开过。</p>


<p>Deferred在1.5是两个_Deferred的合体，但1+1不等于2，它还是做了增强。偷偷爆料，Deferred本来是python世界大名鼎鼎的Twisted框架的东西，由早期七大JS类库中的MochiKit取经回来，最后被dojo继承衣钵。jQuery之所以这样构造Deferred，分明不愿背抄袭的恶名，于是方法改得一塌糊涂，是jQuery命名最差的API，完全不知所云。它还加入当时正在热烈讨论的promise机制。下面是一个比较列表：</p>


<table>   <tr>      <td>dojo</td> <td>jQuery</td><td>注解</td>   </tr>    <tr>      <td>addBoth</td> <td>then</td><td>同时添加正常回调与错误回调</td>   </tr> <tr>      <td>addCallback</td> <td>done</td><td>添加正常回调</td>   </tr> <tr>      <td>addErrback</td> <td>fail</td> <td>添加错误回调</td>   </tr> <tr>      <td>callback</td> <td>resolve</td><td>执行所有正常回调</td>   </tr>    <tr>      <td>errback</td> <td>reject</td><td>执行所有错误回调</td>   </tr>  <tr>      <td></td> <td>resolveWith</td><td>在指定作用域下执行所有正常回调，但dojo已经在addCallback上指定好了</td>   </tr><tr>      <td></td> <td>rejectWith</td><td>在指定作用域下执行所有错误回调，但dojo已经在addErrback上指定好了</td>   </tr>  <tr>      <td></td> <td>promise</td><td>返回一个外界不能改变其状态的Deferred对象（外称为Promise对象）</td>   </tr></table>


<p><br>//这里面没有改变异步列队状态的方法——resolve, resolveWith, reject, rejectWith<br>//Deferred存在三种状态，没触发，完成（没出错），出错<br>promiseMethods = "then done fail isResolved isRejected promise".split( " " ),<br><br>// 创建一个不透明的函数列队<br><em>Deferred: function() {<br>var // callbacks list<br>callbacks = [],<br>// stored [ context , args ]<br>fired,<br>// to avoid firing when already doing so<br>firing,<br>// flag to know if the deferred has been cancelled<br>cancelled,<br>// the deferred itself<br>deferred  = {<br><br>// done( f1, f2, ...)<br>done: function() {<br>if ( !cancelled ) {<br>var args = arguments,<br>i,<br>length,<br>elem,<br>type,<br></em>fired;<br>if ( fired ) {<br><em>fired = fired;<br>fired = 0;<br>}<br>for ( i = 0, length = args.length; i &lt; length; i++ ) {<br>elem = args[ i ];<br>type = jQuery.type( elem );<br>if ( type === "array" ) {<br>deferred.done.apply( deferred, elem );<br>} else if ( type === "function" ) {<br>callbacks.push( elem );<br>}<br>}<br>if ( </em>fired ) {<br>deferred.resolveWith( <em>fired[ 0 ], </em>fired[ 1 ] );<br>}<br>}<br>return this;<br>},<br><br>// resolve with given context and args<br>resolveWith: function( context, args ) {<br>if ( !cancelled &amp;&amp; !fired &amp;&amp; !firing ) {<br>firing = 1;<br>try {<br>while( callbacks[ 0 ] ) {<br>callbacks.shift().apply( context, args );<br>}<br>}<br>finally {<br>fired = [ context, args ];<br>firing = 0;<br>}<br>}<br>return this;<br>},<br><br>// resolve with this as context and given arguments<br>resolve: function() {<br>deferred.resolveWith( jQuery.isFunction( this.promise ) ? this.promise() : this, arguments );<br>return this;<br>},<br><br>// Has this deferred been resolved?<br>isResolved: function() {<br>return !!( firing || fired );<br>},<br><br>// Cancel<br>cancel: function() {<br>cancelled = 1;<br>callbacks = [];<br>return this;<br>}<br>};<br><br>return deferred;<br>},<br><br>// 创建一个异步列队<br>Deferred: function( func ) {<br>var deferred = jQuery.<em>Deferred(),<br>failDeferred = jQuery.</em>Deferred(),<br>promise;<br>// Add errorDeferred methods, then and promise<br>jQuery.extend( deferred, {<br>then: function( doneCallbacks, failCallbacks ) {<br>deferred.done( doneCallbacks ).fail( failCallbacks );<br>return this;<br>},<br>fail: failDeferred.done,<br>rejectWith: failDeferred.resolveWith,<br>reject: failDeferred.resolve,<br>isRejected: failDeferred.isResolved,<br>                        //这是一个单例方法，一个异步列队只对应一个Promise对象，Promise可以说其代理人<br>promise: function( obj , i /<em> internal </em>/ ) {<br>if ( obj == null ) {<br>if ( promise ) {//<br>return promise;<br>}<br>promise = obj = {};<br>}<br>i = promiseMethods.length;<br>while( i-- ) {<br>obj[ promiseMethods[ i ] ] = deferred[ promiseMethods[ i ] ];<br>}<br>return obj;<br>}<br>} );<br>// Make sure only one callback list will be used<br>deferred.then( failDeferred.cancel, deferred.cancel );<br>// Unexpose cancel<br>delete deferred.cancel;<br>// Call given func if any<br>if ( func ) {<br>func.call( deferred, deferred );<br>}<br>return deferred;<br>},<br><br>// 用于实现回调的回调<br>when: function( object ) {<br>var args = arguments,<br>length = args.length,<br>deferred = length &lt;= 1 &amp;&amp; object &amp;&amp; jQuery.isFunction( object.promise ) ?<br>object :<br>jQuery.Deferred(),<br>promise = deferred.promise(),<br>resolveArray;<br><br>if ( length &gt; 1 ) {<br>resolveArray = new Array( length );<br>jQuery.each( args, function( index, element ) {<br>jQuery.when( element ).then( function( value ) {<br>resolveArray[ index ] = arguments.length &gt; 1 ? slice.call( arguments, 0 ) : value;<br>if( ! --length ) {<br>deferred.resolveWith( promise, resolveArray );<br>}<br>}, deferred.reject );<br>} );<br>} else if ( deferred !== object ) {<br>deferred.resolve( object );<br>}<br>return promise;<br>},<br><br><p title="司徒正美 when">jQuery的when方法用于实现回调的回调，或者说，几个异列列队都执行后才执行另外的一些回调。这些后来的回调也是用done, when, fail添加的，但when返回的这个对象已经添加让用户控制它执行的能力了。因为这时它是种叫Promise的东西，只负责添加回调与让用户窥探其状态。一旦前一段回调都触发了，它就自然进入正常回调列队（deferred ，见Deferred方法的定义）或错误回调列队（failDeferred ）中去。不过我这样讲，对于没有异步编程经验的人来说，肯定听得云里雾里。看实例好了。</p><br>  $.when({aa:1}, {aa:2}).done(function(a,b){<br>         console.log(a.aa)<br>          console.log(b.aa)<br>     });<br><p title="司徒正美 Deferred">直接输出1,2。如果是传入两个函数，也是返回两个函数。因此对于普通的数据类型，前面的when有多少个参数，后面的done, fail方法的回调就有多少个参数。</p><br>               function fn(){<br>                    return 4;<br>                }<br> <br>                function log(s){<br>                  window.console &amp;&amp; console.log(s)<br>                }<br>                $.when( { num:1 }, 2, '3', fn() ).done(function(o1, o2, o3, o4){<br>                    log(o1.num);<br>                    log(o2);<br>                    log(o3);<br>                    log(o4);<br>                });<br><p>如果我们想得到各个异步的结果，我们需要用resolve, resolveWith, reject, rejectWith进行传递它们。</p><br>                var log = function(msg){<br>                    window.console &amp;&amp; console.log(msg)<br>                }<br>                function asyncThing1(){<br>                    var dfd = $.Deferred();<br>                    setTimeout(function(){<br>                        log('asyncThing1 seems to be done...');<br>                        dfd.resolve('1111');<br>                    },1000);<br>                    return dfd.promise();<br>                }<br>                function asyncThing2(){<br>                    var dfd = $.Deferred();<br>                    setTimeout(function(){<br>                        log('asyncThing2 seems to be done...');<br>                        dfd.resolve('222');<br>                    },1500);<br>                    return dfd.promise();<br>                }<br>                function asyncThing3(){<br>                    var dfd = $.Deferred();<br>                    setTimeout(function(){<br>                        log('asyncThing3 seems to be done...');<br>                        dfd.resolve('333');<br>                    },2000);<br>                    return dfd.promise();<br>                }<br>     <br>                /<em> do it </em>/<br>                $.when( asyncThing1(), asyncThing2(), asyncThing3() ).done(function(res1, res2, res3){<br>                    log('all done!');<br>                    log(res1 + ', ' + res2 + ', ' + res3);<br>                })<br><p title="司徒正美 异步列队">异步列队一开始没什么人用（现在也没有什么人用，概念太抽象了，方法名起得太烂了），于是它只能在内部自产自销。首先被染指的是queue。queue模块是1.4为吸引社区的delay插件，特地从data模块中分化的产物，而data则是从event模块化分出来的。jQuery新模块的诞生总是因为用户对已有API的局限制不满而致。最早的queue模块的源码：</p><br>jQuery.extend({<br>queue: function( elem, type, data ) {<br>if ( !elem ) {<br>return;<br>}<br><br>type = (type || "fx") + "queue";<br>var q = jQuery.data( elem, type );<br><br>// Speed up dequeue by getting out quickly if this is just a lookup<br>if ( !data ) {<br>return q || [];<br>}<br><br>if ( !q || jQuery.isArray(data) ) {<br>q = jQuery.data( elem, type, jQuery.makeArray(data) );<br><br>} else {<br>q.push( data );<br>}<br><br>return q;<br>},<br><br>dequeue: function( elem, type ) {<br>type = type || "fx";<br><br>var queue = jQuery.queue( elem, type ), fn = queue.shift();<br><br>// If the fx queue is dequeued, always remove the progress sentinel<br>if ( fn === "inprogress" ) {<br>fn = queue.shift();<br>}<br><br>if ( fn ) {<br>// Add a progress sentinel to prevent the fx queue from being<br>// automatically dequeued<br>if ( type === "fx" ) {<br>queue.unshift("inprogress");<br>}<br><br>fn.call(elem, function() {<br>jQuery.dequeue(elem, type);<br>});<br>}<br>}<br>});<br><br>jQuery.fn.extend({<br>queue: function( type, data ) {<br>if ( typeof type !== "string" ) {<br>data = type;<br>type = "fx";<br>}<br><br>if ( data === undefined ) {<br>return jQuery.queue( this[0], type );<br>}<br>return this.each(function( i, elem ) {<br>var queue = jQuery.queue( this, type, data );<br><br>if ( type === &quot;fx&quot; &amp;&amp; queue[0] !== &quot;inprogress&quot; ) {<br>jQuery.dequeue( this, type );<br>}<br>});<br>},<br>dequeue: function( type ) {<br>return this.each(function() {<br>jQuery.dequeue( this, type );<br>});<br>},<br><br>// Based off of the plugin by Clint Helfers, with permission.<br>// http://blindsignals.com/index.php/2009/07/jquery-delay/<br>delay: function( time, type ) {<br>time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;<br>type = type || "fx";<br><br>return this.queue( type, function() {<br>var elem = this;<br>setTimeout(function() {<br>jQuery.dequeue( elem, type );<br>}, time );<br>});<br>},<br><br>clearQueue: function( type ) {<br>return this.queue( type || "fx", [] );<br>}<br>});<br><br><p>1.6添加了<em>mark,</em>unmark，promise。queue是让函数同属一个队伍里面，目的是让动画一个接一个执行。<em>mark则是让它们各自拥有队伍，并列执行（虽然它们只记录异步列队中已被执行的函数个数）。promise则在这些并发执行的动画执行后才执行另些一些回调（或动画）。</p><br><br>(function( jQuery ) {<br><br>function handleQueueMarkDefer( elem, type, src ) {<br>    //清空记录deferred个数的字段，函数列队与异步列队<br>var deferDataKey = type + "defer",<br>queueDataKey = type + "queue",<br>markDataKey = type + "mark",<br>defer = jQuery.data( elem, deferDataKey, undefined, true );<br>if ( defer &amp;&amp;<br>( src === &quot;queue&quot; || !jQuery.data( elem, queueDataKey, undefined, true ) ) &amp;&amp;<br>( src === "mark" || !jQuery.data( elem, markDataKey, undefined, true ) ) ) {<br>// Give room for hard-coded callbacks to fire first<br>// and eventually mark/queue something else on the element<br>setTimeout( function() {<br>if ( !jQuery.data( elem, queueDataKey, undefined, true ) &amp;&amp;<br>!jQuery.data( elem, markDataKey, undefined, true ) ) {<br>jQuery.removeData( elem, deferDataKey, true );<br>defer.resolve();<br>}<br>}, 0 );<br>}<br>}<br><br>jQuery.extend({<br><br></em>mark: function( elem, type ) {<br>if ( elem ) {<br>type = (type || "fx") + "mark";//创建一个以mark为后缀的字段，用于记录此列队中个数<br>jQuery.data( elem, type, (jQuery.data(elem,type,undefined,true) || 0) + 1, true );<br>}<br>},<br><br><em>unmark: function( force, elem, type ) {<br>if ( force !== true ) {<br>type = elem;<br>elem = force;<br>force = false;<br>}<br>if ( elem ) {<br>type = type || "fx";<br>var key = type + "mark",<br>                        //让个数减1，如果第一个参数为true，就强逼减至0<br>count = force ? 0 : ( (jQuery.data( elem, key, undefined, true) || 1 ) - 1 );<br>if ( count ) {<br>jQuery.data( elem, key, count, true );<br>} else {//如果为0，就移除它<br>jQuery.removeData( elem, key, true );<br>handleQueueMarkDefer( elem, type, "mark" );<br>}<br>}<br>},<br><br>queue: function( elem, type, data ) {<br>if ( elem ) {<br>type = (type || "fx") + "queue";<br>var q = jQuery.data( elem, type, undefined, true );<br>// Speed up dequeue by getting out quickly if this is just a lookup<br>if ( data ) {<br>if ( !q || jQuery.isArray(data) ) {<br>q = jQuery.data( elem, type, jQuery.makeArray(data), true );<br>} else {<br>q.push( data );<br>}<br>}<br>return q || [];<br>}<br>},<br><br>dequeue: function( elem, type ) {<br>type = type || "fx";<br><br>var queue = jQuery.queue( elem, type ),<br>fn = queue.shift(),<br>defer;<br><br>// If the fx queue is dequeued, always remove the progress sentinel<br>if ( fn === "inprogress" ) {<br>fn = queue.shift();<br>}<br><br>if ( fn ) {<br>// Add a progress sentinel to prevent the fx queue from being<br>// automatically dequeued<br>if ( type === "fx" ) {<br>queue.unshift("inprogress");<br>}<br><br>fn.call(elem, function() {<br>jQuery.dequeue(elem, type);<br>});<br>}<br><br>if ( !queue.length ) {<br>jQuery.removeData( elem, type + "queue", true );<br>handleQueueMarkDefer( elem, type, "queue" );<br>}<br>}<br>});<br><br>jQuery.fn.extend({<br>queue: function( type, data ) {<br>if ( typeof type !== "string" ) {<br>data = type;<br>type = "fx";<br>}<br><br>if ( data === undefined ) {<br>return jQuery.queue( this[0], type );<br>}<br>return this.each(function() {<br>var queue = jQuery.queue( this, type, data );<br><br>if ( type === &quot;fx&quot; &amp;&amp; queue[0] !== &quot;inprogress&quot; ) {<br>jQuery.dequeue( this, type );<br>}<br>});<br>},<br>dequeue: function( type ) {<br>return this.each(function() {<br>jQuery.dequeue( this, type );<br>});<br>},<br>// Based off of the plugin by Clint Helfers, with permission.<br>// http://blindsignals.com/index.php/2009/07/jquery-delay/<br>delay: function( time, type ) {<br>time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;<br>type = type || "fx";<br><br>return this.queue( type, function() {<br>var elem = this;<br>setTimeout(function() {<br>jQuery.dequeue( elem, type );<br>}, time );<br>});<br>},<br>clearQueue: function( type ) {<br>return this.queue( type || "fx", [] );<br>},<br><br>        //把jQuery对象装进一个异步列队，允许它在一系列动画中再执行之后绑定的回调<br>promise: function( type, object ) {<br>if ( typeof type !== "string" ) {<br>object = type;<br>type = undefined;<br>}<br>type = type || "fx";<br>var defer = jQuery.Deferred(),<br>elements = this,<br>i = elements.length,<br>count = 1,<br>deferDataKey = type + "defer",<br>queueDataKey = type + "queue",<br>markDataKey = type + "mark";<br>function resolve() {<br>if ( !( --count ) ) {<br>defer.resolveWith( elements, [ elements ] );<br>}<br>}<br>while( i-- ) {<br>                    //如果它之前已经使用过unmark, queue等方法，那么我们将生成一个新的Deferred放进缓存系统<br>if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||<br>( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||<br>jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &amp;&amp;<br>jQuery.data( elements[ i ], deferDataKey, jQuery.</em>Deferred(), true ) )) {<br>count++;<br>tmp.done( resolve );<br>}<br>}<br>resolve();<br>return defer.promise();<br>}<br>});<br><br>})( jQuery );<br><p>jQuery.ajax模块也被染指，$.XHR对象，当作XMLHttpRequest 对象的仿造器是由一个Deferred对象与一个<em>Deferred的对象构成。</p><br><br>deferred = jQuery.Deferred(),<br>completeDeferred = jQuery.</em>Deferred(),<br>jqXHR  ={/<em><em>/}<br>//....<br>deferred.promise( jqXHR );<br>jqXHR.success = jqXHR.done;<br>jqXHR.error = jqXHR.fail;<br>jqXHR.complete = completeDeferred.done;<br><br><p>jQuery1.7，从deferred模块中分化出callback模块，其实就是之前的_Deferred的增强版，添加去重，锁定，return false时中断执行下一个回调，清空等功能。</p><br>(function( jQuery ) {<br><br>// String to Object flags format cache<br>var flagsCache = {};<br><br>// Convert String-formatted flags into Object-formatted ones and store in cache<br>function createFlags( flags ) {<br>var object = flagsCache[ flags ] = {},<br>i, length;<br>flags = flags.split( /\s+/ );<br>for ( i = 0, length = flags.length; i &lt; length; i++ ) {<br>object[ flags[i] ] = true;<br>}<br>return object;<br>}<br><br>/</em><br> * Create a callback list using the following parameters:<br> </em><br> <em>flags:an optional list of space-separated flags that will change how<br> </em>the callback list behaves<br> <em><br> * By default a callback list will act like an event callback list and can be<br> * "fired" multiple times.<br> </em><br> * Possible flags:<br> <em><br> </em>once:只执行一次<br> <em><br> </em>memory:模仿domReady的行为<br> <em><br> </em>unique:去重<br> <em><br> </em>stopOnFalse:        模仿事件回调中的return false中断传播的行为<br> <em><br> </em>/<br>jQuery.Callbacks = function( flags ) {<br><br>// Convert flags from String-formatted to Object-formatted<br>// (we check in cache first)<br>flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};<br><br>var // Actual callback list<br>list = [],<br>// Stack of fire calls for repeatable lists<br>stack = [],<br>// Last fire value (for non-forgettable lists)<br>memory,<br>// Flag to know if list is currently firing<br>firing,<br>// First callback to fire (used internally by add and fireWith)<br>firingStart,<br>// End of the loop when firing<br>firingLength,<br>// Index of currently firing callback (modified by remove if needed)<br>firingIndex,<br>// Add one or several callbacks to the list<br>add = function( args ) {<br>var i,<br>length,<br>elem,<br>type,<br>actual;<br>for ( i = 0, length = args.length; i &lt; length; i++ ) {<br>elem = args[ i ];<br>type = jQuery.type( elem );<br>if ( type === "array" ) {<br>// Inspect recursively<br>add( elem );<br>} else if ( type === "function" ) {<br>// Add if not in unique mode and callback is not in<br>if ( !flags.unique || !self.has( elem ) ) {<br>list.push( elem );<br>}<br>}<br>}<br>},<br>// Fire callbacks<br>fire = function( context, args ) {<br>args = args || [];<br>memory = !flags.memory || [ context, args ];<br>firing = true;<br>firingIndex = firingStart || 0;<br>firingStart = 0;<br>firingLength = list.length;<br>for ( ; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++ ) {<br>if ( list[ firingIndex ].apply( context, args ) === false &amp;&amp; flags.stopOnFalse ) {<br>memory = true; // Mark as halted<br>break;<br>}<br>}<br>firing = false;<br>if ( list ) {<br>if ( !flags.once ) {<br>if ( stack &amp;&amp; stack.length ) {<br>memory = stack.shift();<br>self.fireWith( memory[ 0 ], memory[ 1 ] );<br>}<br>} else if ( memory === true ) {<br>self.disable();<br>} else {<br>list = [];<br>}<br>}<br>},<br>// Actual Callbacks object<br>self = {<br>// Add a callback or a collection of callbacks to the list<br>add: function() {<br>if ( list ) {<br>var length = list.length;<br>add( arguments );<br>// Do we need to add the callbacks to the<br>// current firing batch?<br>if ( firing ) {<br>firingLength = list.length;<br>// With memory, if we're not firing then<br>// we should call right away, unless previous<br>// firing was halted (stopOnFalse)<br>} else if ( memory &amp;&amp; memory !== true ) {<br>firingStart = length;<br>fire( memory[ 0 ], memory[ 1 ] );<br>}<br>}<br>return this;<br>},<br>// Remove a callback from the list<br>remove: function() {<br>if ( list ) {<br>var args = arguments,<br>argIndex = 0,<br>argLength = args.length;<br>for ( ; argIndex &lt; argLength ; argIndex++ ) {<br>for ( var i = 0; i &lt; list.length; i++ ) {<br>if ( args[ argIndex ] === list[ i ] ) {<br>// Handle firingIndex and firingLength<br>if ( firing ) {<br>if ( i &lt;= firingLength ) {<br>firingLength--;<br>if ( i &lt;= firingIndex ) {<br>firingIndex--;<br>}<br>}<br>}<br>// Remove the element<br>list.splice( i--, 1 );<br>// If we have some unicity property then<br>// we only need to do this once<br>if ( flags.unique ) {<br>break;<br>}<br>}<br>}<br>}<br>}<br>return this;<br>},<br>// Control if a given callback is in the list<br>has: function( fn ) {<br>if ( list ) {<br>var i = 0,<br>length = list.length;<br>for ( ; i &lt; length; i++ ) {<br>if ( fn === list[ i ] ) {<br>return true;<br>}<br>}<br>}<br>return false;<br>},<br>// Remove all callbacks from the list<br>empty: function() {<br>list = [];<br>return this;<br>},<br>// Have the list do nothing anymore<br>disable: function() {<br>list = stack = memory = undefined;<br>return this;<br>},<br>// Is it disabled?<br>disabled: function() {<br>return !list;<br>},<br>// Lock the list in its current state<br>lock: function() {<br>stack = undefined;<br>if ( !memory || memory === true ) {<br>self.disable();<br>}<br>return this;<br>},<br>// Is it locked?<br>locked: function() {<br>return !stack;<br>},<br>// Call all callbacks with the given context and arguments<br>fireWith: function( context, args ) {<br>if ( stack ) {<br>if ( firing ) {<br>if ( !flags.once ) {<br>stack.push( [ context, args ] );<br>}<br>} else if ( !( flags.once &amp;&amp; memory ) ) {<br>fire( context, args );<br>}<br>}<br>return this;<br>},<br>// Call all the callbacks with the given arguments<br>fire: function() {<br>self.fireWith( this, arguments );<br>return this;<br>},<br>// To know if the callbacks have already been called at least once<br>fired: function() {<br>return !!memory;<br>}<br>};<br><br>return self;<br>};<br><br>})( jQuery );<br><p>这期间有还个小插曲，jQuery团队还想增加一个叫<a href="https://github.com/jquery/jquery/blob/4092e3d2754e3847cd3159edb23184d4cfd4cf03/src/topic.js">Topic</a>的模块，内置发布者订阅者机制，但这封装太溥了，结果被否决。</p><br>(function( jQuery ) {<br><br>var topics = {},<br>sliceTopic = [].slice;<br><br>jQuery.Topic = function( id ) {<br>var callbacks,<br>method,<br>topic = id &amp;&amp; topics[ id ];<br>if ( !topic ) {<br>callbacks = jQuery.Callbacks();<br>topic = {<br>publish: callbacks.fire,<br>subscribe: callbacks.add,<br>unsubscribe: callbacks.remove<br>};<br>if ( id ) {<br>topics[ id ] = topic;<br>}<br>}<br>return topic;<br>};<br><br>jQuery.extend({<br>subscribe: function( id ) {<br>var topic = jQuery.Topic( id ),<br>args = sliceTopic.call( arguments, 1 );<br>topic.subscribe.apply( topic, args );<br>return {<br>topic: topic,<br>args: args<br>};<br>},<br>unsubscribe: function( id ) {<br>var topic = id &amp;&amp; id.topic || jQuery.Topic( id );<br>topic.unsubscribe.apply( topic, id &amp;&amp; id.args ||<br>sliceTopic.call( arguments, 1 ) );<br>},<br>publish: function( id ) {<br>var topic = jQuery.Topic( id );<br>topic.publish.apply( topic, sliceTopic.call( arguments, 1 ) );<br>}<br>});<br><br>})( jQuery );<br><p>虽然把大量代码移动callbacks，但1.7的Deferred却一点没有没变小，它变得更重型，它由三个函数列队组成了。并且返回的是Promise对象，比原来多出了pipe, state, progress, always方法。ajax那边就变成这样：</p><br><br>deferred = jQuery.Deferred(),<br>completeDeferred = jQuery.Callbacks( "once memory" ),<br><br>deferred.promise( jqXHR );<br>jqXHR.success = jqXHR.done;<br>jqXHR.error = jqXHR.fail;<br>jqXHR.complete = completeDeferred.add;<br><p>queue那边也没变多少。</p><br>//1.72<br>(function( jQuery ) {<br><br>function handleQueueMarkDefer( elem, type, src ) {<br>var deferDataKey = type + "defer",<br>queueDataKey = type + "queue",<br>markDataKey = type + "mark",<br>defer = jQuery.<em>data( elem, deferDataKey );<br>if ( defer &amp;&amp;<br>( src === &quot;queue&quot; || !jQuery.</em>data(elem, queueDataKey) ) &amp;&amp;<br>( src === "mark" || !jQuery.<em>data(elem, markDataKey) ) ) {<br>// Give room for hard-coded callbacks to fire first<br>// and eventually mark/queue something else on the element<br>setTimeout( function() {<br>if ( !jQuery.</em>data( elem, queueDataKey ) &amp;&amp;<br>!jQuery.<em>data( elem, markDataKey ) ) {<br>jQuery.removeData( elem, deferDataKey, true );<br>defer.fire();<br>}<br>}, 0 );<br>}<br>}<br><br>jQuery.extend({<br><br></em>mark: function( elem, type ) {<br>if ( elem ) {<br>type = ( type || "fx" ) + "mark";<br>jQuery.<em>data( elem, type, (jQuery.</em>data( elem, type ) || 0) + 1 );<br>}<br>},<br><br><em>unmark: function( force, elem, type ) {<br>if ( force !== true ) {<br>type = elem;<br>elem = force;<br>force = false;<br>}<br>if ( elem ) {<br>type = type || "fx";<br>var key = type + "mark",<br>count = force ? 0 : ( (jQuery.</em>data( elem, key ) || 1) - 1 );<br>if ( count ) {<br>jQuery.<em>data( elem, key, count );<br>} else {<br>jQuery.removeData( elem, key, true );<br>handleQueueMarkDefer( elem, type, "mark" );<br>}<br>}<br>},<br><br>queue: function( elem, type, data ) {<br>var q;<br>if ( elem ) {<br>type = ( type || "fx" ) + "queue";<br>q = jQuery.</em>data( elem, type );<br><br>// Speed up dequeue by getting out quickly if this is just a lookup<br>if ( data ) {<br>if ( !q || jQuery.isArray(data) ) {<br>q = jQuery.<em>data( elem, type, jQuery.makeArray(data) );<br>} else {<br>q.push( data );<br>}<br>}<br>return q || [];<br>}<br>},<br><br>dequeue: function( elem, type ) {<br>type = type || "fx";<br><br>var queue = jQuery.queue( elem, type ),<br>fn = queue.shift(),<br>hooks = {};<br><br>// If the fx queue is dequeued, always remove the progress sentinel<br>if ( fn === "inprogress" ) {<br>fn = queue.shift();<br>}<br><br>if ( fn ) {<br>// Add a progress sentinel to prevent the fx queue from being<br>// automatically dequeued<br>if ( type === "fx" ) {<br>queue.unshift( "inprogress" );<br>}<br><br>jQuery.</em>data( elem, type + ".run", hooks );<br>fn.call( elem, function() {<br>jQuery.dequeue( elem, type );<br>}, hooks );<br>}<br><br>if ( !queue.length ) {<br>jQuery.removeData( elem, type + "queue " + type + ".run", true );<br>handleQueueMarkDefer( elem, type, "queue" );<br>}<br>}<br>});<br><br>jQuery.fn.extend({<br>queue: function( type, data ) {<br>var setter = 2;<br><br>if ( typeof type !== "string" ) {<br>data = type;<br>type = "fx";<br>setter--;<br>}<br><br>if ( arguments.length &lt; setter ) {<br>return jQuery.queue( this[0], type );<br>}<br><br>return data === undefined ?<br>this :<br>this.each(function() {<br>var queue = jQuery.queue( this, type, data );<br><br>if ( type === &quot;fx&quot; &amp;&amp; queue[0] !== &quot;inprogress&quot; ) {<br>jQuery.dequeue( this, type );<br>}<br>});<br>},<br>dequeue: function( type ) {<br>return this.each(function() {<br>jQuery.dequeue( this, type );<br>});<br>},<br>// Based off of the plugin by Clint Helfers, with permission.<br>// http://blindsignals.com/index.php/2009/07/jquery-delay/<br>delay: function( time, type ) {<br>time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;<br>type = type || "fx";<br><br>return this.queue( type, function( next, hooks ) {<br>var timeout = setTimeout( next, time );<br>hooks.stop = function() {<br>clearTimeout( timeout );<br>};<br>});<br>},<br>clearQueue: function( type ) {<br>return this.queue( type || "fx", [] );<br>},<br>// Get a promise resolved when queues of a certain type<br>// are emptied (fx is the type by default)<br>promise: function( type, object ) {<br>if ( typeof type !== "string" ) {<br>object = type;<br>type = undefined;<br>}<br>type = type || "fx";<br>var defer = jQuery.Deferred(),<br>elements = this,<br>i = elements.length,<br>count = 1,<br>deferDataKey = type + "defer",<br>queueDataKey = type + "queue",<br>markDataKey = type + "mark",<br>tmp;<br>function resolve() {<br>if ( !( --count ) ) {<br>defer.resolveWith( elements, [ elements ] );<br>}<br>}<br>while( i-- ) {<br>if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||<br>( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||<br>jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &amp;&amp;<br>jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {<br>count++;<br>tmp.add( resolve );<br>}<br>}<br>resolve();<br>return defer.promise( object );<br>}<br>});<br><br>})( jQuery );<br><p>这时候，钩子机制其实已经在jQuery内部蔓延起来，1.5是css模块的cssHooks，1.6是属性模块的attrHooks, propHooks, boolHooks, nodeHooks,1.7是事件模块的fixHooks， keyHooks, mouseHooks,1.8是queue模块的<em>queueHooks，由于</em>queueHooks，queue终于瘦身了。</p><br>//1.8<br>jQuery.extend({<br>queue: function( elem, type, data ) {<br>var queue;<br><br>if ( elem ) {<br>type = ( type || "fx" ) + "queue";<br>queue = jQuery.<em>data( elem, type );<br><br>// Speed up dequeue by getting out quickly if this is just a lookup<br>if ( data ) {<br>if ( !queue || jQuery.isArray(data) ) {<br>queue = jQuery.</em>data( elem, type, jQuery.makeArray(data) );<br>} else {<br>queue.push( data );<br>}<br>}<br>return queue || [];<br>}<br>},<br><br>dequeue: function( elem, type ) {<br>type = type || "fx";<br><br>var queue = jQuery.queue( elem, type ),<br>fn = queue.shift(),<br>hooks = jQuery.<em>queueHooks( elem, type ),<br>next = function() {<br>jQuery.dequeue( elem, type );<br>};<br><br>// If the fx queue is dequeued, always remove the progress sentinel<br>if ( fn === "inprogress" ) {<br>fn = queue.shift();<br>}<br><br>if ( fn ) {<br><br>// Add a progress sentinel to prevent the fx queue from being<br>// automatically dequeued<br>if ( type === "fx" ) {<br>queue.unshift( "inprogress" );<br>}<br><br>// clear up the last queue stop function<br>delete hooks.stop;<br>fn.call( elem, next, hooks );<br>}<br>if ( !queue.length &amp;&amp; hooks ) {<br>hooks.empty.fire();<br>}<br>},<br><br>// not intended for public consumption - generates a queueHooks object, or returns the current one<br></em>queueHooks: function( elem, type ) {<br>var key = type + "queueHooks";<br>return jQuery.<em>data( elem, key ) || jQuery.</em>data( elem, key, {<br>empty: jQuery.Callbacks("once memory").add(function() {<br>jQuery.removeData( elem, type + "queue", true );<br>jQuery.removeData( elem, key, true );<br>})<br>});<br>}<br>});<br><br>jQuery.fn.extend({<br>queue: function( type, data ) {<br>var setter = 2;<br><br>if ( typeof type !== "string" ) {<br>data = type;<br>type = "fx";<br>setter--;<br>}<br><br>if ( arguments.length &lt; setter ) {<br>return jQuery.queue( this[0], type );<br>}<br><br>return data === undefined ?<br>this :<br>this.each(function() {<br>var queue = jQuery.queue( this, type, data );<br><br>// ensure a hooks for this queue<br>jQuery.<em>queueHooks( this, type );<br><br>if ( type === &quot;fx&quot; &amp;&amp; queue[0] !== &quot;inprogress&quot; ) {<br>jQuery.dequeue( this, type );<br>}<br>});<br>},<br>dequeue: function( type ) {<br>return this.each(function() {<br>jQuery.dequeue( this, type );<br>});<br>},<br>// Based off of the plugin by Clint Helfers, with permission.<br>// http://blindsignals.com/index.php/2009/07/jquery-delay/<br>delay: function( time, type ) {<br>time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;<br>type = type || "fx";<br><br>return this.queue( type, function( next, hooks ) {<br>var timeout = setTimeout( next, time );<br>hooks.stop = function() {<br>clearTimeout( timeout );<br>};<br>});<br>},<br>clearQueue: function( type ) {<br>return this.queue( type || "fx", [] );<br>},<br>// Get a promise resolved when queues of a certain type<br>// are emptied (fx is the type by default)<br>promise: function( type, obj ) {<br>var tmp,<br>count = 1,<br>defer = jQuery.Deferred(),<br>elements = this,<br>i = this.length,<br>resolve = function() {<br>if ( !( --count ) ) {<br>defer.resolveWith( elements, [ elements ] );<br>}<br>};<br><br>if ( typeof type !== "string" ) {<br>obj = type;<br>type = undefined;<br>}<br>type = type || "fx";<br><br>while( i-- ) {<br>if ( (tmp = jQuery.</em>data( elements[ i ], type + &quot;queueHooks&quot; )) &amp;&amp; tmp.empty ) {<br>count++;<br>tmp.empty.add( resolve );<br>}<br>}<br>resolve();<br>return defer.promise( obj );<br>}<br>});<br><p>同时，动画模块迎来了它第三次大重构，它也有一个钩子Tween.propHooks。它多出两个对象，其中Animation返回一个异步列队，Tween 是用于处理单个样式或属性的变化，相当于之前Fx对象。animate被抽空了，它在1.72可是近百行的规模。jQuery通过钩子机制与分化出一些新的对象，将一些巨型方法重构掉。现在非常长的方法只龟缩在节点模块，回调模块。</p><br><br>animate: function( prop, speed, easing, callback ) {<br>var empty = jQuery.isEmptyObject( prop ),<br>optall = jQuery.speed( speed, easing, callback ),<br>doAnimation = function() {<br>// Operate on a copy of prop so per-property easing won't be lost<br>var anim = Animation( this, jQuery.extend( {}, prop ), optall );<br><br>// Empty animations resolve immediately<br>if ( empty ) {<br>anim.stop( true );<br>}<br>};<br><br>return empty || optall.queue === false ?<br>this.each( doAnimation ) :<br>this.queue( optall.queue, doAnimation );<br>},<br><p>到目前为止，所有异步的东西都被jQuery改造成异步列队的“子类”或叫“变种”更合适些。如domReady, 动画，AJAX，与执行了promise或delay或各种特效方法之后的jQuery对象。于是所有异步的东西在promise的加护下，像同步那样编写异步程序。</p><div>http://www.bitstorm.org/weblog/2012-1/Deferred_and_promise_in_jQuery.htmlhttp://hamalog.tumblr.com/post/5159447047/jquery-deferred</div><img src="http://www.cnblogs.com/rubylouvre/aggbug/2765576.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/rubylouvre/archive/2012/11/13/2765576.html">本文链接</a></p></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
