<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>[译]JavaScript:函数的作用域链</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>[译]JavaScript:函数的作用域链</h2>
<p class="meta">2012-11-18 07:02</p>

<div class="post">
<h2>[译]JavaScript:函数的作用域链</h2>

<h3>by 紫云飞</h3>

<h3>at 2012-11-17 23:02:00</h3>

<h3>original <a href="http://www.cnblogs.com/ziyunfei/archive/2012/11/17/2768967.html">http://www.cnblogs.com/ziyunfei/archive/2012/11/17/2768967.html</a></h3>

<p><span style="font-family:Calibri">原文:<a href="http://blogs.msdn.com/b/jscript/archive/2007/07/26/scope-chain-of-jscript-functions.aspx">http://blogs.msdn.com/b/jscript/archive/2007/07/26/scope-chain-of-jscript-functions.aspx</a><br></span></p>


<hr><p><span style="font-family:Calibri">在JavaScript中,函数的作用域链是一个很难理解的东西.这是因为,JavaScript中函数的作用域链和其他语言比如<span style="font-family:Calibri">C, C++</span>中函数的作用域链相差甚远.本文详细解释了JavaScript中与函数的作用域链相关的知识,理解这些知识可以帮助你在处理闭包的时候避免一些可能出现的问题.</span></p><p><span style="font-family:Calibri">在JavaScript中,函数可以让你在一次调用中执行一系列的操作.有多种方式来定义一个函数,如下: </span></p><p><span style="font-family:Calibri"><strong><span><span style="font-family:Calibri">函数声明:</span></span></strong></span></p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> maximum(x, y) {<br>    </span><span style="color:#0000ff">if</span> (x &gt; y) <span style="color:#0000ff">return</span><span style="color:#000000"> x;<br>    </span><span style="color:#0000ff">else</span> <span style="color:#0000ff">return</span><span style="color:#000000"> y;<br>}<br><br>maximum(</span>5, 6) <span style="color:#008000">//</span><span style="color:#008000">返回6;</span></div><p><span style="font-family:Calibri">这种语法通常用来定义全局作用域下的函数(全局函数).</span></p><p><span style="font-family:Calibri"><span><span style="font-family:Calibri"><strong>函数表达式</strong>:</span></span></span></p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> obj = <span style="color:#0000ff">new</span><span style="color:#000000"> Object();<br>obj.maximum </span>= <span style="color:#0000ff">function</span><span style="color:#000000"> (x, y) {<br>    </span><span style="color:#0000ff">if</span> (x &gt; y) <span style="color:#0000ff">return</span><span style="color:#000000"> x;<br>    </span><span style="color:#0000ff">else</span> <span style="color:#0000ff">return</span><span style="color:#000000"> y;<br>};<br><br>obj.maximum(</span>5, 6) <span style="color:#008000">//</span><span style="color:#008000">返回6;</span></div><p><span style="font-family:Calibri">这种语法通常用来定义一个作为对象方法的函数.</span></p><p><span style="font-family:&#39;Courier New&#39;"><strong><span><span style="font-family:Calibri">Function构造函数</span></span></strong><span style="font-family:&#39;Courier New&#39;">:</span></span></p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> maximum = <span style="color:#0000ff">new</span> Function(&quot;x&quot;, &quot;y&quot;, &quot;if(x &gt; y) return x; else return y;&quot;<span style="color:#000000">);<br>maximum(</span>5, 6); <span style="color:#008000">//返回</span><span style="color:#008000">6;</span></div><p><span style="font-family:Calibri">以这种形式定义函数通常没有很好的可读性(没有缩进),只在特定情况下使用.</span></p><p><strong><span style="font-family:Calibri"><strong><span style="font-family:Calibri"><span>函数定义</span><span>:</span></span></strong></span></strong></p><p><span style="font-family:Calibri">函数定义指的是在JavaScript引擎内部创建一个函数对象的过程.<span style="font-family:Calibri">如果是全局函数的话,</span>这个函数对象会作为属性添加到全局对象上,<span style="font-family:Calibri">如果是内部函数(嵌套函数)的话</span>,该函数对象会作为属性添加到</span><span style="font-family:Calibri">上层函数的活动对象</span><span style="font-family:Calibri">上,属性名就是函数名.需要指出的是,如果函数是以函数声明的方式定义的,则函数的定义操作会发生在脚本解析的时候.如下例中,当JavaScript引擎完成脚本解析时,就已经创建了一个函数对象func,该函数对象作为属性添加到了全局对象中,属性名为"func".</span></p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#008000">/*f</span><span style="color:#008000">unc函数可以被访问到,因为在脚本开始执行前func函数就已经存在了.</span><span style="color:#008000">*/</span><span style="color:#000000"><br>alert(func(</span>2)); <span style="color:#008000">//返回</span><span style="color:#008000">8</span><span style="color:#008000"><br><br>//执行该语句会覆盖</span><span style="color:#008000">func的值为true.</span><br><span style="color:#0000ff">var</span> func = <span style="color:#0000ff">true</span><span style="color:#000000">;<br><br>alert(func); </span><span style="color:#008000">//返回"</span><span style="color:#008000">true";</span><span style="color:#008000"><br><br>/*在脚本开始执行前,解析下面的语句就会定义一个函数对象</span><span style="color:#008000">func.</span><span style="color:#008000">*/</span><br><span style="color:#0000ff">function</span><span style="color:#000000"> func(x) {<br>    </span><span style="color:#0000ff">return</span> x * x *<span style="color:#000000"> x;<br>}</span></div><p><span style="font-family:Calibri">在下面的例子中,存在内部函数的情况.内部函数innerFn的定义操作发生在外部函数outerFn执行的时候(其实也是发生在执行前的解析阶段),同时,内部函数会作为属性添加到外部函数的活动对象上.</span></p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> outerFn() {<br>    </span><span style="color:#0000ff">function</span><span style="color:#000000"> innerFn() {}<br>}<br>outerFn(); </span><span style="color:#008000">//执行</span><span style="color:#008000">outerFn函数的时候会定义一个函数innerFn</span></div><p><span><span style="font-family:Calibri"><strong>注</strong>:<span>  对于使用</span>Function构造函数定义的函数来说,函数定义操作就发生在执行Function构造函数的时候.</span></span></p><p><strong><span style="font-family:Calibri">作用域链<span>:</span></span></strong></p><p><span><span style="font-family:Calibri">函数的作用域链是由一系列对象(函数的活动对象+0个到多个的上层函数的活动对象+最后的全局对象)组成的,在函数执行的时候,会按照先后顺序从这些对象的属性中</span></span><span><span style="font-family:Calibri">寻找函数体中用到的标识符的值(标识符解析)</span></span><span><span style="font-family:Calibri">.函数会在定义时将它们各自所处环境(全局上下文或者函数上下文)的作用域链存储到自身的[[scope]]内部属性中. 首先看一个内部函数的例子: </span></span></p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> outerFn(i) {<br>    </span><span style="color:#0000ff">return</span> <span style="color:#0000ff">function</span><span style="color:#000000"> innerFn() {<br>        </span><span style="color:#0000ff">return</span><span style="color:#000000"> i;<br>    }<br>}<br></span><span style="color:#0000ff">var</span> innerFn = outerFn(4<span style="color:#000000">);<br>innerFn(); </span><span style="color:#008000">//</span><span style="color:#008000">返回4</span></div><p><span style="font-family:Calibri">当innerFn函数执行时,成功返回了变量i的值4,但变量i既不存在于<span style="font-family:Calibri">innerFn</span>函数自身的局部变量中,也不存在于全局作用域中.那么变量i的值是从哪儿得到的? 你也许认为内部函数<span style="font-family:Calibri">innerFn</span>的作用域链是由innerFn函数的活动对象+全局对象组成的.但这是不对的,只有全局函数的作用域链包含两个对象,这并不适用于内部函数.让我们先分析全局函数,然后再分析内部函数.</span></p><p><strong><span><span style="font-family:Calibri"><strong>全局函数</strong>:</span></span></strong></p><p><span style="font-family:Calibri">全局函数的作用域链很好理解. </span></p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> x = 10<span style="color:#000000">;<br></span><span style="color:#0000ff">var</span> y = 0<span style="color:#000000">;<br><br></span><span style="color:#0000ff">function</span><span style="color:#000000"> testFn(i) {<br>    </span><span style="color:#0000ff">var</span> x = <span style="color:#0000ff">true</span><span style="color:#000000">;<br>    y </span>= y + 1<span style="color:#000000">;<br>    alert(i);<br>}<br>testFn(</span>10);</div><p><img src="http://pic002.cnblogs.com/images/2012/116671/2012111416050462.gif" alt=""></p><p><span><span style="font-family:Calibri">全局对象: JavaScript引擎在脚本开始执行之前就会创建全局对象,并添加到一些预定义的属性"Infinity", "Math"等.在脚本中定义的全局变量也会成为全局对象的属性. </span></span></p><p><span><span style="font-family:Calibri">活动对象<strong>: </strong>当JavaScript引擎调用一些函数时,该函数会创建一个新的活动对象,所有在函数内部定义的局部变量以及传入函数的命名参数和</span></span><span style="font-family:Calibri">arguments对象都会作为这个活动对象的属性.这个活动对象加上该函数的[[scope]]内部属性中存储的作用域链就组成了本次函数调用的作用域链.</span></p><p><strong><span><span style="font-family:Calibri"><strong>内部函数</strong>:</span></span></strong></p><p><span style="font-family:Calibri">让我们分析一下下面的JavaScript代码.</span></p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> outerFn(i, j) {<br>    </span><span style="color:#0000ff">var</span> x = i +<span style="color:#000000"> j;<br>    </span><span style="color:#0000ff">return</span> <span style="color:#0000ff">function</span><span style="color:#000000"> innerFn(x) {<br>        </span><span style="color:#0000ff">return</span> i +<span style="color:#000000"> x;<br>    }<br>}<br></span><span style="color:#0000ff">var</span> func1 = outerFn(5, 6<span style="color:#000000">);<br></span><span style="color:#0000ff">var</span> func2 = outerFn(10, 20<span style="color:#000000">);<br>alert(func1(</span>10)); <span style="color:#008000">//</span><span style="color:#008000">返回15</span><br>alert(func2(10)); <span style="color:#008000">//返回</span><span style="color:#008000">20</span></div><p><span><span style="font-family:Calibri">在调用</span></span><span><span style="font-family:Calibri">func1(10)和func2(10)时,你引用到了</span></span><span><span style="font-family:Calibri">两个不同的</span></span><span><span style="font-family:Calibri">i .这是怎么回事?</span></span><span style="font-family:Calibri">首先看下面的语句,</span></p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> func1 = outerFn(5,6);</div><p><span style="font-family:Calibri">调用outerFn (5, 6)的时候定义了一个新的函数对象innerFn,然后该函数对象成为了outerFn函数的活动对象的一个属性.这时<span style="font-family:Calibri">innerFn</span>的作用域链是由outerFn的活动对象和全局对象组成的. 这个作用域链存储在了innerFn函数的内部属性[[scope]]中,然后返回了该函数,变量func1就指向了这个<span style="font-family:Calibri">innerFn</span>函数.</span></p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">alert(func1(10));<span style="color:#008000">//</span><span style="color:#008000">返回15</span></div><p><span><span style="font-family:Calibri">在func1被调用时,它自身的活动对象被创建,然后添加到了[[scope]]中存储着的作用域链的最前方(新的作用域链,并不会改变<span><span style="font-family:Calibri">[[scope]]</span></span>中存储着的那个作用域链).这时的作用域链才是func1函数执行时用到的作用域链.从这个作用域链中,你可以看到变量‘i’的值实际上就是在执行outerFn(5,6)时产生的活动对象的属性i的值.下图显示了整个流程.  </span></span></p><p><img src="http://pic002.cnblogs.com/images/2012/116671/2012111517203821.jpg" alt=""><span style="font-family:Calibri">                                                                                           </span></p><p><span style="font-family:Calibri">现在让我们回到问题,"</span><span style="font-family:Calibri">在调用func1(10)和func2(10)时,你引用到了两个不同的i .这是怎么回事?".让我们从下图中看一下func2执行时的情况,答案就是在定义</span><span style="font-family:Calibri">func1和func2时,函数</span><span style="font-family:Calibri">outerFn中产生过两个不同的活动对象. </span></p><p><img src="http://pic002.cnblogs.com/images/2012/116671/2012111517265189.jpg" alt=""></p><p><span style="font-family:Calibri">现在又出现了一个问题, 一个活动对象在函数执行的时候创建,但在函数执行完毕返回的时候不会被销毁吗? 我用下面的三个例子来讲解这个问题.</span></p><p><span style="font-family:Calibri">i)</span> 没有内部函数的函数<span><span style="font-family:Calibri">                 <br></span></span></p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> outerFn(x) {<br>    </span><span style="color:#0000ff">return</span> x *<span style="color:#000000"> x;<br>}<br></span><span style="color:#0000ff">var</span> y = outerFn(2);</div><p><span style="font-family:Calibri">如果函数没有内部函数,则在该函数执行时,当前活动对象会被添加到该函数的作用域链的最前端.作用域链是唯一引用这个活动对象的地方.当函数退出时,活动对象会被从作用域链上删除,由于再没有任何地方引用这个活动对象,则它随后会被垃圾回收器销毁.</span></p><p><span style="font-family:Calibri">ii)</span> 包含内部函数的函数,但这个内部函数没有被外部函数之外的变量所引用</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> outerFn(x) {<br>    </span><span style="color:#008000">//在<span style="color:#008000">outerFn</span>外部没有指向</span><span style="color:#008000">square的<span style="color:#008000">引用</span> </span><br>    <span style="color:#0000ff">function</span><span style="color:#000000"> square(x) {<br>        </span><span style="color:#0000ff">return</span> x *<span style="color:#000000"> x;<br>    }<br>    </span><span style="color:#008000">//<span style="color:#008000">在<span style="color:#008000">outerFn</span>外部没有指向</span><span style="color:#008000">cube的<span style="color:#008000">引</span></span></span><span style="color:#008000">用</span><br>    <span style="color:#0000ff">function</span><span style="color:#000000"> cube(x) {<br>        </span><span style="color:#0000ff">return</span> x * x *<span style="color:#000000"> x;<br>    }<br>    </span><span style="color:#0000ff">var</span> temp =<span style="color:#000000"> square(x);<br>    </span><span style="color:#0000ff">return</span> temp / 2<span style="color:#000000">;<br>}<br></span><span style="color:#0000ff">var</span> y = outerFn(5);</div><p><span style="font-family:Calibri">在这种情况下,函数执行时创建的活动对象不仅添加到了当前函数的作用域链的前端,而且还添加到了内部函数的作用域链中.当该函数退出时,活动对象会从当前函数的作用域链中删除,活动对象和内部函数互相引用着对方,<span style="font-family:Calibri">outerFn</span>函数的活动对象引用着嵌套的函数对象square和cube,内部函数对象square和cube的作用域链中引用了outerFn函数的活动对象.但由于它们都没有外部引用,所以都将会被<span style="font-family:Calibri">垃圾回收器回收.</span></span></p><p><span style="font-family:Calibri">iii)</span>  包含内部函数的函数,但外部函数之外存在指向这个内部函数的引用</p><p><span style="font-family:Calibri">例1: </span></p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> outerFn(x) {<br>    </span><span style="color:#008000">//内部函数作为</span><span style="color:#008000">outerFn的返回值被引用到了外部</span><br>    <span style="color:#0000ff">return</span> <span style="color:#0000ff">function</span><span style="color:#000000"> innerFn() {<br>        </span><span style="color:#0000ff">return</span> x *<span style="color:#000000"> x;<br>    }<br>}<br><br></span><span style="color:#008000">//引用着返回的内部函数</span><br><span style="color:#0000ff">var</span> square = outerFn(5<span style="color:#000000">);<br>square();<br></span></div><p>例2:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span><span style="color:#000000"> square;<br><br></span><span style="color:#0000ff">function</span><span style="color:#000000"> outerFn(x) {<br>    </span><span style="color:#008000">//通过全局变量引用到了内部函数</span><br>    square = <span style="color:#0000ff">function</span><span style="color:#000000"> innerFn() {<br>        </span><span style="color:#0000ff">return</span> x *<span style="color:#000000"> x;<br>    }<br>}<br>outerFn(</span>5<span style="color:#000000">);<br>square();</span></div><p><span style="font-family:Calibri">在这种情况下,outerFn<span style="font-family:Calibri">函数执行时创建的活动对象不仅添加到了当前函数的作用域链的前端,而且还添加到了内部函数innerFn的作用域链中(innerFn的[[scope]]内部属性)</span>.当外部函数<span style="font-family:Calibri">outerFn</span>退出时,虽然它的活动对象从当前作用域链中删除了,但内部函数<span style="font-family:Calibri"><span style="font-family:Calibri">innerFn</span></span>的作用域链仍然引用着它. 由于内部函数<span style="font-family:Calibri"><span style="font-family:Calibri">innerFn</span></span>存在一个外部引用square,且内部函数<span style="font-family:Calibri"><span style="font-family:Calibri"><span style="font-family:Calibri">innerFn</span></span></span>的作用域链仍然引用着外部函数<span style="font-family:Calibri">outerFn</span>的活动对象,所以在调用<span style="font-family:Calibri"><span style="font-family:Calibri"><span style="font-family:Calibri"><span style="font-family:Calibri">innerFn</span></span></span></span>时,仍然可以访问到<span style="font-family:Calibri"><span style="font-family:Calibri">outerFn</span></span>的活动对象上存储着的变量x的值.</span></p><p><strong><strong><span style="font-family:Calibri">多个内部函数:</span></strong></strong></p><p><span style="font-family:Calibri">更有趣的场景是有不止一个的内部函数,多个内部函数的作用域链引用着同一个外部函数的活动对象.该活动对象的改变会反应到三个内部函数上.</span></p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> createCounter(i) {<br>    </span><span style="color:#0000ff">function</span><span style="color:#000000"> increment() {<br>        </span>++<span style="color:#000000">i;<br>    }<br><br>    </span><span style="color:#0000ff">function</span><span style="color:#000000"> decrement() {<br>        </span>--<span style="color:#000000">i;<br>    }<br><br>    </span><span style="color:#0000ff">function</span><span style="color:#000000"> getValue() {<br>        </span><span style="color:#0000ff">return</span><span style="color:#000000"> i;<br>    }<br><br>    </span><span style="color:#0000ff">function</span><span style="color:#000000"> Counter(increment, decrement, getValue) {<br>        </span><span style="color:#0000ff">this</span>.increment =<span style="color:#000000"> increment;<br>        </span><span style="color:#0000ff">this</span>.decrement =<span style="color:#000000"> decrement;<br>        </span><span style="color:#0000ff">this</span>.getValue =<span style="color:#000000"> getValue;<br>    }<br>    </span><span style="color:#0000ff">return</span> <span style="color:#0000ff">new</span><span style="color:#000000"> Counter(increment, decrement, getValue);<br>}<br></span><span style="color:#0000ff">var</span> counter = createCounter(5<span style="color:#000000">);<br>counter.increment();<br>alert(counter.getValue()); </span><span style="color:#008000">//返回</span><span style="color:#008000">6</span></div><p><img src="http://pic002.cnblogs.com/images/2012/116671/2012111517354929.jpg" alt=""></p><p><span style="font-family:Calibri">上图表示了createCounter函数的活动对象被三个内部函数的作用域链所共享.</span></p><p><strong><strong><span style="font-family:Calibri">闭包以及循环引用</span></strong><span style="font-family:Calibri"><span>:</span></span></strong></p><p><span style="font-family:Calibri">上面讨论了JavaScript中函数的作用域链,下面谈一下在闭包中可能出现因循环引用而产生内存泄漏的问题.闭包通常指得是能够在外部函数外面被调用的内部函数.下面给出一个例子:</span></p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> outerFn(x) {<br>    x.func </span>= <span style="color:#0000ff">function</span><span style="color:#000000"> innerFn() {}<br>}<br></span><span style="color:#0000ff">var</span> div = document.createElement("DIV"<span style="color:#000000">);<br>outerFn(div);</span></div><p><span style="font-family:Calibri">在上例中,一个DOM对象和一个JavaScript对象之间就存在着循环引用. DOM 对象div通过属性<span style="font-family:Calibri">‘func’</span>引用着内部函数innerFn.内部函数innerFn的作用域链(<span style="font-family:Calibri">存储在<span style="font-family:Calibri">内部属性<span style="font-family:Calibri">[[scope]]上</span></span></span>)上的活动对象的属性‘x’ 引用着DOM对象<span style="font-family:Calibri">div</span>. 这样的循环引用就可能造成内存泄漏</span><span style="font-family:Calibri">.</span></p><blockquote><p><span style="font-family:Calibri">译者注:猜测作者是为了使文章更易懂,故意不提及执行上下文的概念,本文中出现[[scope]]内部属性的地方也是我加的.<br></span></p></blockquote><img src="http://www.cnblogs.com/ziyunfei/aggbug/2768967.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/ziyunfei/archive/2012/11/17/2768967.html">本文链接</a></p>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
