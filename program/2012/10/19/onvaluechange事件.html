<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>onvaluechange事件</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>onvaluechange事件</h2>
<p class="meta">19 Oct 2012</p>

<div class="post">
<h2>onvaluechange事件</h2>

<h3>by 司徒正美</h3>

<h3>at 2012-10-19 07:47:00</h3>

<h3>original <a href="http://www.cnblogs.com/rubylouvre/archive/2012/10/19/2730355.html">http://www.cnblogs.com/rubylouvre/archive/2012/10/19/2730355.html</a></h3>

<p>这不是一个真实的浏览器事件，不过的确曾经存在这样一个事件满足我们的需求。</p>


<p>很多时候，我们需要对文本域的值进行变化检测，不论是这变化是用户通过键盘敲打引发的，或是通过el.setAttribute("value","aaa")引发的，还是el.value = "bbb"引发的，还是用户通过复制粘贴引发的，更恶心的是HTML通过语音输入引发的。只要里面的文字发生变化，我们希望都能比较及时调用相应的程序进行处理。</p>


<p>在旧式IE（IE6-8）下，onpropertychange可以满足上述所有需求（由于IE不支持input[speed]），因此不用考虑最后一种输入）。</p>


<p>IE9开始区分attribute和property了，从许多场合来是好事，但在这场合则是坏事，它相当于DOM3变动事件中的DOMAttrModified。只对用户输入与setAttribute见效，不支持直接赋值方式的检测。</p>


<p>标准浏览器也提供了一个input,但它也不支持直接赋值方式的检测。即便最新式的mutationObserver API，对el.value ="zzz"这种属性赋值法也无济于事。因此自己动手富衣足食。</p>


<p>取一个文本域的值最简单不过，对两个字符串进行比较也最简单不过。我们要做的是得到先后两个值。因此需要用最通用的事件进行冒允。当我们在PC上输入内容，肯定会触发mousedown事件，也肯定触发mousedown。进行输入时确定会触发键盘事件，根据我的知识库，keypress会对一些系统键失灵，因此最好用keyup,keydown。但用户不一定通过键盘输入，HTML5还提供了语音输入，只要点了那个麦风筒图案就可以口述了，麦风筒也在input上，因此mousedown肯定也有。当我们输入后肯定会继续其他表单元素的填写或进行提交，因此会触发blur事件。从mousedown到blur这段时间，我们可以通过定时器加keydown, keyup， webkitspeechchange的回调进行值变化判定，变化了就执行用户回调，把前后两个值放到事件对象中。</p>


<p>下面是mass Framework的实现：</p>


<p><br>define("valuechange", ["$event"], function(){<br>    var DATA = "valuechangeData";<br>    var ID  = "valuechangeID"<br>    var interval = 50;<br>    //如果值前后发生改变,触发绑定回调<br>    function testChange(elem, type, poll) {<br>        if(poll){<br>            $.<em>data(elem, ID, setTimeout(function(){<br>                testChange(elem, type, poll);<br>            },interval));<br>        }<br>        var old = $.</em>data(elem, DATA);<br>        var neo = elem.value;<br>        if(old !== neo){<br>            $.<em>data(elem, DATA, neo);<br>            var event = new $.Event("valuechange")<br>            event.oldType = type<br>            event.oldValue = old;<br>            event.newValue = neo;<br>            $.event.fire.call(elem, event)<br>        }<br>    }<br>    function unTestChange(elem){<br>        var id = $.</em>removeData(elem, ID)<br>        clearTimeout( id )<br>        $.log($.<em>removeData)<br>        $.</em>removeData(elem, DATA);<br>    }<br>   <br>    function startTest(event) {<br>        var elem = event.target;<br>        if (event.type == 'focus' ) {<br>            $.<em>data(elem, DATA , elem.value);<br>        }<br>        testChange(elem,event.type, true);<br>    }<br>    function stopTest(event){<br>        unTestChange(event.target)<br>    }<br>    <br>    function listen(elem) {<br>        unlisten(elem);<br>        "keydown keyup mousedown focus".replace($.rword, function(name){<br>            $(elem).bind(name+".</em>valuechange", startTest)<br>        })<br>        $(elem).bind('blur.<em>valuechange', stopTest);<br>        //http://liumiao.me/html/wd/W3C/264.html<br>        $(elem).bind('webkitspeechchange.</em>valuechange', function(e){<br>            testChange(e.target,e.type)<br>        });<br>    }<br>    function unlisten(elem){<br>        unTestChange(elem)<br>        $(elem).unbind("._valuechange")<br>    }<br>    $.fn.valuechange = function(callback){<br>         return callback?  this.bind( "valuechange", callback ) : this.fire( "valuechange" );<br>    }<br>    $.eventAdapter.valuechange = {<br>        setup: function(desc){<br>            var elem = desc.currentTarget, nodeName = elem.tagName;<br>            if (nodeName == 'INPUT' || nodeName == 'TEXTAREA') {<br>                listen(elem);<br>                return false<br>            }<br>        },<br>        tearDown: function (desc) {<br>            unlisten(desc.currentTarge);<br>            return false<br>        }<br>    }<br>})<br><p>它的事件系统的架构与jQuery的很相近，都是通过setup， teardown方法来绑定特殊的事件。我们只对INPUT元素及文本区进行操作，一定进入分支，就调用listen监听函数。接下来绑定的事件的作用依次是：</p><ul><li>mousedown:监听粘贴。</li><li>keyup,keydown:监听键盘输入。</li><li>focus：监听一切引发聚焦的事件，比如在触摸屏下。</li><li>webkitspeechchange：监听语音输入。</li><li>blur：清理定时器，比如虽然已经放在文本域中啊，但长期没有动，那么只有等keyup再次触发新的定时器了。</li></ul><p>具体例子可见<a href="http://rubylouvre.github.com/doc/event/$.fn.valuechange.html">这里</a>。</p><p>有了这个onvaluechange事件，以后做表单验证或自动完成及MVVM的输入双向绑定就轻松多了。</p><img src="http://www.cnblogs.com/rubylouvre/aggbug/2730355.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/rubylouvre/archive/2012/10/19/2730355.html">本文链接</a></p></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
