<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>[译]JavaScript中的属性</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>[译]JavaScript中的属性</h2>
<p class="meta">2012-10-30 23:17</p>

<div class="post">
<h2>[译]JavaScript中的属性</h2>

<h3>by 紫云飞</h3>

<h3>at 2012-10-30 15:17:00</h3>

<h3>original <a href="http://www.cnblogs.com/ziyunfei/archive/2012/10/30/2745786.html">http://www.cnblogs.com/ziyunfei/archive/2012/10/30/2745786.html</a></h3>

<p>原文:<a href="http://www.2ality.com/2012/10/javascript-properties.html">http://www.2ality.com/2012/10/javascript-properties.html</a></p>


<hr><p>在JavaScript中,属性决定了一个对象的状态,本文详细的研究了它们是如何工作的.</p><h3>属性类型<p>JavaScript中有三种不同类型的属性:命名数据属性(named data properties),命名访问器属性(named accessor properties)以及内部属性(internal properties).</p><p><strong>命名数据属性</strong></p><p>这种属性就是我们通常所用的"普通"属性,它用来将一个字符串名称映射到某个值上.比如,下面的对象<tt>obj有一个名为字符串</tt><tt>"prop"的数据属性,该属性的值为数字</tt>123.</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> obj =<span style="color:#000000"> {<br>    prop: </span>123<span style="color:#000000"><br>};</span></div><p>你可以获取(读取)到一个属性的值:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">console.log(obj.prop); <span style="color:#008000">//</span><span style="color:#008000"> 123</span><br>console.log(obj["prop"]); <span style="color:#008000">//</span><span style="color:#008000"> 123</span></div><p>你还可以设置(写入)一个属性的值:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">obj.prop = "abc"<span style="color:#000000">;<br>obj[</span>"prop"] = "abc";</div><p><strong>命名访问器属性</strong></p><p>另外,还可以借助函数来获取或设置一个属性的值.这些函数称之为访问器函数(accessor function).控制属性读取的访问器函数称之为getter.控制属性写入的访问器函数称之为setter.</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> obj =<span style="color:#000000"> {<br>    get prop() {<br>        </span><span style="color:#0000ff">return</span> "Getter"<span style="color:#000000">;<br>    },<br>    set prop(value) {<br>        console.log(</span>"Setter: "+<span style="color:#000000">value);<br>    }<br>}</span></div><p>让我们操作<tt>一下obj的属性</tt>:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt;<span style="color:#000000"> obj.prop<br></span>'Getter'<br>&gt; obj.prop = 123<span style="color:#000000">;<br>Setter: </span>123</div><p><strong>内部属性</strong></p><p>有一些属性仅仅是为规范所用的,称之为内部属性,因为它们无法通过JavaScript直接访问到,但是它们的确存在,并且影响着程序的表现.内部属性的名称比较特殊,它们都被两个中括号包围着.下面有两个例子:</p><ul><li>内部属性[[Prototype]]指向了所属对象的原型.该属性的值可以通过<tt>Object.getPrototypeOf()函数读取到</tt>.该属性的值只能在创建一个新对象的时候通过<tt>Object.create()或者</tt><tt>__proto__来设置</tt> <sup><a href="http://www.cnblogs.com/ziyunfei/#a1">[1]</a></sup>.</li><li>内部属性[[Extensible]]决定了是否能给所属对象添加新的属性.该属性的值可以通过<tt>Object.isExtensible()读取到</tt>.还可以通过<tt>Object.preventExtensions()将该属性的值设置为false</tt>.一旦设置为<tt>false</tt>,就无法再设置回<tt>true了</tt>.</li></ul><p><strong>属性特性</strong></p><p>一个属性的所有状态,包括它的数据和元数据,都存储在该属性的特性(attributes)中.属性拥有自己的特性,就像对象拥有自己的属性一样.特性的名称经常写成类似内部属性的形式(双中括号).</p><p>下面是命名数据属性拥有的特性:</p><ul><li>[[Value]] 存储着属性的值,也就是属性的数据.</li><li>[[Writable]] 存储着一个布尔值,表明该属性的值是否可以改变.</li></ul><p>下面是命名访问器属性拥有的特性:</p><ul><li>[[Get]] 存储着<em>getter</em>,也就是在读取这个属性时调用的函数.该函数返回的值也就是这个属性的值.</li><li>[[Set]] 存储着<em>setter</em>,也就是在为这个属性赋值时调用的函数.该函数在调用时会被传入一个参数,参数的值为所赋的那个新值.</li></ul><p>下面是两种类型的属性都有的特性:</p><ul><li>[[Enumerable]] 存储着一个布尔值.可以让一个属性不能被枚举,在某些操作下隐藏掉自己(下面会有详细讲解).</li><li>[[Configurable]] 存储着一个布尔值.如果为false,则你不能删除这个属性,不能改变这个属性的大部分特性(除了[[Value]]),不能将一个数据属性重定义成访问器属性,或者反之.换句话说就是:[[Configurable]]控制了一个属性的元数据的可写性.</li></ul><p><strong>默认值</strong></p><p>如果你不明确的指定某个特性的值,则它们会被赋一个默认值:</p><table><tbody><tr><td><strong>特性名称</strong></td><td><strong>默认值</strong></td></tr><tr><td>[[Value]]</td><td><tt>undefined</tt></td></tr><tr><td>[[Get]]</td><td><tt>undefined</tt></td></tr><tr><td>[[Set]]</td><td><tt>undefined</tt></td></tr><tr><td>[[Writable]]</td><td><tt>false</tt></td></tr><tr><td>[[Enumerable]]</td><td><tt>false</tt></td></tr><tr><td>[[Configurable]]</td><td><tt>false</tt></td></tr></tbody></table><p>这些默认值对于属性描述符尤其重要.</p><p><strong>属性描述符</strong></p><p>属性描述符(property descriptor)可以将一个属性的所有特性编码成一个对象并返回.该对象的每个属性都对应着所属属性的一个特性.例如,下面是一个值为123的只读属性的属性描述符:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#000000">{<br>    value: </span>123<span style="color:#000000">,<br>    writable: </span><span style="color:#0000ff">false</span><span style="color:#000000">,<br>    enumerable: </span><span style="color:#0000ff">true</span><span style="color:#000000">,<br>    configurable: </span><span style="color:#0000ff">false</span><span style="color:#000000"><br>}</span></div><p>你也可以使用一个访问器属性来实现上面这个拥有只读特性的数据属性,其属性描述符如下:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#000000">{<br>    get: </span><span style="color:#0000ff">function</span> () { <span style="color:#0000ff">return</span> 123<span style="color:#000000"> },<br>    </span><span style="color:#008000">//</span><span style="color:#008000">没有set,也就是只读</span><br>    enumerable: <span style="color:#0000ff">true</span><span style="color:#000000">,<br>    configurable: </span><span style="color:#0000ff">false</span><span style="color:#000000"><br>}</span></div><p><strong>使用属性描述符的函数</strong></p><p>在使用下面的函数时会用到属性描述符:</p><ul><li><tt>Object.defineProperty(obj, propName, propDesc)</tt><br>        创建或改变对象<tt>obj的</tt><tt>propName属性,</tt><tt>propName</tt><tt>属性的特性通过属性描述符</tt><tt>propDesc给出</tt>.返回修改后的obj对象.例如:<div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> obj = Object.defineProperty({}, "foo"<span style="color:#000000">, {<br>    value: </span>123<span style="color:#000000">,<br>    enumerable: </span><span style="color:#0000ff">true</span><br>    <span style="color:#008000">//</span><span style="color:#008000"> writable和configurable为默认值</span><br>});</div></li><li><tt>Object.defineProperties(obj, propDescObj)</tt><br>        <tt>Object.defineProperty()的批处理版本</tt>.对象<tt>propDescObj的每个属性都指定了要给原对象obj添加或修改的一个属性和对应的属性描述符</tt><tt>.</tt>例如:<div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> obj =<span style="color:#000000"> Object.definePropertys({}, {<br>    foo: { value: </span>123, enumerable: <span style="color:#0000ff">true</span><span style="color:#000000"> },<br>    bar: { value: </span>"abc", enumerable: <span style="color:#0000ff">true</span><span style="color:#000000"> }<br>});</span></div></li><li><tt>Object.create(proto, propDescObj?)</tt><br>        首先,创建一个原型为<tt>proto的对象</tt>.然后,如果提供了可选参数<tt>propDescObj</tt>,则会按照<tt>Object.defineProperties添加属性的方式给这个新对象添加属性</tt>.最后,返回操作后的新对象.例如,下面的代码创建的对象和上面的Object.definePropertys例子创建的对象完全一样:<div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> obj =<span style="color:#000000"> Object.create(Object.prototype, {<br>    foo: { value: </span>123, enumerable: <span style="color:#0000ff">true</span><span style="color:#000000"> },<br>    bar: { value: </span>"abc", enumerable: <span style="color:#0000ff">true</span><span style="color:#000000"> }<br>});</span></div></li><li><tt>Object.getOwnPropertyDescriptor(obj, propName)</tt><br>        返回对象obj的名为<tt>propName的</tt>自身属性(非继承来的)的属性描述符.如果没有这个自身属性,则返回<tt>undefined</tt>.<div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; Object.getOwnPropertyDescriptor(Object.prototype, &quot;toString&quot;<span style="color:#000000">)<br>{ value: [Function: toString],<br>  writable: </span><span style="color:#0000ff">true</span><span style="color:#000000">,<br>  enumerable: </span><span style="color:#0000ff">false</span><span style="color:#000000">,<br>  configurable: </span><span style="color:#0000ff">true</span><span style="color:#000000"> }<br><br></span>&gt; Object.getOwnPropertyDescriptor({}, &quot;toString&quot;<span style="color:#000000">)<br>undefined</span></div></li></ul><p><strong>可枚举性</strong></p><p>本节会解释什么操作会受到属性的可枚举性的影响,什么操作不会.我们首先假设已经定义了如下这样的对象proto和obj:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> proto =<span style="color:#000000"> Object.defineProperties({}, {<br>    foo: { value: </span>1, enumerable: <span style="color:#0000ff">true</span><span style="color:#000000"> },<br>    bar: { value: </span>2, enumerable: <span style="color:#0000ff">false</span><span style="color:#000000"> }<br>});<br></span><span style="color:#0000ff">var</span> obj =<span style="color:#000000"> Object.create(proto, {<br>    baz: { value: </span>1, enumerable: <span style="color:#0000ff">true</span><span style="color:#000000"> },<br>    qux: { value: </span>2, enumerable: <span style="color:#0000ff">false</span><span style="color:#000000"> }<br>});</span></div><p>需要注意的是,所有对象(包括上面的<tt>proto</tt>)通常来说都至少有一个原型<tt>Object.prototype</tt><sup> <a href="http://www.cnblogs.com/ziyunfei/#a2">[2]</a></sup>:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; Object.getPrototypeOf({}) ===<span style="color:#000000"> Object.prototype<br></span><span style="color:#0000ff">true</span></div><p><tt>我们常用的内置方法比如</tt><tt>toString和</tt><tt>hasOwnProperty</tt>are等实际上都是定义在<tt>Object.prototype身上的</tt>.</p><p><strong>受可枚举性影响的操作</strong></p><p>可枚举性只影响两种操作:for-in循环和<tt>Object.keys()</tt>.</p><p>for-in循环会遍历到一个对象的所有可枚举属性的名称,包括继承来的属性:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; <span style="color:#0000ff">for</span> (<span style="color:#0000ff">var</span> x <span style="color:#0000ff">in</span> obj) console.log(x);   <span style="color:#008000">//</span><span style="color:#008000">没有遍历到Object.prototype上不可枚举的属性qux</span><br><span style="color:#000000">baz<br>foo</span></div><p><tt>Object.keys()返回一个对象的所有可枚举的自身属</tt><tt>性</tt>(非继承的)<tt>的名称组成的数组</tt>:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt;<span style="color:#000000"> Object.keys(obj)<br>[ </span>'baz' ]</div><p>如果你想获取到所有的自身属性,则应该使用<tt>Object.getOwnPropertyNames().</tt></p><p><strong>不受可枚举性影响的操作</strong></p><p>除了上面的两个操作,其他的操作都会忽略掉属性的可枚举性.一些读取操作会使用到继承来的属性:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; &quot;toString&quot; <span style="color:#0000ff">in</span><span style="color:#000000"> obj<br></span><span style="color:#0000ff">true</span><br>&gt;<span style="color:#000000"> obj.toString<br>[Function: toString]</span></div><p>还有一些操作只会考虑自身属性:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt;<span style="color:#000000"> Object.getOwnPropertyNames(obj)<br>[ </span>'baz', 'qux'<span style="color:#000000"> ]<br><br></span>&gt; obj.hasOwnProperty(&quot;qux&quot;<span style="color:#000000">)<br></span><span style="color:#0000ff">true</span><br>&gt; obj.hasOwnProperty(&quot;toString&quot;<span style="color:#000000">)<br></span><span style="color:#0000ff">false</span><br><br>&gt; Object.getOwnPropertyDescriptor(obj, &quot;qux&quot;<span style="color:#000000">)<br>{ value: </span>2<span style="color:#000000">,<br>  writable: </span><span style="color:#0000ff">false</span><span style="color:#000000">,<br>  enumerable: </span><span style="color:#0000ff">false</span><span style="color:#000000">,<br>  configurable: </span><span style="color:#0000ff">false</span><span style="color:#000000"> }<br></span>&gt; Object.getOwnPropertyDescriptor(obj, &quot;toString&quot;<span style="color:#000000">)<br>undefined</span></div><p>创建,删除,定义属性的操作只会影响到自身属性:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">obj.propName =<span style="color:#000000"> value<br>obj[</span>"propName"] =<span style="color:#000000"> value<br><br></span><span style="color:#0000ff">delete</span><span style="color:#000000"> obj.propName<br></span><span style="color:#0000ff">delete</span> obj["propName"<span style="color:#000000">]<br><br>Object.defineProperty(obj, propName, desc)<br>Object.defineProperties(obj, descObj)</span></div><p><strong>最佳实践</strong></p><p>一般的规则是:系统创建的属性是不可枚举的,用户创建的属性是可枚举的:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt;<span style="color:#000000"> Object.keys([])<br>[]<br></span>&gt;<span style="color:#000000"> Object.getOwnPropertyNames([])<br>[ </span>'length'<span style="color:#000000"> ]<br></span>&gt; Object.keys([&#39;a&#39;<span style="color:#000000">])<br>[ </span>'0' ]</div><p>特别是针对原型对象上的方法来说:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt;<span style="color:#000000"> Object.keys(Object.prototype)<br>[]<br></span>&gt;<span style="color:#000000"> Object.getOwnPropertyNames(Object.prototype)<br>[ hasOwnProperty</span>'<span style="color:#000000">,<br>  </span>'valueOf'<span style="color:#000000">,<br>  </span>'constructor'<span style="color:#000000">,<br>  </span>'toLocaleString'<span style="color:#000000">,<br>  </span>'isPrototypeOf'<span style="color:#000000">,<br>  </span>'propertyIsEnumerable'<span style="color:#000000">,<br>  </span>'toString' ]</div><p>因此,在你自己写的代码中,通常不应该给内置的原型对象添加属性,如果你必须要这么做,则应该把这个属性设置为不可枚举的,以防止影响到其他代码.</p><p>正如我们所看到的,不可枚举的好处是:能确保已有的代码中的for-in语句不受到从原型继承来的属性的影响.但是,不可枚举的属性只能够创建一种"for-in只会遍历一个对象的自身属性"这样的幻觉.在你的代码中,仍应该尽可能避免使用for-in<sup><a href="http://www.cnblogs.com/ziyunfei/#a3">[3]</a></sup>.</p><p>如果你把对象当成是字符串到值的Map来使用的话,则你应该只操作自身属性且要忽略掉可枚举性.不过这种情况下还有很多其他陷阱需要考虑<sup><a href="http://www.cnblogs.com/ziyunfei/#a4">[4]</a></sup>.</p><p><strong>结论</strong></p><p>在本文中,我们对属性的性质(称之为特性)进行了研究.需要注意的是,实际上JavaScript引擎并不是必须得通过特性来组织一个属性,它们主要是作为ECMAScript规范中定义的一个抽象操作.但有时候这些特性也会明确的出现在语言代码中,比如在属性描述符中.</p><p>更进一步的知识(2ality):</p><ul><li>阅读 “<a href="http://www.2ality.com/2011/07/js-properties.html">JavaScript properties: inheritance and enumerability</a>” 了解更多的受继承和枚举性影响的属性相关操作的知识.</li><li>阅读 “<a href="http://www.2ality.com/2012/01/js-inheritance-by-example.html">JavaScript inheritance by example</a>” 进一步了解JavaScript的继承.</li></ul><p><strong>参考</strong></p><ol><li><a name="a1" href="http://www.2ality.com/2012/10/proto.html"></a><a href="http://www.2ality.com/2012/10/proto.html">JavaScript: __proto__</a></li><li><a name="a2" href="http://www.2ality.com/2012/08/instanceof-object.html"></a><a href="http://www.2ality.com/2012/08/instanceof-object.html">What object is not an instance of Object?</a></li><li><a name="a3" href="http://www.2ality.com/2011/04/iterating-over-arrays-and-objects-in.html"></a><a href="http://www.2ality.com/2011/04/iterating-over-arrays-and-objects-in.html">Iterating over arrays and objects in JavaScript</a></li><li><a name="a4" href="http://www.2ality.com/2012/01/objects-as-maps.html"></a><a href="http://www.2ality.com/2012/01/objects-as-maps.html">The pitfalls of using objects as maps in JavaScript</a></li></ol><img src="http://www.cnblogs.com/ziyunfei/aggbug/2745786.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/ziyunfei/archive/2012/10/30/2745786.html">本文链接</a></p></h3>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
