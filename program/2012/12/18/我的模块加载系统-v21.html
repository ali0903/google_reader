<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>我的模块加载系统 v21</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>我的模块加载系统 v21</h2>
<p class="meta">2012-12-18 19:12</p>

<div class="post">
<h2>我的模块加载系统 v21</h2>

<h3>by 司徒正美</h3>

<h3>at 2012-12-18 11:12:00</h3>

<h3>original <a href="http://www.cnblogs.com/rubylouvre/archive/2012/12/18/2822912.html">http://www.cnblogs.com/rubylouvre/archive/2012/12/18/2822912.html</a></h3>

<p>多上stackoverflow总是有好处，昨天发现opera12之前一个比较致命的BUG，触发条件是script.onreadystatechange = script.onload = function(){}，因此连同mass, jQuery, seajs,labjs, headjs,controljs在内都中招了。我们可以称之为连写回调引发的血案。这个我正文会详解。</p>


<p><s>本版本的第二个改进是IE6的自闭合base标签回避问题。以前不管是否存在base标签，所有浏览器都插入到head标签的第一个子节点之前。但这样倒序可能引发后插入的先解析。因此现在特地对IE6进行处理，如果存在base标签，不管它是否自闭合，插入到它的前面，那样也可以保证顺序插入。其他浏览器则使用head.appendChild(script)。</s></p>


<p>本版本的第三个改进是FF3.6之前不支持document.readyState问题，这个是用于domReady。以前我们先行判定DOC.readyState === "complete"，但FF没有这东西，就每次进入DOMContentLoaded分支。但DOMContentLoaded事件只会触发一次，domReady后这分支就不起作用了。解决方案我是从labjs的源码中读到的：<br>/* The following "hack" was suggested by Andrea Giammarchi and adapted from: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html<br>   NOTE: this hack only operates in FF and then only in versions where document.readyState is not present (FF &lt; 3.6?).<br>   <br>   The hack essentially "patches" the **page** that LABjs is loaded onto so that it has a proper conforming document.readyState, so that if a script which does <br>   proper and safe dom-ready detection is loaded onto a page, after dom-ready has passed, it will still be able to detect this state, by inspecting the now hacked <br>   document.readyState property. The loaded script in question can then immediately trigger any queued code executions that were waiting for the DOM to be ready. <br>   For instance, jQuery 1.4+ has been patched to take advantage of document.readyState, which is enabled by this hack. But 1.3.2 and before are **not** safe or <br>   fixed by this hack, and should therefore **not** be lazy-loaded by script loader tools such as LABjs.<br>*/ <br>(function(addEvent,domLoaded,handler){<br>if (document.readyState == null &amp;&amp; document[addEvent]){<br>document.readyState = "loading";<br>document[addEvent](domLoaded,handler = function(){<br>document.removeEventListener(domLoaded,handler,false);<br>document.readyState = "complete";<br>},false);<br>}<br>})("addEventListener","DOMContentLoaded");<br><p>第四个改进是，框架最开头前的三个分号的回归！这是用于合并脚本时用。</p><p>好了，回归第一个问题，我们的大荤。我们推崇使用script加载模块，是因为它提供事件回调让我们掌握整个加载状况。IE6-8是使用onreadystatechange 事件，IE9-10开始支持onload，其他标浏览器则支持onload，但opera比较奇葩，onload与onreadystatechange 都支持，并且script也有readyState属性。如果opera抄袭抄得好也没所谓，但抄出BUG来。</p><p>看下面脚本,第一次加载它时，opera9.64 弹出interactive，loaded。然后我们关闭此页面，再打开它时，就弹出loaded，loaded（估计是浏览器缓存的原因），并且这情况一定没有改善。随机抽个版本，如opera10.52，加载个新JS文件，第一次就是弹出loaded，loaded。幸好在opera12.12,它已经不支持onreadystatechange。而IE6-10总是弹出loading，loaded。</p><br>window.onload = function(){<br>    var script = document.createElement("script");<br>    var array = []<br>    script.onreadystatechange = function(){<br>        array.push(this.readyState);<br>    }<br>    script.src = "jquery.js"// Opera 9.64<br>    document.body.appendChild(script);<br>    setTimeout(function(){<br>        alert(array)<br>    },2000)<br>}<br><p>换言之，这种连写法会让我们在opera没有加载完JS前执行用户回调，导致出错。解决方案是不要连写，并在回调中只对IE进行readyState判定！下面是改进后loadJS函数：</p><br><br>    function loadJS( url ){<br>        var node = DOC.createElement("script")//, IE = node.uniqueID<br>        node.className = moduleClass;<br>        node[W3C ? "onload" : "onreadystatechange"] = function(){<br>            if(W3C || /loaded|complete/i.test(node.readyState) ){<br>                //mass Framework会在_checkFail把它上面的回调清掉<br>                var factory = parsings.pop() ;<br>                factory &amp;&amp;  factory.delay(node.src)<br>                if( checkFail(node) ){<br>                    $.log("已成功加载 "+node.src, 7);<br>                }<br>            }<br>        }<br>        node.onerror = function(){<br>            checkFail(node, true)<br>        }<br>        node.src = url <br>   <br>            head.appendChild(node)<br><br>        $.log("正准备加载 "+node.src, 7)<br>    }<br><p></p><p>基本上就是这样。mass Framework许多想法总是跑在世界前面，兼容性巨无细漏，欢迎试用！</p><br>;;;(function( global, DOC ){<br>    var $$ = global.$//保存已有同名变量<br>    var rmakeid = /(#.+|\W)/g;<br>    var NsKey = DOC.URL.replace( rmakeid,"")<br>    var NsVal = global[ NsKey ];//公共命名空间<br>    var W3C   = DOC.dispatchEvent //w3c事件模型<br>    var html  = DOC.documentElement;<br>    var head  = DOC.head || DOC.getElementsByTagName( "head" )[0]<br>    var base = head.getElementsByTagName("base")[0];<br>    var loadings = [];//正在加载中的模块列表<br>    var parsings = []; //储存需要绑定ID与factory对应关系的模块（标准浏览器下，先parse的script节点会先onload）<br>    var mass = 1;//当前框架的版本号<br>    var postfix = "";//用于强制别名<br>    var cbi = 1e5 ; //用于生成回调函数的名字<br>    var all = "lang_fix,lang,support,class,flow,query,data,node,attr,css_fix,css,event_fix,event,ajax,fx"<br>    var moduleClass = "mass" + -(new Date());<br>    var class2type = {<br>        "[object HTMLDocument]"   : "Document",<br>        "[object HTMLCollection]" : "NodeList",<br>        "[object StaticNodeList]" : "NodeList",<br>        "[object IXMLDOMNodeList]": "NodeList",<br>        "[object DOMWindow]"      : "Window"  ,<br>        "[object global]"         : "Window"  ,<br>        "null"                    : "Null"    ,<br>        "NaN"                     : "NaN"     ,<br>        "undefined"               : "Undefined"<br>    }<br>    var toString = class2type.toString, basepath<br>    function $( expr, context ){//新版本的基石<br>        if( $.type( expr,"Function" ) ){ //注意在safari下,typeof nodeList的类型为function,因此必须使用$.type<br>            return  $.require( all+",ready", expr );<br>        }else{<br>            if( !$.fn )<br>                throw "node module is required!"<br>            return new $.fn.init( expr, context );<br>        }<br>    }<br>    //多版本共存<br>    if( typeof NsVal !== "function"){<br>        NsVal = $;//公用命名空间对象<br>        NsVal.uuid = 1;<br>    }<br>    if(NsVal.mass !== mass  ){<br>        NsVal[ mass ] = $;//保存当前版本的命名空间对象到公用命名空间对象上<br>        if(NsVal.mass || ($$ &amp;&amp; $$.mass == null)) {<br>            postfix = ( mass + "" ).replace(/\D/g, "" ) ;//是否强制使用多库共存<br>        }<br>    }else{<br>        return;<br>    }<br>    /**<br>     * 糅杂，为一个对象添加更多成员<br>     * @param {Object} receiver 接受者<br>     * @param {Object} supplier 提供者<br>     * @return  {Object} 目标对象<br>     */<br>    var has = Object.prototype.hasOwnProperty<br>    function mix( receiver, supplier ){<br>        var args = Array.apply([], arguments ),i = 1, key,//如果最后参数是布尔，判定是否覆写同名属性<br>        ride = typeof args[args.length - 1] == "boolean" ? args.pop() : true;<br>        if(args.length === 1){//处理$.mix(hash)的情形<br>            receiver = !this.window ? this : {} ;<br>            i = 0;<br>        }<br>        while((supplier = args[i++])){<br>            for ( key in supplier ) {//允许对象糅杂，用户保证都是对象<br>                if ( has.call(supplier,key) &amp;&amp; (ride || !(key in receiver))) {<br>                    receiver[ key ] = supplier[ key ];<br>                }<br>            }<br>        }<br>        return receiver;<br>    }<br><br>    mix( $, {//为此版本的命名空间对象添加成员<br>        html:  html,<br>        head:  head,<br>        mix:   mix,<br>        rword: /[^, ]+/g,<br>        mass:  mass,//大家都爱用类库的名字储存版本号，我也跟风了<br>        "@bind": W3C ? "addEventListener" : "attachEvent",<br>        //将内部对象挂到window下，此时可重命名，实现多库共存  name String 新的命名空间<br>        exports: function( name ) {<br>            $$ &amp;&amp; ( global.$ = $$ );//多库共存<br>            name = name || $.config.nick;//取得当前简短的命名空间<br>            $.config.nick = name;<br>            global[ NsKey ] = NsVal;<br>            return global[ name ]  = this;<br>        },<br>        /**<br>         * 数组化<br>         * @param {ArrayLike} nodes 要处理的类数组对象<br>         * @param {Number} start 可选。要抽取的片断的起始下标。如果是负数，从后面取起<br>         * @param {Number} end  可选。规定从何处结束选取<br>         * @return {Array}<br>         */<br>        slice: function ( nodes, start, end ) {<br>            var ret = [], n = nodes.length;<br>            if(end === void 0 || typeof end == &quot;number&quot; &amp;&amp; isFinite(end)){<br>                start = parseInt(start,10) || 0;<br>                end = end == void 0 ? n : parseInt(end, 10);<br>                if(start &lt; 0){<br>                    start += n;<br>                }<br>                if(end &gt; n){<br>                    end = n;<br>                }<br>                if(end &lt; 0){<br>                    end += n;<br>                }<br>                for (var i = start; i &lt; end; ++i) {<br>                    ret[i - start] = nodes[i];<br>                }<br>            }<br>            return ret;<br>        },<br>        /**<br>         * 用于取得数据的类型（一个参数的情况下）或判定数据的类型（两个参数的情况下）<br>         * @param {Any} obj 要检测的东西<br>         * @param {String} str 可选，要比较的类型<br>         * @return {String|Boolean}<br>         */<br>        type: function ( obj, str ){<br>            var result = class2type[ (obj == null || obj !== obj ) ? obj :  toString.call( obj ) ] || obj.nodeName || "#";<br>            if( result.charAt(0) === "#" ){//兼容旧式浏览器与处理个别情况,如window.opera<br>                //利用IE678 window == document为true,document == window竟然为false的神奇特性<br>                if( obj == obj.document &amp;&amp; obj.document != obj ){<br>                    result = "Window"; //返回构造器名字<br>                }else if( obj.nodeType === 9 ) {<br>                    result = "Document";//返回构造器名字<br>                }else if( obj.callee ){<br>                    result = "Arguments";//返回构造器名字<br>                }else if( isFinite( obj.length ) &amp;&amp; obj.item ){<br>                    result = "NodeList"; //处理节点集合<br>                }else{<br>                    result = toString.call( obj ).slice( 8, -1 );<br>                }<br>            }<br>            if( str ){<br>                return str === result;<br>            }<br>            return result;<br>        },<br>        //$.log(str, showInPage=true, 5 )<br>        //level Number，通过它来过滤显示到控制台的日志数量。0为最少，只显示最致命的错误，<br>        //7则连普通的调试消息也打印出来。 显示算法为 level &lt;= $.config.level。<br>        //这个$.colre.level默认为9。下面是level各代表的含义。<br>        //0 EMERGENCY 致命错误,框架崩溃<br>        //1 ALERT 需要立即采取措施进行修复<br>        //2 CRITICAL 危急错误<br>        //3 ERROR 异常<br>        //4 WARNING 警告<br>        //5 NOTICE 通知用户已经进行到方法<br>        //6 INFO 更一般化的通知<br>        //7 DEBUG 调试消息<br>        log: function (str){<br>            var show = true, page = false<br>            for(var i = 1 ; i &lt; arguments.length; i++){<br>                var el = arguments[i]<br>                if(typeof el == "number"){<br>                    show = el &lt;=  $.config.level<br>                }else if(el === true){<br>                    page = true;<br>                }<br>            }<br>            if(show){<br>                if( page === true ){<br>                    $.require( "ready", function(){<br>                        var div =  DOC.createElement( "pre" );<br>                        div.className = "mass_sys_log";<br>                        div.innerHTML = str +"";//确保为字符串<br>                        DOC.body.appendChild(div);<br>                    });<br>                }else if( global.console ){<br>                    global.console.log( str );<br>                }<br>            }<br>            return str<br>        },<br>        //主要用于建立一个从元素到数据的引用，具体用于数据缓存，事件绑定，元素去重<br>        getUid: global.getComputedStyle ? function( obj ){//IE9+,标准浏览器<br>            return obj.uniqueNumber || ( obj.uniqueNumber = NsVal.uuid++ );<br>        }: function( obj ){<br>            if(obj.nodeType !== 1){//如果是普通对象，文档对象，window对象<br>                return obj.uniqueNumber || ( obj.uniqueNumber = NsVal.uuid++ );<br>            }//注：旧式IE的XML元素不能通过el.xxx = yyy 设置自定义属性<br>            var uid = obj.getAttribute("uniqueNumber");<br>            if ( !uid ){<br>                uid = NsVal.uuid++;<br>                obj.setAttribute( "uniqueNumber", uid );<br>            }<br>            return +uid;//确保返回数字<br>        },<br>        /**<br>         * 生成键值统一的对象，用于高速化判定<br>         * @param {Array|String} array 如果是字符串，请用","或空格分开<br>         * @param {Number} val 可选，默认为1<br>         * @return {Object}<br>         */<br>        oneObject : function( array, val ){<br>            if( typeof array == "string" ){<br>                array = array.match( $.rword ) || [];<br>            }<br>            var result = {}, value = val !== void 0 ? val :1;<br>            for(var i = 0, n = array.length; i &lt; n; i++){<br>                result[ array[i] ] = value;<br>            }<br>            return result;<br>        },<br>        config: function( settings ) {<br>            var kernel  = $.config;<br>            for ( var p in settings ) {<br>                if (!settings.hasOwnProperty( p ))<br>                    continue<br>                var prev = kernel[ p ];<br>                var curr = settings[ p ];<br>                if (prev &amp;&amp; p === &quot;alias&quot;) {<br>                    for (var c in curr) {<br>                        if (curr.hasOwnProperty( c )) {<br>                            var prevValue = prev[ c ];<br>                            var currValue = curr[ c ];<br>                            if( prevValue &amp;&amp; prev !== curr ){<br>                                throw new Error(c + "不能重命名")<br>                            }<br>                            prev[ c ] = currValue;<br>                        }<br>                    }<br>                } else {<br>                    kernel[ p ] = curr;<br>                }<br>            }<br>            return this<br>        }<br>    });<br>    (function(scripts, cur){<br>        cur = scripts[ scripts.length - 1 ];<br>        var url = cur.hasAttribute ?  cur.src : cur.getAttribute( "src", 4 );<br>        url = url.replace(/[?#].*/, "");<br>        var a = cur.getAttribute("debug");<br>        var b = cur.getAttribute("storage");<br>        var kernel = $.config;<br>        kernel.debug = a == "true" || a == "1";<br>        kernel.storage = b == "true"|| b == "1";<br>        basepath =  kernel.base = url.substr( 0, url.lastIndexOf("/") ) +"/";<br>        kernel.nick = cur.getAttribute("nick") || "$";<br>        kernel.erase = cur.getAttribute("erase") || "erase";<br>        kernel.alias = {};<br>        kernel.level = 9;<br><br>    })(DOC.getElementsByTagName( "script" ));<br>    $.noop = $.error = function(){};<br><br>    "Boolean,Number,String,Function,Array,Date,RegExp,Window,Document,Arguments,NodeList".replace( $.rword, function( name ){<br>        class2type[ "[object " + name + "]" ] = name;<br>    });<br><br>    function parseURL(url, parent, ret){<br>        //[]里面，不是开头的-要转义，因此要用/^[-a-z0-9_$]{2,}$/i而不是/^[a-z0-9_-$]{2,}<br>        //别名至少两个字符；不用汉字是避开字符集的问题<br>        if( /^(mass|ready)$/.test(url)){//特别处理ready标识符<br>            return [url, "js"];<br>        }<br>        if(/^[-a-z0-9_$]{2,}$/i.test(url) &amp;&amp; $.config.alias[url] ){<br>            ret = $.config.alias[url];<br>        }else{<br>            parent = parent.substr( 0, parent.lastIndexOf('/') )<br>            if(/^(\w+)(\d)?:.*/.test(url)){  //如果用户路径包含协议<br>                ret = url<br>            }else {<br>                var tmp = url.charAt(0);<br>                if( tmp !== &quot;.&quot; &amp;&amp; tmp != &quot;/&quot;){  //相对于根路径<br>                    ret = basepath + url;<br>                }else if(url.slice(0,2) == "./"){ //相对于兄弟路径<br>                    ret = parent + url.substr(1);<br>                }else if( url.slice(0,2) == ".."){ //相对于父路径<br>                    var arr = parent.replace(/\/$/,"").split("/");<br>                    tmp = url.replace(/\.\.\//g,function(){<br>                        arr.pop();<br>                        return "";<br>                    });<br>                    ret = arr.join("/")+"/"+tmp;<br>                }else if(tmp == "/"){<br>                    ret = parent  + url<br>                }else{<br>                    throw new Error("不符合模块标识规则: "+url)<br>                }<br>            }<br>        }<br>        var ext = "js";<br>        tmp = ret.replace(/[?#].*/, "");<br>        if(/\.(\w+)$/.test( tmp )){<br>            ext = RegExp.$1;<br>        }<br>        if( ext!=&quot;css&quot; &amp;&amp;tmp == ret &amp;&amp; !/\.js$/.test(ret)){//如果没有后缀名会补上.js<br>            ret += ".js";<br>        }<br>        return [ret, ext];<br>    }<br>  <br>    $.mix({<br>        //绑定事件(简化版)<br>        bind: W3C ? function( el, type, fn, phase ){<br>            el.addEventListener( type, fn, !!phase );<br>            return fn;<br>        } : function( el, type, fn ){<br>            el.attachEvent &amp;&amp; el.attachEvent( &quot;on&quot;+type, fn );<br>            return fn;<br>        },<br>        unbind: W3C ? function( el, type, fn, phase ){<br>            el.removeEventListener( type, fn || $.noop, !!phase );<br>        } : function( el, type, fn ){<br>            if ( el.detachEvent ) {<br>                el.detachEvent( "on" + type, fn || $.noop );<br>            }<br>        },<br>        //移除指定或所有本地储存中的模块<br>        erase : function( id, v ){<br>            if(id == void 0){<br>                Storage.clear();<br>            }else{<br>                var old = Storage.getItem( id+"_version" );<br>                if(old &amp;&amp; (!v || v &gt; Number(old)) ){<br>                    Storage.removeItem( id );<br>                    Storage.removeItem( id+"_deps" );<br>                    Storage.removeItem( id+"_parent" );<br>                    Storage.removeItem( id+"_version" );<br>                }<br>            }<br>        }<br>    });<br>    //================================localStorage===============================<br>    var Storage = $.oneObject("setItem,getItem,removeItem,clear",$.noop);<br>    if( global.localStorage){<br>        Storage = localStorage; <br>    }else  if( html.addBehavior){<br>        html.addBehavior('#default#userData');<br>        html.save("massdata");<br>        //https://github.com/marcuswestin/store.js/issues/40#issuecomment-4617842<br>        //在IE67它对键名非常严格,不能有特殊字符,否则抛throwed an This name may not contain the &#39;~&#39; character: _key--&gt;~&lt;--<br>        var rstoragekey = new RegExp(&quot;[!\&quot;#$%&amp;&#39;()*+,/\\\\:;&lt;=&gt;?@[\\]^`{|}~]&quot;, &quot;g&quot;);<br>        function curry(fn) {<br>            return function(a, b) {<br>                html.load("massdata");<br>                a = String(a).replace(rstoragekey, function(w){<br>                    return w.charCodeAt(0);<br>                });<br>                var result = fn( a, b );<br>                html.save("massdata");<br>                return result<br>            }<br>        }<br>        Storage = {<br>            setItem : curry(function(key, val){<br>                html.setAttribute(key, val);<br>            }),<br>            getItem: curry(function(key){<br>                return html.getAttribute(key);<br>            }),<br>            removeItem: curry(function(key){<br>                html.removeAttribute(key);<br>            }),<br>            clear: function(){<br>                var attributes = html.XMLDocument.documentElement.attributes<br>                for (var i=0, attr; attr=attributes[i]; i++) {<br>                    html.removeAttribute(attr.name)<br>                }<br>            }<br>        }<br>    }<br>    var rerase = new RegExp("(?:^| )" + $.config.erase + "(?:(?:=([^;]*))|;|$)")<br>    var match = String(DOC.cookie).match( rerase );<br>    //读取从后端过来的cookie指令，转换成一个对象，键名为模块的URL，值为版本号（这是一个时间戮）<br>    if(match &amp;&amp; match[1]){<br>        try{<br>            var obj = eval("0,"+match[1]);<br>            for(var i in obj){//$.erase会版本号比现在小的模块从本地储存中删掉<br>                $.erase(i, obj[i])<br>            }<br>        }catch(e){}<br>    }<br><br>    //============================加载系统===========================<br>    var modules = $.modules =  {<br>        ready:{ },<br>        mass: {<br>            state: 2,<br>            exports: $<br>        }<br>    };<br>    function getCurrentScript(){<br>        if(DOC.currentScript){<br>            return DOC.currentScript.src<br>        }<br>        var nodes = DOC.getElementsByTagName("script")<br>        for (var i = 0, node; node = nodes[i++];) {<br>            if (!node.pass &amp;&amp; node.className == moduleClass &amp;&amp; node.readyState === &quot;interactive&quot;) {<br>                return  node.pass = node.src;<br>            }<br>        }<br>    }<br>    //检测是否存在循环依赖<br>    function checkCycle( deps, nick ){<br>        for(var id in deps){<br>            if( deps[id] == &quot;司徒正美&quot; &amp;&amp; modules[id].state != 2 &amp;&amp;( id == nick || checkCycle(modules[id].deps, nick))){<br>                return true;<br>            }<br>        }<br>    }<br>    //检测此JS模块的依赖是否都已安装完毕,是则安装自身<br>    function checkDeps(){<br>        loop:<br>        for ( var i = loadings.length, id; id = loadings[ --i ]; ) {<br>            var obj = modules[ id ], deps = obj.deps;<br>            for( var key in deps ){<br>                if( deps.hasOwnProperty( key ) &amp;&amp; modules[ key ].state != 2 ){<br>                    continue loop;<br>                }<br>            }<br>            //如果deps是空对象或者其依赖的模块的状态都是2<br>            if( obj.state != 2){<br>                loadings.splice( i, 1 );//必须先移除再安装，防止在IE下DOM树建完后手动刷新页面，会多次执行它<br>                fireFactory( obj.id, obj.args, obj.factory );<br>                checkDeps();<br>            }<br>        }<br>    }<br>    function checkFail( node, error ){<br>        var id = node.src;<br>        node.onload = node.onreadystatechange = node.onerror = null;<br>        if( error || !modules[ id ].state ){<br>            //注意，在IE通过!modules[ id ].state检测可能不精确，这时立即移除节点会出错<br>            setTimeout(function(){<br>                head.removeChild(node)<br>            }, error ? 0 : 1000 );<br>            $.log("加载 "+ id +" 失败", 7);<br>        }else{<br>            return true;<br>        }<br>    }<br>    function loadJS( url ){<br>        var node = DOC.createElement("script")//, IE = node.uniqueID<br>        node.className = moduleClass;<br>        node[W3C ? "onload" : "onreadystatechange"] = function(){<br>            if(W3C || /loaded|complete/i.test(node.readyState) ){<br>                //mass Framework会在_checkFail把它上面的回调清掉，尽可能释放回存，尽管DOM0事件写法在IE6下GC无望<br>                var factory = parsings.pop() ;<br>                factory &amp;&amp;  factory.delay(node.src)<br>                if( checkFail(node) ){<br>                    $.log("已成功加载 "+node.src, 7);<br>                }<br>            }<br>        }<br>        node.onerror = function(){<br>            checkFail(node, true)<br>        }<br>        node.src = url <br><br>            head.appendChild(node)<br><br>        $.log("正准备加载 "+node.src, 7)<br>    }<br>    function loadCSS(url){<br>        var id = url.replace(rmakeid,"");<br>        if (DOC.getElementById(id))<br>            return<br>        var node     =  DOC.createElement("link");<br>        node.rel     = "stylesheet";<br>        node.href    = url;<br>        node.id      = id;<br>        head.insertBefore( node, head.firstChild );<br>    }<br>    function loadStorage( id ){<br>        var factory =  Storage.getItem( id );<br>        if( $.config.storage &amp;&amp; factory &amp;&amp; !modules[id]){<br>            var parent = Storage.getItem(id+"_parent");<br>            var deps = Storage.getItem(id+"_deps");<br>            deps = deps ?  deps.match( $.rword ) : "";<br>            modules[ id ] ={<br>                id: id,<br>                parent: parent,<br>                exports: {},<br>                state: 1<br>            };<br>            require(deps, Function(&quot;return &quot;+ factory )(), id) //0,1,2 --&gt; 1,2,0<br>        }<br>    }<br><br>    //请求模块（依赖列表,模块工厂,加载失败时触发的回调）<br>    window.require = $.require = function( list, factory, parent ){<br>        var deps = {},  // 用于检测它的依赖是否都为2<br>        args = [],      // 用于依赖列表中的模块的返回值<br>        dn = 0,         // 需要安装的模块数<br>        cn = 0,         // 已安装完的模块数<br>        id = parent || "cb"+ ( cbi++ ).toString(32);<br>        parent = parent || basepath<br>        String(list).replace( $.rword, function(el){<br>            var array = parseURL(el, parent ),  url = array[0];<br>            if(array[1] == "js"){<br>                dn++<br>                loadStorage( id )<br>                if( !modules[ url ]  ){<br>                    modules[ url ] = {<br>                        id: url,<br>                        parent: parent,<br>                        exports: {}<br>                    };<br>                    loadJS( url );<br>                }else if( modules[ url ].state === 2 ){<br>                    cn++;<br>                }<br>                if( !deps[ url ] ){<br>                    args.push( url );<br>                    deps[ url ] = "司徒正美";//去重<br>                }<br>            }else if(array[1] === "css"){<br>                loadCSS( url );<br>            }<br>        });<br>        //创建或更新模块的状态<br>        modules[id] = {<br>            id: id,<br>            factory: factory,<br>            deps: deps,<br>            args: args,<br>            state: 1<br>        }<br>        if( dn === cn ){//如果需要安装的等于已安装好的<br>            fireFactory( id, args, factory );//装配到框架中<br>            checkDeps();<br>            return<br>        }<br>        //在正常情况下模块只能通过_checkDeps执行<br>        loadings.unshift( id );<br>    }<br>    //定义模块<br>    var rcomment =  /\/\*(?:[^*]|\*+[^\/*])*\*+\/|\/\/.*/g<br>    window.define = $.define = function( id, deps, factory ){//模块名,依赖列表,模块本身<br>        var args = Array.apply([],arguments), _id<br>        if(typeof id == "string"){<br>            _id = args.shift();<br>        }<br>        if( typeof args[0] === "boolean" ){//用于文件合并, 在标准浏览器中跳过补丁模块<br>            if( args[0] ){<br>                return;<br>            }<br>            args.shift()<br>        }<br>        if(typeof args[0] == "function"){<br>            args.unshift([]);<br>        }//上线合并后能直接得到模块ID,否则寻找当前正在解析中的script节点的src作为模块ID<br>        //但getCurrentScript方法只对IE6-10,FF4+有效,其他使用onload+delay闭包组合<br>        id = modules[id] &amp;&amp; modules[id].state == 2 ? _id : getCurrentScript();<br>        factory = args[1];<br>        factory.id = _id;//用于调试<br>        factory.delay = function( id ){<br>            args.push( id );<br>            if( checkCycle(modules[id].deps, id)){<br>                throw new Error( id +"模块与之前的某些模块存在循环依赖")<br>            }<br>            if( $.config.storage &amp;&amp; !Storage.getItem( id ) ){<br>                Storage.setItem( id, factory.toString().replace(rcomment,""));<br>                Storage.setItem( id+"_deps", args[0]+"");<br>                Storage.setItem( id+"_parent",  id);<br>                Storage.setItem( id+"_version", new Date - 0);<br>            }<br>            delete factory.delay;//释放内存<br>            require.apply(null, args); //0,1,2 --&gt; 1,2,0<br>        }<br>        if(id ){<br>            factory.delay(id,args)<br>        }else{//先进先出<br>            parsings.push( factory )<br>        }<br>    }<br>    $.require.amd = modules<br>    <br>    //从returns对象取得依赖列表中的各模块的返回值，执行factory, 完成模块的安装<br>    function fireFactory( id, deps, factory ){<br>        for ( var i = 0, array = [], d; d = deps[i++]; ) {<br>            array.push( modules[ d ].exports );<br>        }<br>        var module = Object( modules[id] ), ret;<br>        ret =  factory.apply(global, array);<br>        module.state = 2;<br>        if( ret !== void 0 ){<br>            modules[ id ].exports = ret<br>        }<br>        return ret;<br>    }<br>    all.replace($.rword,function(a){<br>        $.config.alias[ "$"+a ] = basepath + a + ".js";<br>    });<br>    //domReady机制<br>    var readyFn, ready =  W3C ? "DOMContentLoaded" : "readystatechange" ;<br>    function fireReady(){<br>        modules.ready.state = 2;<br>        checkDeps();<br>        if( readyFn ){<br>            $.unbind( DOC, ready, readyFn );<br>        }<br>        fireReady = $.noop;//隋性函数，防止IE9二次调用_checkDeps<br>    };<br>    function doScrollCheck() {<br>        try {<br>            html.doScroll( "left" ) ;<br>            fireReady();<br>        } catch(e) {<br>            setTimeout( doScrollCheck, 31 );<br>        }<br>    };<br>    //在firefox3.6之前，不存在readyState属性<br>    //http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html<br>    if(DOC.readyState == null){<br>        DOC.readyState = "loading";<br>        var readyState = true;<br>    }<br>    if ( DOC.readyState === "complete" ) {<br>        fireReady();//如果在domReady之外加载<br>    }else {<br>        $.bind( DOC, ready, readyFn = function(){<br>            if ( W3C || DOC.readyState === "complete" ){<br>                fireReady();<br>                if(readyState){//IE下不能改写DOC.readyState<br>                    DOC.readyState  = "complete";<br>                }<br>            }<br>        });<br>        if( html.doScroll &amp;&amp; self.eval === parent.eval)<br>            doScrollCheck();<br>    }<br><br>    global.VBArray &amp;&amp; (&quot;abbr,article,aside,audio,bdi,canvas,data,datalist,details,figcaption,figure,footer,&quot; +<br>        "header,hgroup,mark,meter,nav,output,progress,section,summary,time,video").replace( $.rword, function( tag ){<br>        DOC.createElement(tag);<br>    });<br><br>    //https://developer.mozilla.org/en/DOM/window.onpopstate<br>    $.bind( global, "popstate", function(){<br>        NsKey = DOC.URL.replace(rmakeid,"");<br>        $.exports();<br>    });<br>    $.exports( $.config.nick +  postfix );//防止不同版本的命名空间冲突<br>/*combine modules*/<br><br>})( self, self.document );//为了方便在VS系列实现智能提示,把这里的this改成self或window<br><p><a href="https://github.com/RubyLouvre">框架地址</a></p><img src="http://www.cnblogs.com/rubylouvre/aggbug/2822912.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/rubylouvre/archive/2012/12/18/2822912.html">本文链接</a></p></p>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
