<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>经典算法题每日演练——第十八题 外排序</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>经典算法题每日演练——第十八题 外排序</h2>
<p class="meta">19 Dec 2012</p>

<div class="post">
<h2>经典算法题每日演练——第十八题 外排序</h2>

<h3>by 一线码农</h3>

<h3>at 2012-12-19 14:44:00</h3>

<h3>original <a href="http://www.cnblogs.com/huangxincheng/archive/2012/12/19/2824943.html">http://www.cnblogs.com/huangxincheng/archive/2012/12/19/2824943.html</a></h3>

<p> </p>


<p><br><p>     说到排序，大家第一反应基本上是内排序，是的，算法嘛，玩的就是内存，然而内存是有限制的，总有装不下的那一天，此时就可以来玩玩</p><br><p>外排序，当然在我看来，外排序考验的是一个程序员的架构能力，而不仅仅局限于排序这个层次。</p><br><p> </p><br><p>一：N路归并排序</p><br><p>1.概序</p><br><p>    我们知道算法中有一种叫做分治思想，一个大问题我们可以采取分而治之，各个突破，当子问题解决了，大问题也就KO了，还有一点我们知道</p><br><p>内排序的归并排序是采用二路归并的，因为分治后有LogN层，每层两路归并需要N的时候，最后复杂度为NlogN，那么外排序我们可以将这个“二”</p><br><p>扩大到M，也就是将一个大文件分成M个小文件，每个小文件是有序的，然后对应在内存中我们开M个优先队列，每个队列从对应编号的文件中读取</p><br><p>TopN条记录，然后我们从M路队列中各取一个数字进入中转站队列，并将该数字打上队列编号标记，当从中转站出来的最小数字就是我们最后要排</p><br><p>序的数字之一，因为该数字打上了队列编号，所以方便我们通知对应的编号队列继续出数字进入中转站队列，可以看出中转站一直保存了M个记录，</p><br><p>当中转站中的所有数字都出队完毕，则外排序结束。如果大家有点蒙的话，我再配合一张图，相信大家就会一目了然，这考验的是我们的架构能力。</p><br><p><img src="http://images.cnitblog.com/blog/214741/201212/19135427-8d678fffb48d4d24a054014b441542a2.png" alt=""></p><br><p>图中这里有个Batch容器，这个容器我是基于性能考虑的，当batch=n时，我们定时刷新到文件中，保证内存有足够的空间。</p><br><p> </p><br><p>2.构建</p><br><p>&lt;1&gt; 生成数据</p><br><p>   这个基本没什么好说的，采用随机数生成n条记录。</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>        #region 随机生成数据<br>        /// &lt;summary&gt;<br>        /// 随机生成数据<br>        ///&lt;param name=&quot;max&quot;&gt;执行生成的数据上线&lt;/param&gt;<br>        /// &lt;/summary&gt;<br>        public static void CreateData(int max)<br>        {<br>            var sw = new StreamWriter(Environment.CurrentDirectory + "//demo.txt");<br><br>            for (int i = 0; i &lt; max; i++)<br>            {<br>                Thread.Sleep(2);<br>                var rand = new Random((int)DateTime.Now.Ticks).Next(0, int.MaxValue &gt;&gt; 3);<br><br>                sw.WriteLine(rand);<br>            }<br>            sw.Close();<br>        }<br>        #endregion<br></pre><br></div><br><p>　　</p><br><p>&lt;2&gt; 切分数据<br>     根据实际情况我们来决定到底要分成多少个小文件，并且小文件的数据必须是有序的，小文件的个数也对应这内存中有多少个优先队列。</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>        #region 将数据进行分份<br>        /// &lt;summary&gt;<br>        /// 将数据进行分份<br>        /// &lt;param name=&quot;size&quot;&gt;每页要显示的条数&lt;/param&gt;<br>        /// &lt;/summary&gt;<br>        public static int Split(int size)<br>        {<br>            //文件总记录数<br>            int totalCount = 0;<br><br>            //每一份文件存放 size 条 记录<br>            List&lt;int&gt; small = new List&lt;int&gt;();<br><br>            var sr = new StreamReader((Environment.CurrentDirectory + "//demo.txt"));<br><br>            var pageSize = size;<br><br>            int pageCount = 0;<br><br>            int pageIndex = 0;<br><br>            while (true)<br>            {<br>                var line = sr.ReadLine();<br><br>                if (!string.IsNullOrEmpty(line))<br>                {<br>                    totalCount++;<br><br>                    //加入小集合中<br>                    small.Add(Convert.ToInt32(line));<br><br>                    //说明已经到达指定的 size 条数了<br>                    if (totalCount % pageSize == 0)<br>                    {<br>                        pageIndex = totalCount / pageSize;<br><br>                        small = small.OrderBy(i =&gt; i).Select(i =&gt; i).ToList();<br><br>                        File.WriteAllLines(Environment.CurrentDirectory + &quot;//&quot; + pageIndex + &quot;.txt&quot;, small.Select(i =&gt; i.ToString()));<br><br>                        small.Clear();<br>                    }<br>                }<br>                else<br>                {<br>                    //说明已经读完了，将剩余的small记录写入到文件中<br>                    pageCount = (int)Math.Ceiling((double)totalCount / pageSize);<br><br>                    small = small.OrderBy(i =&gt; i).Select(i =&gt; i).ToList();<br><br>                    File.WriteAllLines(Environment.CurrentDirectory + &quot;//&quot; + pageCount + &quot;.txt&quot;, small.Select(i =&gt; i.ToString()));<br><br>                    break;<br>                }<br>            }<br><br>            return pageCount;<br>        }<br>        #endregion<br></pre><br></div><br><p>　　</p><br><p>&lt;3&gt; 加入队列</p><br><p>    我们知道内存队列存放的只是小文件的topN条记录，当内存队列为空时，我们需要再次从小文件中读取下一批的TopN条数据，然后放入中转站</p><br><p>继续进行比较。</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>#region 将数据加入指定编号队列<br>        /// &lt;summary&gt;<br>        /// 将数据加入指定编号队列<br>        /// &lt;/summary&gt;<br>        /// &lt;param name=&quot;i&quot;&gt;队列编号&lt;/param&gt;<br>        /// &lt;param name=&quot;skip&quot;&gt;文件中跳过的条数&lt;/param&gt;<br>        /// &lt;param name=&quot;list&quot;&gt;&lt;/param&gt;<br>        /// &lt;param name=&quot;top&quot;&gt;需要每次读取的条数&lt;/param&gt;<br>        public static void AddQueue(int i, List&lt;PriorityQueue&lt;int?&gt;&gt; list, ref int[] skip, int top = 100)<br>        {<br>            var result = File.ReadAllLines((Environment.CurrentDirectory + "//" + (i + 1) + ".txt"))<br>                             .Skip(skip[i]).Take(top).Select(j =&gt; Convert.ToInt32(j));<br><br>            //加入到集合中<br>            foreach (var item in result)<br>                list[i].Eequeue(null, item);<br><br>            //将个数累计到skip中，表示下次要跳过的记录数<br>            skip[i] += result.Count();<br>        }<br>        #endregion<br></pre><br></div><br><p>　　</p><br><p>&lt;4&gt; 测试</p><br><p> 最后我们来测试一下:</p><br><p> 数据量：short.MaxValue。</p><br><p> 内存存放量：1200。</p><br><p>在这种场景下，我们决定每个文件放1000条，也就有33个小文件，也就有33个内存队列，每个队列取Top100条，Batch=500时刷新</p><br><p>硬盘，中转站存放33<em>2个数字（因为入中转站时打上了队列标记）,最后内存活动最大总数为：sum=33</em>100+500+66=896&lt;1200。</p><br><p>时间复杂度为N*logN。当然这个“阀值”，我们可以再仔细微调。</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>  public static void Main()<br>        {<br>            //生成2<sup>15</sup>数据<br>            CreateData(short.MaxValue);<br><br>            //每个文件存放1000条<br>            var pageSize = 1000;<br><br>            //达到batchCount就刷新记录<br>            var batchCount = 0;<br><br>            //判断需要开启的队列<br>            var pageCount = Split(pageSize);<br><br>            //内存限制：1500条<br>            List&lt;PriorityQueue&lt;int?&gt;&gt; list = new List&lt;PriorityQueue&lt;int?&gt;&gt;();<br><br>            //定义一个队列中转器<br>            PriorityQueue&lt;int?&gt; queueControl = new PriorityQueue&lt;int?&gt;();<br><br>            //定义每个队列完成状态<br>            bool[] complete = new bool[pageCount];<br><br>            //队列读取文件时应该跳过的记录数<br>            int[] skip = new int[pageCount];<br><br>            //是否所有都完成了<br>            int allcomplete = 0;<br><br>            //定义 10 个队列<br>            for (int i = 0; i &lt; pageCount; i++)<br>            {<br>                list.Add(new PriorityQueue&lt;int?&gt;());<br><br>                //i：   记录当前的队列编码<br>                //list: 队列数据<br>                //skip：跳过的条数<br>                AddQueue(i, list, ref skip);<br>            }<br><br>            //初始化操作，从每个队列中取出一条记录，并且在入队的过程中<br>            //记录该数据所属的 “队列编号”<br>            for (int i = 0; i &lt; list.Count; i++)<br>            {<br>                var temp = list[i].Dequeue();<br><br>                //i:队列编码,level:要排序的数据<br>                queueControl.Eequeue(i, temp.level);<br>            }<br><br>            //默认500条写入一次文件<br>            List&lt;int&gt; batch = new List&lt;int&gt;();<br><br>            //记录下次应该从哪一个队列中提取数据<br>            int nextIndex = 0;<br><br>            while (queueControl.Count() &gt; 0)<br>            {<br>                //从中转器中提取数据<br>                var single = queueControl.Dequeue();<br><br>                //记录下一个队列总应该出队的数据<br>                nextIndex = single.t.Value;<br><br>                var nextData = list[nextIndex].Dequeue();<br><br>                //如果改对内弹出为null，则说明该队列已经，需要从nextIndex文件中读取数据<br>                if (nextData == null)<br>                {<br>                    //如果该队列没有全部读取完毕<br>                    if (!complete[nextIndex])<br>                    {<br>                        AddQueue(nextIndex, list, ref skip);<br><br>                        //如果从文件中读取还是没有，则说明改文件中已经没有数据了<br>                        if (list[nextIndex].Count() == 0)<br>                        {<br>                            complete[nextIndex] = true;<br>                            allcomplete++;<br>                        }<br>                        else<br>                        {<br>                            nextData = list[nextIndex].Dequeue();<br>                        }<br>                    }<br>                }<br><br>                //如果弹出的数不为空，则将该数入中转站<br>                if (nextData != null)<br>                {<br>                    //将要出队的数据 转入 中转站<br>                    queueControl.Eequeue(nextIndex, nextData.level);<br>                }<br><br>                batch.Add(single.level);<br><br>                //如果batch=500，或者所有的文件都已经读取完毕，此时我们要批量刷入数据<br>                if (batch.Count == batchCount || allcomplete == pageCount)<br>                {<br>                    var sw = new StreamWriter(Environment.CurrentDirectory + "//result.txt", true);<br><br>                    foreach (var item in batch)<br>                    {<br>                        sw.WriteLine(item);<br>                    }<br><br>                    sw.Close();<br><br>                    batch.Clear();<br>                }<br>            }<br><br>            Console.WriteLine("恭喜，外排序完毕！");<br>            Console.Read();<br>        }<br></pre><br></div><br><p>　　</p><br><p><img src="http://images.cnitblog.com/blog/214741/201212/19143549-e844540c7f0342c2beb549e9c9978f61.png" alt=""></p><br><p>总的代码：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="">View Code<br><div><br><pre>  1 using System;<br>  2 using System.Collections.Generic;<br>  3 using System.Linq;<br>  4 using System.Text;<br>  5 using System.Diagnostics;<br>  6 using System.Threading;<br>  7 using System.IO;<br>  8 using System.Threading.Tasks;<br>  9 <br> 10 namespace ConsoleApplication2<br> 11 {<br> 12     public class Program<br> 13     {<br> 14         public static void Main()<br> 15         {<br> 16             //生成2<sup>15</sup>数据<br> 17             CreateData(short.MaxValue);<br> 18 <br> 19             //每个文件存放1000条<br> 20             var pageSize = 1000;<br> 21 <br> 22             //达到batchCount就刷新记录<br> 23             var batchCount = 0;<br> 24 <br> 25             //判断需要开启的队列<br> 26             var pageCount = Split(pageSize);<br> 27 <br> 28             //内存限制：1500条<br> 29             List&lt;PriorityQueue&lt;int?&gt;&gt; list = new List&lt;PriorityQueue&lt;int?&gt;&gt;();<br> 30 <br> 31             //定义一个队列中转器<br> 32             PriorityQueue&lt;int?&gt; queueControl = new PriorityQueue&lt;int?&gt;();<br> 33 <br> 34             //定义每个队列完成状态<br> 35             bool[] complete = new bool[pageCount];<br> 36 <br> 37             //队列读取文件时应该跳过的记录数<br> 38             int[] skip = new int[pageCount];<br> 39 <br> 40             //是否所有都完成了<br> 41             int allcomplete = 0;<br> 42 <br> 43             //定义 10 个队列<br> 44             for (int i = 0; i &lt; pageCount; i++)<br> 45             {<br> 46                 list.Add(new PriorityQueue&lt;int?&gt;());<br> 47 <br> 48                 //i：   记录当前的队列编码<br> 49                 //list: 队列数据<br> 50                 //skip：跳过的条数<br> 51                 AddQueue(i, list, ref skip);<br> 52             }<br> 53 <br> 54             //初始化操作，从每个队列中取出一条记录，并且在入队的过程中<br> 55             //记录该数据所属的 “队列编号”<br> 56             for (int i = 0; i &lt; list.Count; i++)<br> 57             {<br> 58                 var temp = list[i].Dequeue();<br> 59 <br> 60                 //i:队列编码,level:要排序的数据<br> 61                 queueControl.Eequeue(i, temp.level);<br> 62             }<br> 63 <br> 64             //默认500条写入一次文件<br> 65             List&lt;int&gt; batch = new List&lt;int&gt;();<br> 66 <br> 67             //记录下次应该从哪一个队列中提取数据<br> 68             int nextIndex = 0;<br> 69 <br> 70             while (queueControl.Count() &gt; 0)<br> 71             {<br> 72                 //从中转器中提取数据<br> 73                 var single = queueControl.Dequeue();<br> 74 <br> 75                 //记录下一个队列总应该出队的数据<br> 76                 nextIndex = single.t.Value;<br> 77 <br> 78                 var nextData = list[nextIndex].Dequeue();<br> 79 <br> 80                 //如果改对内弹出为null，则说明该队列已经，需要从nextIndex文件中读取数据<br> 81                 if (nextData == null)<br> 82                 {<br> 83                     //如果该队列没有全部读取完毕<br> 84                     if (!complete[nextIndex])<br> 85                     {<br> 86                         AddQueue(nextIndex, list, ref skip);<br> 87 <br> 88                         //如果从文件中读取还是没有，则说明改文件中已经没有数据了<br> 89                         if (list[nextIndex].Count() == 0)<br> 90                         {<br> 91                             complete[nextIndex] = true;<br> 92                             allcomplete++;<br> 93                         }<br> 94                         else<br> 95                         {<br> 96                             nextData = list[nextIndex].Dequeue();<br> 97                         }<br> 98                     }<br> 99                 }<br>100 <br>101                 //如果弹出的数不为空，则将该数入中转站<br>102                 if (nextData != null)<br>103                 {<br>104                     //将要出队的数据 转入 中转站<br>105                     queueControl.Eequeue(nextIndex, nextData.level);<br>106                 }<br>107 <br>108                 batch.Add(single.level);<br>109 <br>110                 //如果batch=500，或者所有的文件都已经读取完毕，此时我们要批量刷入数据<br>111                 if (batch.Count == batchCount || allcomplete == pageCount)<br>112                 {<br>113                     var sw = new StreamWriter(Environment.CurrentDirectory + "//result.txt", true);<br>114 <br>115                     foreach (var item in batch)<br>116                     {<br>117                         sw.WriteLine(item);<br>118                     }<br>119 <br>120                     sw.Close();<br>121 <br>122                     batch.Clear();<br>123                 }<br>124             }<br>125 <br>126             Console.WriteLine("恭喜，外排序完毕！");<br>127             Console.Read();<br>128         }<br>129 <br>130         #region 将数据加入指定编号队列<br>131         /// &lt;summary&gt;<br>132         /// 将数据加入指定编号队列<br>133         /// &lt;/summary&gt;<br>134         /// &lt;param name=&quot;i&quot;&gt;队列编号&lt;/param&gt;<br>135         /// &lt;param name=&quot;skip&quot;&gt;文件中跳过的条数&lt;/param&gt;<br>136         /// &lt;param name=&quot;list&quot;&gt;&lt;/param&gt;<br>137         /// &lt;param name=&quot;top&quot;&gt;需要每次读取的条数&lt;/param&gt;<br>138         public static void AddQueue(int i, List&lt;PriorityQueue&lt;int?&gt;&gt; list, ref int[] skip, int top = 100)<br>139         {<br>140             var result = File.ReadAllLines((Environment.CurrentDirectory + "//" + (i + 1) + ".txt"))<br>141                              .Skip(skip[i]).Take(top).Select(j =&gt; Convert.ToInt32(j));<br>142 <br>143             //加入到集合中<br>144             foreach (var item in result)<br>145                 list[i].Eequeue(null, item);<br>146 <br>147             //将个数累计到skip中，表示下次要跳过的记录数<br>148             skip[i] += result.Count();<br>149         }<br>150         #endregion<br>151 <br>152         #region 随机生成数据<br>153         /// &lt;summary&gt;<br>154         /// 随机生成数据<br>155         ///&lt;param name=&quot;max&quot;&gt;执行生成的数据上线&lt;/param&gt;<br>156         /// &lt;/summary&gt;<br>157         public static void CreateData(int max)<br>158         {<br>159             var sw = new StreamWriter(Environment.CurrentDirectory + "//demo.txt");<br>160 <br>161             for (int i = 0; i &lt; max; i++)<br>162             {<br>163                 Thread.Sleep(2);<br>164                 var rand = new Random((int)DateTime.Now.Ticks).Next(0, int.MaxValue &gt;&gt; 3);<br>165 <br>166                 sw.WriteLine(rand);<br>167             }<br>168             sw.Close();<br>169         }<br>170         #endregion<br>171 <br>172         #region 将数据进行分份<br>173         /// &lt;summary&gt;<br>174         /// 将数据进行分份<br>175         /// &lt;param name=&quot;size&quot;&gt;每页要显示的条数&lt;/param&gt;<br>176         /// &lt;/summary&gt;<br>177         public static int Split(int size)<br>178         {<br>179             //文件总记录数<br>180             int totalCount = 0;<br>181 <br>182             //每一份文件存放 size 条 记录<br>183             List&lt;int&gt; small = new List&lt;int&gt;();<br>184 <br>185             var sr = new StreamReader((Environment.CurrentDirectory + "//demo.txt"));<br>186 <br>187             var pageSize = size;<br>188 <br>189             int pageCount = 0;<br>190 <br>191             int pageIndex = 0;<br>192 <br>193             while (true)<br>194             {<br>195                 var line = sr.ReadLine();<br>196 <br>197                 if (!string.IsNullOrEmpty(line))<br>198                 {<br>199                     totalCount++;<br>200 <br>201                     //加入小集合中<br>202                     small.Add(Convert.ToInt32(line));<br>203 <br>204                     //说明已经到达指定的 size 条数了<br>205                     if (totalCount % pageSize == 0)<br>206                     {<br>207                         pageIndex = totalCount / pageSize;<br>208 <br>209                         small = small.OrderBy(i =&gt; i).Select(i =&gt; i).ToList();<br>210 <br>211                         File.WriteAllLines(Environment.CurrentDirectory + &quot;//&quot; + pageIndex + &quot;.txt&quot;, small.Select(i =&gt; i.ToString()));<br>212 <br>213                         small.Clear();<br>214                     }<br>215                 }<br>216                 else<br>217                 {<br>218                     //说明已经读完了，将剩余的small记录写入到文件中<br>219                     pageCount = (int)Math.Ceiling((double)totalCount / pageSize);<br>220 <br>221                     small = small.OrderBy(i =&gt; i).Select(i =&gt; i).ToList();<br>222 <br>223                     File.WriteAllLines(Environment.CurrentDirectory + &quot;//&quot; + pageCount + &quot;.txt&quot;, small.Select(i =&gt; i.ToString()));<br>224 <br>225                     break;<br>226                 }<br>227             }<br>228 <br>229             return pageCount;<br>230         }<br>231         #endregion<br>232     }<br>233 }</pre><br></div><br></div><br><p> </p><br><p>优先队列：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="">View Code<br><div><br><pre>  1 using System;<br>  2 using System.Collections.Generic;<br>  3 using System.Linq;<br>  4 using System.Text;<br>  5 using System.Diagnostics;<br>  6 using System.Threading;<br>  7 using System.IO;<br>  8 <br>  9 namespace ConsoleApplication2<br> 10 {<br> 11     public class PriorityQueue&lt;T&gt;<br> 12     {<br> 13         /// &lt;summary&gt;<br> 14         /// 定义一个数组来存放节点<br> 15         /// &lt;/summary&gt;<br> 16         private List&lt;HeapNode&gt; nodeList = new List&lt;HeapNode&gt;();<br> 17 <br> 18         #region 堆节点定义<br> 19         /// &lt;summary&gt;<br> 20         /// 堆节点定义<br> 21         /// &lt;/summary&gt;<br> 22         public class HeapNode<br> 23         {<br> 24             /// &lt;summary&gt;<br> 25             /// 实体数据<br> 26             /// &lt;/summary&gt;<br> 27             public T t { get; set; }<br> 28 <br> 29             /// &lt;summary&gt;<br> 30             /// 优先级别 1-10个级别 (优先级别递增)<br> 31             /// &lt;/summary&gt;<br> 32             public int level { get; set; }<br> 33 <br> 34             public HeapNode(T t, int level)<br> 35             {<br> 36                 this.t = t;<br> 37                 this.level = level;<br> 38             }<br> 39 <br> 40             public HeapNode() { }<br> 41         }<br> 42         #endregion<br> 43 <br> 44         #region  添加操作<br> 45         /// &lt;summary&gt;<br> 46         /// 添加操作<br> 47         /// &lt;/summary&gt;<br> 48         public void Eequeue(T t, int level = 1)<br> 49         {<br> 50             //将当前节点追加到堆尾<br> 51             nodeList.Add(new HeapNode(t, level));<br> 52 <br> 53             //如果只有一个节点，则不需要进行筛操作<br> 54             if (nodeList.Count == 1)<br> 55                 return;<br> 56 <br> 57             //获取最后一个非叶子节点<br> 58             int parent = nodeList.Count / 2 - 1;<br> 59 <br> 60             //堆调整<br> 61             UpHeapAdjust(nodeList, parent);<br> 62         }<br> 63         #endregion<br> 64 <br> 65         #region 对堆进行上滤操作，使得满足堆性质<br> 66         /// &lt;summary&gt;<br> 67         /// 对堆进行上滤操作，使得满足堆性质<br> 68         /// &lt;/summary&gt;<br> 69         /// &lt;param name=&quot;nodeList&quot;&gt;&lt;/param&gt;<br> 70         /// &lt;param name=&quot;index&quot;&gt;非叶子节点的之后指针（这里要注意：我们<br> 71         /// 的筛操作时针对非叶节点的）<br> 72         /// &lt;/param&gt;<br> 73         public void UpHeapAdjust(List&lt;HeapNode&gt; nodeList, int parent)<br> 74         {<br> 75             while (parent &gt;= 0)<br> 76             {<br> 77                 //当前index节点的左孩子<br> 78                 var left = 2 * parent + 1;<br> 79 <br> 80                 //当前index节点的右孩子<br> 81                 var right = left + 1;<br> 82 <br> 83                 //parent子节点中最大的孩子节点，方便于parent进行比较<br> 84                 //默认为left节点<br> 85                 var min = left;<br> 86 <br> 87                 //判断当前节点是否有右孩子<br> 88                 if (right &lt; nodeList.Count)<br> 89                 {<br> 90                     //判断parent要比较的最大子节点<br> 91                     min = nodeList[left].level &lt; nodeList[right].level ? left : right;<br> 92                 }<br> 93 <br> 94                 //如果parent节点大于它的某个子节点的话，此时筛操作<br> 95                 if (nodeList[parent].level &gt; nodeList[min].level)<br> 96                 {<br> 97                     //子节点和父节点进行交换操作<br> 98                     var temp = nodeList[parent];<br> 99                     nodeList[parent] = nodeList[min];<br>100                     nodeList[min] = temp;<br>101 <br>102                     //继续进行更上一层的过滤<br>103                     parent = (int)Math.Ceiling(parent / 2d) - 1;<br>104                 }<br>105                 else<br>106                 {<br>107                     break;<br>108                 }<br>109             }<br>110         }<br>111         #endregion<br>112 <br>113         #region 优先队列的出队操作<br>114         /// &lt;summary&gt;<br>115         /// 优先队列的出队操作<br>116         /// &lt;/summary&gt;<br>117         /// &lt;returns&gt;&lt;/returns&gt;<br>118         public HeapNode Dequeue()<br>119         {<br>120             if (nodeList.Count == 0)<br>121                 return null;<br>122 <br>123             //出队列操作，弹出数据头元素<br>124             var pop = nodeList[0];<br>125 <br>126             //用尾元素填充头元素<br>127             nodeList[0] = nodeList[nodeList.Count - 1];<br>128 <br>129             //删除尾节点<br>130             nodeList.RemoveAt(nodeList.Count - 1);<br>131 <br>132             //然后从根节点下滤堆<br>133             DownHeapAdjust(nodeList, 0);<br>134 <br>135             return pop;<br>136         }<br>137         #endregion<br>138 <br>139         #region  对堆进行下滤操作，使得满足堆性质<br>140         /// &lt;summary&gt;<br>141         /// 对堆进行下滤操作，使得满足堆性质<br>142         /// &lt;/summary&gt;<br>143         /// &lt;param name=&quot;nodeList&quot;&gt;&lt;/param&gt;<br>144         /// &lt;param name=&quot;index&quot;&gt;非叶子节点的之后指针（这里要注意：我们<br>145         /// 的筛操作时针对非叶节点的）<br>146         /// &lt;/param&gt;<br>147         public void DownHeapAdjust(List&lt;HeapNode&gt; nodeList, int parent)<br>148         {<br>149             while (2 * parent + 1 &lt; nodeList.Count)<br>150             {<br>151                 //当前index节点的左孩子<br>152                 var left = 2 * parent + 1;<br>153 <br>154                 //当前index节点的右孩子<br>155                 var right = left + 1;<br>156 <br>157                 //parent子节点中最大的孩子节点，方便于parent进行比较<br>158                 //默认为left节点<br>159                 var min = left;<br>160 <br>161                 //判断当前节点是否有右孩子<br>162                 if (right &lt; nodeList.Count)<br>163                 {<br>164                     //判断parent要比较的最大子节点<br>165                     min = nodeList[left].level &lt; nodeList[right].level ? left : right;<br>166                 }<br>167 <br>168                 //如果parent节点小于它的某个子节点的话，此时筛操作<br>169                 if (nodeList[parent].level &gt; nodeList[min].level)<br>170                 {<br>171                     //子节点和父节点进行交换操作<br>172                     var temp = nodeList[parent];<br>173                     nodeList[parent] = nodeList[min];<br>174                     nodeList[min] = temp;<br>175 <br>176                     //继续进行更下一层的过滤<br>177                     parent = min;<br>178                 }<br>179                 else<br>180                 {<br>181                     break;<br>182                 }<br>183             }<br>184         }<br>185         #endregion<br>186 <br>187         #region 获取元素并下降到指定的level级别<br>188         /// &lt;summary&gt;<br>189         /// 获取元素并下降到指定的level级别<br>190         /// &lt;/summary&gt;<br>191         /// &lt;returns&gt;&lt;/returns&gt;<br>192         public HeapNode GetAndDownPriority(int level)<br>193         {<br>194             if (nodeList.Count == 0)<br>195                 return null;<br>196 <br>197             //获取头元素<br>198             var pop = nodeList[0];<br>199 <br>200             //设置指定优先级（如果为 MinValue 则为 -- 操作）<br>201             nodeList[0].level = level == int.MinValue ? --nodeList[0].level : level;<br>202 <br>203             //下滤堆<br>204             DownHeapAdjust(nodeList, 0);<br>205 <br>206             return nodeList[0];<br>207         }<br>208         #endregion<br>209 <br>210         #region 获取元素并下降优先级<br>211         /// &lt;summary&gt;<br>212         /// 获取元素并下降优先级<br>213         /// &lt;/summary&gt;<br>214         /// &lt;returns&gt;&lt;/returns&gt;<br>215         public HeapNode GetAndDownPriority()<br>216         {<br>217             //下降一个优先级<br>218             return GetAndDownPriority(int.MinValue);<br>219         }<br>220         #endregion<br>221 <br>222         #region 返回当前优先队列中的元素个数<br>223         /// &lt;summary&gt;<br>224         /// 返回当前优先队列中的元素个数<br>225         /// &lt;/summary&gt;<br>226         /// &lt;returns&gt;&lt;/returns&gt;<br>227         public int Count()<br>228         {<br>229             return nodeList.Count;<br>230         }<br>231         #endregion<br>232     }<br>233 }</pre><br></div><br></div><br><p> </p><img src="http://www.cnblogs.com/huangxincheng/aggbug/2824943.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/huangxincheng/archive/2012/12/19/2824943.html">本文链接</a></p></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
