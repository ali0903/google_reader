<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>图解HTTPS</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>图解HTTPS</h2>
<p class="meta">2012-12-16 21:39</p>

<div class="post">
<h2>图解HTTPS</h2>

<h3>by</h3>

<h3>at 2012-12-16 13:39:32</h3>

<h3>original <a href="http://kb.cnblogs.com/page/112881/">http://kb.cnblogs.com/page/112881/</a></h3>

<p>　　我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取。所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。</p>


<p>　　<strong>HTTPS简介</strong></p>


<p>　　HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体是如何进行加密，解密，验证的，且看下图。</p>


<p><a href="http://www.jobbole.com/attachment.php?attachmentid=4035&amp;d=1314144789" rel="Lightbox_1309"><img style="display:block;margin-left:auto;margin-right:auto" src="http://pic001.cnblogs.com/images/2011/24634/2011082417242348.png" alt=""></a>　　<strong>1. 客户端发起HTTPS请求</strong></p>


<p>　　这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。</p>


<p>　　<strong>2. 服务端的配置</strong></p>


<p>　　采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p>


<p>　　<strong>3. 传送证书</strong></p>


<p>　　这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p>


<p>　　<strong>4. 客户端解析证书</strong></p>


<p>　　这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p>


<p>　　<strong>5. 传送加密信息</strong></p>


<p>　　这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p>


<p>　　<strong>6. 服务段解密信息</strong></p>


<p>　　服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p>


<p>　　<strong>7. 传输加密后的信息</strong></p>


<p>　　这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p>


<p>　　<strong>8. 客户端解密信息</strong></p>


<p>　　客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</p>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
