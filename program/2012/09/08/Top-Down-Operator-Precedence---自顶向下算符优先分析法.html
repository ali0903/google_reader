<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Top Down Operator Precedence - 自顶向下算符优先分析法</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>Top Down Operator Precedence - 自顶向下算符优先分析法</h2>
<p class="meta">2012-09-08 23:42</p>

<div class="post">
<h2>Top Down Operator Precedence - 自顶向下算符优先分析法</h2>

<h3>by 司徒正美</h3>

<h3>at 2012-09-08 15:42:00</h3>

<h3>original <a href="http://www.cnblogs.com/rubylouvre/archive/2012/09/08/2657682.html">http://www.cnblogs.com/rubylouvre/archive/2012/09/08/2657682.html</a></h3>

<p>这是一篇翻译，原文来自 <a href="http://javascript.crockford.com/tdop/tdop.html" title="Top Down Operator Precedence">Top Down Operator Precedence</a>。由于毕设搞的就是相关技术，所以近期花了块两天时间把文章翻译了，实在够累，希望大侠看见，不吝赐教！</p>


<p>作者：<a href="http://www.crockford.com/" title="Douglas Crockford">Douglas Crockford</a></p>


<p><strong>简介</strong></p>


<p>1973年，波士顿 <a href="http://boole.stanford.edu/pratt.html">Vaughan Pratt</a> 在 <a href="http://www.acm.org/sigs/sigplan/popl.htm">编程语言原则座谈会(Principles of Programming Languages Symposium)</a> 第一期年刊上发表 <a href="http://portal.acm.org/citation.cfm?id=512931">自顶向下算符优先(Top Down Operator Precedence)</a>。在论文中 Pratt 描述了一种结 合递归向下(Recursive Descent)方法 以及  <a href="http://sigact.acm.org/floyd/">Floyd</a> 算符优先(Operator Precedence)方法 优良特性的解析技术。它非常易用。同时，它看起来很像递归向下，但是却可用更少代码实现以及更高效的性能。他声称这项技术非常易懂，便于实现，方便使用，性能特出，同时也很灵活。它是动态的，支持真正语言级别的扩展。</p>


<p>但是很奇怪，对于编译器编译来说如此优异的方法如今却完全被忽略了。为什么会这样呢？Pratt 在论文中指出，由于更早出现的 BNF 语法以及其各种各样的变种版本，伴随着与之相关的自动机和定理的出现，限制了自动机这种不可见领域的多样发展。</p>


<p>另外一种解释说，他的这种技术只是在应用于动态的，函数式编程语言上才会有很高的效率。将它应用于静态程序语言上则略先困难。在论文中，Pratt 用 LISP 语言基本毫不费力地就从词法单元流中解析出来了语法树。但是这种解析技术却没有在 LISP 社区中体现出太大的价值。自从 LISP 诞生之日起，就有出现很多让它拥有算法似的语法(ALGOL-like syntax)，其中包括 <a href="http://zane.brouhaha.com/%7Ehealyzh/doc/cgol.doc.txt">Pratts 的 CGOL</a>，<a href="http://community.computerhistory.org/scc/projects/LISP/index.html#LISP_2_">LISP 2</a>，<a href="ftp://reports.stanford.edu/pub/cstr/reports/cs/tr/68/92/CS-TR-68-92.pdf">MLISP</a>，<a href="http://www.opendylan.org/">Dylan</a>，<a href="http://community.computerhistory.org/scc/projects/LISP/interlisp/Teitelman-3IJCAI.pdf">Interlisp 的 Clisp</a> 以及 <a href="http://www-formal.stanford.edu/jmc/history/lisp/lisp.html">McCarthy 的 原始 M 表达式(original M-expressions)</a>。但是最终都没有被接纳。LISP 社区发现协调程序与数据比富裕表达的语法更有价值。但是主流编程社区依然热衷于自己的语法，所以 LISP 从来没被主流接纳过。Pratt 的技术需要一门动态语言，但是动态语言社区历来都没使用过方便 Pratt 的技术解析的那种语法。</p>


<p><strong>JavaScript</strong></p>


<p>随着 JavaScript 的诞生这种情况发生了改变。JavaScript 是一门动态的函数式语言，但是从语法上看它明显是 C 语言风格家族的一员。它是一门动态语言且拥有社区都喜欢的语法。</p>


<p>JavaScript 也拥有面向对象特性。Pratt 1973年的论文预测面向对象将会是一种趋势，但是却缺乏一套富于表达的描述方法。JavaScript 是一门非常适合使用 Pratt 技术的语言。接下来我会用  JavaScript 快速实现一个简单的解析器。</p>


<p>在这么短小的一个章节里，我们没有足够的时间来实现整个 JavaScript，同时我们基本上也不会想去实现，因为语言里面的有一部分是糟粕。但是语言里面依然有一些考虑周全的精华元素。我们将会编写一个只能解析 简化版 JavaScript(Simplified JavaScript) 的解析器。同时我们也会使用简化版的 JavaScript 来编写这个解析器。简化版的 JavaScript 只包含精华的部分，包括：</p>


<ul><li>函数是一级对象。在简化版 JavaScript 中，函数是拥有词法作用域的 lambda 表达式。</li><li>原型继承的动态对象。对象是类无关的。我们可以使用普通的赋值方法像任何一个对象中添加一个成员。一个对象可以从另外一个对象中继承其成员。</li><li>拥有对象直接量和数组直接量。对于创建新的对象和数组，这是一种绝佳的描述方法。JavaScript 直接量是 <a href="http://www.json.org/">JSON</a> 数据接口格式的灵感来源。</li></ul>


<p>我们将充分利用 JavaScript 原型继承的先天特性让词法单元继承自符号对象(symbols)。我们的实现依赖于 <code>Object.create</code> 方法（这个方法是创建一个新对象，并从一个已存在的对象中继承成员）以及一个词法单元生成器(tokenizer)（这个方法是从一个字符串里面生成一个包含简单词法单元对象的数组）。我们在这个词法单元的数组中逐步前进，生成我们的解析树。</p>


<p><strong>符号表</strong></p>


<p>每一个词法单元，例如操作符和标识符，都继承自一个符号对象。我们把所有的符号都保存在 <code>symbol_table</code> 对象（这个符号表是用来判断我们语言中词法单元的类型）中。</p>


<p>var symbol_table = {};<br><p>这个 <code>original_symbol</code> 对象是所有其他符号的原型。它其中的方法同时是被用来重写(overridden)的。（我们将会在接下来的优先级一节来解释 <code>nud</code> 和 <code>led</code> 的作用以及约束力的含义）</p>var original_symbol = {<br>    nud: function() {<br>        this.error('Undefined.');<br>    },<br>    led: function(left) {<br>        this.error('Missing operator.');<br>    }<br>};<br><p>让我们来定义一个生成符号的函数。它包含一个符号 <code>id</code> 和一个可选的约束力值，默认为0。函数返回一个对应 <code>id</code> 的符号对象。如果这个符号已经存在于 <code>symbol_table</code> 中，则函数就直接返回那个符号对象。否则，就创建一个继承于 <code>original_symbol</code> 的符号对象，存储在符号表中，并返回这个对象。一个符号对象初始的时候包含一个 id，一个符号值，一个左约束力，以及其他从 <code>original_symbol</code> 中继承的元素。</p>var symbol = function(id, bp) {<br>    var s = symbol_table[id];<br>    bp = bp || 0;<br>    if (s) {<br>        if (bp &gt;= s.lbp) {<br>            s.lbp = bp;<br>        }<br>    } else {<br>        s = Object.create(original_symbol);<br>        s.id = s.value = id;<br>        s.lbp = bp;<br>        symbol_table[id] = s;<br>    }<br>    return s;<br>};<br><p>下列是常见的分隔符号和结束符号。</p>symbol(':');<br>symbol(';');<br>symbol(',');<br>symbol(')');<br>symbol(']');<br>symbol('}');<br>symbol('else');<br><p><code>(end)</code> 符号表示词法单元流的结束。<code>(name)</code> 符号是新命名符号的原型，例如变量名。包含在 id 两边的括号主要是用来防止与用户定义的词法单元冲突。</p>symbol('(end)');<br>symbol('(name)');<br><p><strong>词法单元</strong></p><p>我们假设源代码已经被转换成一个包含简单词法单元对象（<code>tokens</code>）的数组，每一个对象有一个类型(<code>type</code>)成员（包含名称(<code>name</code>)，字符串(<code>string</code>)，数字(<code>number</code>)或者操作符(<code>operator</code>)）以及一个值(<code>value</code>)成员（是字符串或者数字）。</p><p><code>token</code> 变量总是指向当前的词法单元。</p>var token;<br><p><code>advance</code> 方法从数组中的下一个简单词法单元创建一个新的词法单元对象，并且赋值给 <code>token</code> 变量。它拥有一个可选参数 <code>id</code> 用来检查是否和之前一个词法单元匹配。新的词法单元对象的原型是当前作用域中的 <code>(name)</code> 词法单元或者是符号表中的一个符号。新的词法单元的 <code>arity</code>(运算元) 是 名称(<code>name</code>)，直接量(<code>literal</code>)或者操作符(<code>operator</code>)。<code>arity</code> 随后也可能根据我们了解更多该词法单元在程序中的角色而变化成二元运算(<code>binary</code>)，一元运算(<code>unary</code>)或者语句(<code>statement</code>)。</p>var advance = function(id) {<br>    var a, o, t, v;<br>    if (id &amp;&amp; token.id !== id) {<br>        token.error('Expected "' + id + '".');<br>    }<br>    if (token_nr &gt;= tokens.length) {<br>        token = symbol_table['(end)'];<br>        return;<br>    }<br>    t = tokens[token_nr];<br>    token_nr += 1;<br>    v = t.value;<br>    a = t.type;<br>    if (a === 'name') {<br>        o = scope.find(v);<br>    } else if (a === 'operator') {<br>        o = symbol_table[v];<br>        if (!o) {<br>            t.error('Unknown operator.');<br>        }<br>    } else if (a === 'string' || a === 'number') {<br>        a = 'literal';<br>        o = symbol_table['(literal)'];<br>    } else {<br>        t.error('Unexpected token.');<br>    }<br>    token = Object.create(o);<br>    token.value = v;<br>    token.arity = a;<br>    return token;<br>};<br><p><span></span></p><p><strong>作用域</strong></p><p>大部分语言都为定义新符号准备了一些描述方法（例如变量名）。在非常简单的语言中，当我们遇到一个新的单词时，我们给它一个定义然后放到符号表中。在一些更加复杂语言中，我们可以使用作用域，方便程序员控制这个变量的生存周期和可见性。</p><p>作用域就是程序中变量被定义和可访问的一块区域。当前作用域可以被嵌套进其他作用域中。定义在内层作用域的变量对于外层作用域是不可见的。</p><p>我们将当前作用域对象保存在 <code>scope</code> 变量中。</p>var scope;<br><p><code>original_scope</code> 是所有作用域对象的原型。它包含一个 <code>define</code> 方法用于在作用域中定义新的变量。<code>define</code> 方法将一个名称词法单元转成一个变量词法单元。如果这个变量已经在作用域中定义过或者这个名字被用作保留字，那么将会报错。</p>var itself = function() {<br>    return this;<br>};<br><br>var original_scope = {<br>    define: function(n) {<br>        var t = this.def[n.value];<br>        if (typeof t === 'object') {<br>            n.error(t.reserved ? 'Already reserved.' : 'Already defined.');<br>        }<br>        this.def[n.value] = n;<br>        n.reserved = false;<br>        n.nud = itself;<br>        n.led = null;<br>        n.std = null;<br>        n.lbp = 0;<br>        n.scope = scope;<br>        return n;<br>    },<br><p><code>find</code> 方法用于查找一个名称的定义。这个方法会从当前作用域开始查找，如果有必要的话，会顺着该作用域的父作用域链查找直到最后到达符号表。如果没有找到该名称的定义，则返回 <code>symbol_table['(name)']</code>。</p><p><code>find</code> 方法还会测试查找到的值，判断其不是 <code>undefined</code> （可能会导致未声明的命名），也不是 <code>function</code> （可能与被继承的方法导致冲突）。</p>    find: function(n) {<br>        var e = this, o;<br>        while (true) {<br>            o = e.def[n];<br>            if (o &amp;&amp; typeof o !== &#39;function&#39;) {<br>                return e.def[n];<br>            }<br>            e = e.parent;<br>            if (!e) {<br>                o = symbol_table[n];<br>                return o &amp;&amp; typeof o !== &#39;function&#39; ?<br>                            o : symbol_table['(name)'];<br>            }<br>        }<br>    },<br><p><code>pop</code> 方法用于结束一个作用域，回到其父作用域中。</p>    pop: function() {<br>        scope = this.parent;<br>    }<br><p><code>reserve</code> 方法用于声明一个名称已经在当前作用域中被保留为关键字。</p>    reserve: function(n) {<br>        if (n.arity !== 'name' || n.reserved) {<br>            return;<br>        }<br>        var t = this.def[n.value];<br>        if (t) {<br>            if (t.reserved) {<br>                return;<br>            }<br>            if (t.arity === 'name') {<br>                n.error('Already defined.');<br>            }<br>        }<br>        this.def[n.value] = n;<br>        n.reserved = true;<br>    }<br>};<br><p>我们需要为保留字准备一个策略。在某些语言中，被用于程序结构的词（例如 <code>if</code>）被当作保留字，不能用作变量的名称。由于我们解析器的灵活性，允许我们有一个更有效的策略。例如，我们可以说，在任何一个函数中，所有名称要么用作结构的单词，要么当作变量，但是不可能同时成为两者。那么我们只需当一个名称被用作保留词的时候，才将它保留在局部。这样的话，对于语言的设计者会更好，因为当要为语言添加新的结构单词时，不会破坏现有的程序，同样对于程序员也是好事，他们对于名称的使用不再受限于无关的约束。</p><p>每当我们想要为一个函数或者一个代码块建立一个新的作用域，我们调用 <code>new_scope</code> 函数，这将新建一个对象实例，其原型指向 <code>original_scope</code> 对象。</p>var new_scope = function() {<br>    var s = scope;<br>    scope = Object.create(original_scope);<br>    scope.def = {};<br>    scope.parent = s;<br>    return scope;<br>};<br><p><strong>优先级</strong></p><p>词法单元对象上包含一些可以做优先级判断，匹配其他词法单元已经创建语法树（在未来更大的项目中，可以包含类型判断，代码优化及生成）的方法。优先级判断最基本的问题是：在两个操作符直接给定几个操作数，操作数是应该从左到右运算还是从右到左？</p>d A e B f<br><p>如果 <code>A</code> 和 <code>B</code> 是运算符的话，操作数 <code>e</code> 是应该绑定在 <code>A</code> 还是 <code>B</code> 上？换句话说，也就是这个意思：</p>(d A e) B f    or    d A (e B f)    ?<br><p>最终，这个复杂的解析过程给出了二义性的解决办法。我们在这儿开发用到的解决技术是这样的，每一个词法单元对象都有一个约束力(binding powers)（或者也可以说是优先级）作为成员，以及两个叫做 <code>nud</code>（空判定符）以及 <code>lef</code>（做判定符）的简单方法。<code>nud</code> 不管词法单元的左侧，而 <code>led</code> 却关注。<code>nud</code> 方法常用于值（例如变量和直接量）以及前缀操作符。<code>led</code> 方法常用于中缀和后缀运算符。一个词法单元也可以同时拥有 <code>nud</code> 和 <code>led</code> 方法。例如，<code>-</code> 及可以当作前缀运算符（负号），也可以当作中缀运算符（减号），所以它既拥有 <code>nud</code> 方法也拥有 <code>led</code> 方法。</p><p>在我们的论文中，我们使用这样的优先级：</p>0   最低优先级运算符，例如 ;<br>10 赋值运算符，例如 =<br>20 ?<br>30 || &amp;&amp;<br>40 关系运算符，例如 ===<br>50 + -<br>60 * /<br>70 一元运算符，例如 !<br>80 . [ (<br><p><strong>表达式</strong></p><p>Pratt 技术的核心就是 <code>expression</code> 函数。它需要一个右约束力（right binding power）参数，用来控制它对右侧词法单元有多大的约束力。</p>var expression = function(rbp) {<br>    var left;<br>    var t = token;<br>    advance();<br>    left = t.nud();<br>    while (rbp &lt; token.lbp) {<br>        t = token;<br>        advance();<br>        left = t.led(left);<br>    }<br>    return left;<br>};<br><p><code>expression</code> 调用 <code>token</code> 的 <code>nud</code> 方法。<code>nud</code> 方法用于处理直接量，变量和前缀运算符。只要右约束力小于下一个词法单元的左约束力，那么就对接下来的词法单元调用 <code>led</code> 方法。<code>led</code> 方法用于处理中缀和后缀运算符。这一过程是递归的，因为 <code>nud</code> 和 <code>led</code> 方法都会调用 <code>expression</code>。</p><p><strong>前缀运算符</strong></p><p><code>+</code> 是一个前缀运算符，所以他有一个 <code>led</code> 方法用于将 <code>+</code> 左侧和右侧的词法单元对象转换为树的两支（<code>first</code> 和 <code>second</code>）。左侧的操作数传入 <code>led</code> 中运算，在运算中通过调用 <code>expression</code> 函数来获得右侧操作数。</p>symbol('+', 50).led = function(left) {<br>    this.first = left;<br>    this.second = expression(50);<br>    this.arity = 'binary';<br>    return this;<br>};<br><p>符号 <code><em></code> 与 <code>+</code> 很类似，除了 <code>id</code> 和约束力不同之外。它拥有更大的约束力，由于它优先级更高。</p>symbol('</em>', 60).led = function(left) {<br>    this.first = left;<br>    this.second = expression(60);<br>    this.arity = 'binary';<br>    return this;<br>};<br><p>并不是所有的中缀运算符都与这相似，但是大部分都会是这样的，所以为了让我们的工作更简单，我们定义了一个 <code>infix</code> 函数，用来帮助我们创建中缀运算符的符号对象。<code>infix</code> 函数需要 <code>id</code>，约束力，以及一个可选的 <code>led</code> 函数作为参数。如果没有提供 <code>led</code> 函数，那么 <code>infix</code> 函数提供一个大部分情况下都有用的 <code>led</code> 默认函数。</p>var infix = function(id, bp, led) {<br>    var s = symbol(id, bp);<br>    s.led = led || function(left) {<br>        this.first = left;<br>        this.second = expression(bp);<br>        return this;<br>    };<br>    return s;<br>};<br><p>这就运行我们使用一种更具表达性的风格来指定中缀运算符：</p>infix('+', 50);<br>infix('-', 50);<br>infix('*', 60);<br>infix('/', 60);<br><p><code>===</code> 是 JavaScript 中的精确等于的运算符。</p>infix('===', 40);<br>infix('!==', 40);<br>infix(&#39;&lt;&#39;, 40);<br>infix(&#39;&lt;=&#39;, 40);<br>infix(&#39;&gt;&#39;, 40);<br>infix(&#39;&gt;=&#39;, 40);<br><p>三元运算符需要三个表达式，用 <code>?</code> 和 <code>:</code> 分隔。这不是一个普通的前缀运算符，所以我们需要提供 <code>led</code> 函数。</p>infix('?', 20, function(left) {<br>    this.first = left;<br>    this.second = expression(0);<br>    advance(':');<br>    this.third = expression(0);<br>    this.arity = 'ternary';<br>    return this;<br>});<br><p><code>.</code> 运算符用于选择一个对象的成员。右侧的词法单元必须是一个名称且会被当作直接量使用。</p>infix('.', 80, function(left) {<br>    this.first = left;<br>    if (token.arity !== 'name') {<br>        token.error('Expected a property name.');<br>    }<br>    token.arity = 'literal';<br>    this.second = token;<br>    this.arity = 'binary';<br>    advance();<br>    return this;<br>});<br><p><code>[</code> 运算符用于动态地从一个对象或数组中选择成员。右侧的表达式必须有 <code>]</code> 结尾。</p>infix('[', 80, function(left) {<br>    this.first = left;<br>    this.second = expression(0);<br>    this.arity = 'binary';<br>    advance(']');<br>    return this;<br>});<br><p>上述这些中缀运算符都是左结合的。我们还需要创造右结合的运算符，例如：短路逻辑运算符，这是通过减少右约束力来实现的。</p>var infixr = function(id, bp, led) {<br>    var s = symbol(id, bp);<br>    s.led = led || function(left) {<br>        this.first = left;<br>        this.second = expression(bp - 1);<br>        this.arity = 'binary';<br>        return this;<br>    };<br>    return s;<br>};<br><p>如果 <code>&amp;&amp;</code> 运算符的第一个操作数为假，那么就返回第一个操作数。否则返回第二个。如果 <code>||</code> 运算符的第一个操作数为真，那么就返回第一个操作数，否则返回第二个。（这里“假”的含义包括数字 <code>0</code>，空字符串 <code>''</code>以及 <code>false</code> 值和 <code>null</code> 值。所有其他值（包括所有的对象）都是“真”。）</p>infixr(&#39;&amp;&amp;&#39;, 30);<br>infixr('||', 30);<br><p><strong>前缀运算符</strong></p><p>我们用于右结合中缀运算符的代码，可以适配到前缀运算符。前缀运算符是右结合的。由于前缀运算符不需要项做绑定，所以没有左约束力。前缀运算符同时也可用作保留关键字。</p>var prefix = function(id, nud) {<br>    var s = symbol(id);<br>    s.nud = nud || function() {<br>        scope.reserve(this);<br>        this.first = expression(70);<br>        this.arity = 'unary';<br>        return this;<br>    };<br>    return s;<br>};<br><br>prefix('-')；<br>prefix('!');<br>prefix('typeof');<br><p><code>(</code> 的 <code>nud</code> 函数需要调用 <code>advance(')')</code> 去匹配对应的 <code>)</code> 词法单元。由于 <code>nud</code> 函数返回内部表达式，所以<code>(</code> 词法单元不会成为语法树的一部分。</p>prefix('(', function() {<br>    var e = expression(0);<br>    advance(')');<br>    return e;<br>});<br><p><strong>赋值运算符</strong></p><p>我们可以用 <code>infixr</code> 来定义赋值运算符，但是我们还需要对 <code>assignment</code> 函数做一些特殊定制，来让它多做两件事：测试左侧操作数，确保是正确的左值(lvalue)，添加一个 <code>assignment</code> 成员，之后便可以快速地判断出赋值语句。</p>var assignment = function(id) {<br>    return infix(id, 10, function(left) {<br>        if (left.id !== &#39;.&#39; &amp;&amp; left.id !== &#39;[&#39; &amp;&amp;<br>                left.arity !== 'name') {<br>            left.error('Bad lvalue.');<br>        }<br>        this.first = left;<br>        this.second = expression(9);<br>        this.assigment = true;<br>        this.arity = 'binary';<br>        return this;<br>    });<br>};<br><br>assignment('=');<br>assignment('+=');<br>assignment('-=');<br><p>需要注意的是，我们这里的实现利用了一些列的继承模式，<code>assignment</code> 返回调用 <code>infixr</code> 的结果，而 <code>infixr</code> 则返回调用 <code>symbol</code> 的结果。</p><p><strong>常量</strong></p><p><code>constant</code> 函数用于构建语言内部的常量。<code>nud</code> 方法将一个名称词法单元转换成直接量词法单元。</p>var constant = function(s, v) {<br>    var x = symbol(s);<br>    x.nud = function() {<br>        scope.reserve(this);<br>        this.value = symbol_table[this.id].value;<br>        this.arity = 'literal';<br>        return this;<br>    };<br>    x.value = v;<br>    return x;<br>};<br><br>constant('true', true);<br>constant('false', false);<br>constant('null', null);<br><br>constant('pi', 3.141592653589793);<br><p><code>(literal)</code> 是所有字符串直接量和数字直接量的原型。直接量词法单元的 <code>nud</code> 方法返回词法单元自身。</p>symbol('(literal)').nud = itself;<br><p><strong>语句</strong></p><p>Pratt 原始的陈述体系只针对那些所有东西都是表达式的函数式语言有效。大部分主流语言不像那些层层嵌套的表达式一样，而是拥有语句的概念。只要为词法单元再添加一个 <code>std</code>（语句描述符）方法，就可以很轻松地处理语句。<code>std</code> 很像 <code>nud</code>，除了它只在语句开头调用外。</p><p><code>statement</code> 方法解析一个语句。如果当前词法单元有 <code>std</code> 方法，那么这个词法单元就会被保留做关键词，然后调用 <code>std</code> 方法。否则，我们则假设一个以分号结尾的表达式语句。为了代码更好的可读性，我们只允许赋值或者调用的表达式语句。</p>var statement = function() {<br>    var n = token, v;<br>    if (n.std) {<br>        advance();<br>        scope.reserve(n);<br>        return n.std();<br>    }<br>    v = expression(0);<br>    if (!v.assigment &amp;&amp; v.id !== &#39;(&#39;) {<br>        v.error('Bad expression statement.');<br>    }<br>    advance(';');<br>    return v;<br>};<br><p><code>statements</code> 函数解析所有语句直到遇到 <code>(end)</code> 或者 <code>}</code> 这些表示块结束的标识符。这个函数的返回值是一个语句，或者包含很多语句的一个数组，或者是 <code>null</code> 用来表示没有语句出现。</p>var statements = function() {<br>    var a = [], s;<br>    while (true) {<br>        if (token.id === '}' || token.id === '(end)') {<br>            break;<br>        }<br>        s = statement();<br>        if (s) {<br>            a.push(s);<br>        }<br>    }<br>    return a.length === 0 ? null : a.lenght === 1 ? a[0] : a;<br>};<br><p><code>stmt</code> 函数用于将语句符号添加到符号表中。需要两个参数，语句的 <code>id</code> 和 <code>std</code> 函数。</p>var stmt = function(s, f) {<br>    var x = symbol(s);<br>    x.std = f;<br>    return x;<br>};<br><p>语句块是用花括号括起来的一些列语句，同时也要给它们一个新的作用域。（JavaScript 没有块级作用域，简化版的 JavaScript 修正了这一点。）</p>stmt('{', function() {<br>    new_scope();<br>    var a = statements();<br>    advance('}');<br>    scope.pop();<br>    return a;<br>});<br><p><code>block</code> 函数用于解析语句块。</p>var block = function() {<br>    var t = token;<br>    advance('{');<br>    return t.std();<br>};<br><p><code>var</code> 语句用于在当前语句块里定义一个或多个变量。每一个名称后面跟一个可选的 <code>=</code> 用于初始化表达式。</p>stmt('var', function() {<br>    var a = [], n, t;<br>    while (true) {<br>        n = token;<br>        if (n.arity !== 'name') {<br>            n.error('Expected a new variable name.');<br>        }<br>        scope.define(n);<br>        advance();<br>        if (token.id === '=') {<br>            t = token;<br>            advance('=');<br>            t.first = n;<br>            t.second = expression(0);<br>            t.arity = 'binary';<br>            a.push(t);<br>        }<br>        if (token.id !== ',') {<br>            break;<br>        }<br>        advance(',');<br>    }<br>    advance(';');<br>    return a.length === 0 ? null : a.length === 1 ? a[0] : a;<br>});<br><p><code>while</code> 语句用于定义循环。它的圆括号中包含一个语句，接下来是一个语句块。</p>stmt('while', function() {<br>    advance('(');<br>    this.first = expression(0);<br>    advance(')');<br>    this.second = block();<br>    this.arity = 'statement';<br>    return this;<br>});<br><p><code>if</code> 语句允许有条件地执行。如果我们看见 <code>else</code> 符号后面还有一个语句块，那么我们就接着解析下面的语句块或者是 <code>if</code> 语句。</p>stmt('if', function() {<br>    advance('(');<br>    this.first = expression(0);<br>    advance(')');<br>    this.second = block();<br>    if (token.id === 'else') {<br>        scope.reverse(token);<br>        advance('else');<br>        this.third = token.id === 'if' ? statement() : block();<br>    } else {<br>        this.third = null;<br>    }<br>    this.arity = 'statement';<br>    return this;<br>});<br><p><code>break</code> 语句用于跳出循环。</p>stmt('break', function() {<br>    advance(';');<br>    if (token.id !== '}') {<br>        token.error('Unreachable statement.');<br>    }<br>    this.arity = 'statement';<br>    return this;<br>});<br><p><code>return</code> 语句用于从函数中返回，它有一个可选的表达式。</p>stmt('return', function() {<br>    if (token.id !== ';') {<br>        this.first = expression(0);<br>    }<br>    advance(';');<br>    if (token.id !== '}') {<br>        token.error('Unreachable statement.');<br>    }<br>    this.arity = 'statement';<br>    return this;<br>});<br><p><strong>函数</strong></p><p>函数是可执行的对象。函数有一个可选的函数名（因此它可以递归地调用自己），用圆括号括起来的用逗号分隔的参数以及用花括号括起来的有一系列语句组成的函数体。函数有自己的作用域。</p>prefix('function', function() {<br>    var a = [];<br>    new_scope();<br>    if (token.arity === 'name') {<br>        scope.define(token);<br>        this.name = token.value;<br>        advance();<br>    }<br>    advance('(');<br>    if (tokend.id !== ')') {<br>        while (true) {<br>            if (token.arity !== 'name') {<br>                token.error('Expected a parameter name.');<br>            }<br>            scope.define(token);<br>            a.push(token);<br>            advance();<br>            if (token.id !== ',') {<br>                break;<br>            }<br>            advance(',');<br>        }<br>    }<br>    this.first = a;<br>    advance(')');<br>    advance('{');<br>    this.second = statements();<br>    advance('}');<br>    this.arity = 'function';<br>    scope.pop();<br>    return this;<br>});<br><p>函数使用 <code>(</code> 运算符调用的。其中包含零个或多个用逗号分隔的参数。我们需要判断左侧操作数是否是一个不可能为函数的表达式。</p>infix('(', function(left) {<br>    var a = [];<br>    if (left.id === '.' || left.id === '[') {<br>        this.arity = 'ternary';<br>        this.first = left.first;<br>        this.second = left.sconed;<br>        this.third = a;<br>    } else {<br>        this.arity = 'binary';<br>        this.first = left;<br>        this.second = a;<br>        if ((left.arity !== &#39;unary&#39; || left.id !== &#39;function&#39;) &amp;&amp;<br>                left.arity !== &#39;name&#39; &amp;&amp; left.id !== &#39;(&#39; &amp;&amp;<br>                left.id !== &#39;&amp;&amp;&#39; &amp;&amp; left.id !== &#39;||&#39; &amp;&amp; left.id !== &#39;?&#39;) {<br>            left.error('Expected a variable name.');<br>        }<br>    }<br>    if (token.id !== ')') {<br>        while (true) {<br>            a.push(expression(0));<br>            if (token.id !== ',') {<br>                break;<br>            }<br>            advance(',');<br>        }<br>    }<br>    advance(')');<br>    return this;<br>});<br><p><code>this</code> 符号是一个特殊的变量。当函数是以方法的形式被调用，那它就指向那个对象。</p>symbol('this').nud = function() {<br>    scope.reserve(this);<br>    this.arity = 'this';<br>    return this;<br>};<br><p><strong>对象直接量</strong></p><p>数组直接量是由一对方括号括起来，其中包含零个或多个由逗号分隔的表达式。每一个表达式都是可计算的，且他们的计算结果就是数组的值。</p>prefix('[', function() {<br>    var a = [];<br>    if (token.id !== ']') {<br>        while (true) {<br>            a.push(expression(0));<br>            if (token.id !== ',') {<br>                break;<br>            }<br>            advance(',');<br>        }<br>    }<br>    advance(']');<br>    this.first = a;<br>    this.arity = 'unary';<br>    return this;<br>});<br><p>对象直接量是由一对花括号括起来，其中包含一个或多个由逗号分隔的键值对组成。每一个键值对是由一个分号分隔键与值。且键必须是一个直接量或者是可以被当作直接量的名称组成。</p>prefix('{', function() {<br>    var a = [];<br>    if (token.id !== '}') {<br>        while (true) {<br>            var n = token;<br>            if (n.arity !== &#39;name&#39; &amp;&amp; n.arity !== &#39;literal&#39;) {<br>                token.error('Bad key.');<br>            }<br>            advance();<br>            advance(':');<br>            var v = expression(0);<br>            v.key = n.value;<br>            a.push(v);<br>            if (token.id !== ',') {<br>                break;<br>            }<br>            advance(',');<br>        }<br>    }<br>    advance('}');<br>    this.first = a;<br>    this.arity = 'unary';<br>    return this;<br>});<br><p><strong>未完成的以及一些想法</strong></p><p>语法树可以被代码生成器解析，或者直接交由翻译器执行。处理语法树是很简单的，同样写程序创建一棵语法树也很简单。</p><p>我们可以让 <code>infix</code> 函数接受一个 <code>opcode</code> 参数，这样有助于代码生成。我们同样也可以添加一些其他方法来支持常量折叠或者代码生成。</p><p>我们还可以继续添加更多的语句支持（例如，<code>for</code>，<code>switch</code> 以及 <code>try</code>），语句标签，更多的错误检查，错误恢复以及更多的运算符。我们还可以添加类型规范已经类型推断。</p><p>我们可以让我们的语言更具扩展性。可以让定义变量更加方便，同样也可以让程序员自己添加新的运算符和语句。</p><p><a href="http://javascript.crockford.com/tdop/index.html">快来试试我们在这篇论文中描述的解析器。</a></p><p>关于解析器的其他技术例子可以在 <a href="http://jslint.com/">JSLint</a> 中找到。</p><img src="http://www.cnblogs.com/rubylouvre/aggbug/2657682.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/rubylouvre/archive/2012/09/08/2657682.html">本文链接</a></p></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
