<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>JavaScript原型继承的陷阱</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>JavaScript原型继承的陷阱</h2>
<p class="meta">02 Sep 2012</p>

<div class="post">
<h2>JavaScript原型继承的陷阱</h2>

<h3>by snandy</h3>

<h3>at 2012-09-02 12:01:00</h3>

<h3>original <a href="http://www.cnblogs.com/snandy/archive/2012/09/02/2666747.html">http://www.cnblogs.com/snandy/archive/2012/09/02/2666747.html</a></h3>

<p>JavaScript默认采用原型继承。虽然没有类(class)的概念，它的函数(function)可以充当构造器(constructor)。构造器结合this，new可以构建出类似Java的类。因此，JavaScript通过扩展自身能模拟<a href="http://www.cnblogs.com/snandy/archive/2011/03/09/1977804.html">类式(class-based)继承</a>。</p>


<p> </p>


<p>JavaScript和其它面向对象语言一样，对象类型采用引用方式。持有对象的<a href="http://www.cnblogs.com/snandy/archive/2011/03/01/1967962.html">变量</a>只是一个地址，而基本类型数据是值。当原型上存储对象时，就可能有一些陷阱。</p>


<p> </p>


<p>先看第一个例子</p>


<div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">var create = function() {<br>function Fn() {}<br>return function(parent) {<br>Fn.prototype = parent<br>return new Fn<br>}<br>}()<br> <br>var parent = {<br>    name: 'jack',<br>    age: 30,<br>    isMarried: false<br>}<br>var child = create(parent)<br>console.log(child)</div>


<p>create工具函数实现了一个基本的原型继承，每次调用create都会根据parent对象去复制一个新对象，新对象全部的属性都来自于parent。这里parent有三个属性，都是基本数据类型：字符串，数字，布尔。</p>


<p> </p>


<p>这时修改child看看会不会影响parent</p>


<div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">child.name = 'lily'<br>child.age = 20,<br>child.isMarried = true<br><br>console.log(child)<br>console.log(parent)<br></div>


<p>结果如下</p>


<p><img src="http://pic002.cnblogs.com/images/2012/114013/2012090115532044.png" alt=""></p>


<p>即修改child不会影响到parent。</p>


<p> </p>


<p>再看看另外一个例子</p>


<div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">var create = function() {<br>function Fn() {}<br>return function(parent) {<br>Fn.prototype = parent<br>return new Fn<br>}<br>}()<br> <br>var parent = {<br>    data: {<br>        name: 'jack',<br>        age: 30,<br>        isMarried: false<br>    },<br>    language: ['Java']<br>}<br>var child = create(parent)<br> <br>child.data.name = 'lily'<br>child.data.age = 20<br>child.data.isMarried = true<br>child.language.push('javascript')<br>console.dir(child)<br>console.dir(parent)</div>


<p> </p>


<p>注意这里的parent的两个属性data，language都是引用类型，一个是对象，一个是数组。child仍然继承与parent，随后修改了child，结果如下</p>


<p><img src="http://pic002.cnblogs.com/images/2012/114013/2012090116020737.png" alt=""></p>


<p>可以看到，此时parent也被修改了，和child的name，age等都一样了。这是使用原型继承时需要注意的。</p>


<p> </p>


<p>使用继承时比较好的方式是：</p>


<p>1，数据属性采用类式继承（挂在this上），这样new时也可以通过参数配置</p>


<p>2，方法采用原型继承，这样能节省内存，同时子类重写方法也不会影响父类</p>


<p>下面是一个满足以上2点的写类工具函数</p>


<div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">/**<br> * @param {String} className<br> * @param {String/Function} superCls<br> * @param {Function} classImp<br> */<br>function $class(className, superCls, classImp) {<br>var p, supr<br>if(superCls === '') superCls = Object<br>function clazz() {<br>if(typeof this.init == "function") {<br>this.init.apply(this, arguments)<br>}<br>}<br>p = clazz.prototype = new superCls()<br>clazz.prototype.constructor = clazz<br>clazz.prototype.className = className<br>supr = superCls.prototype<br>window[className] = clazz<br>classImp.apply(p, [supr])<br>}<br></div>


<p> </p>


<p>对象类型放在父类原型上时务必小心子类修改其，这时继承于该父类的所有子类的实例都将被修改。而这造出的bug很不容易发现。</p>


<p> </p>


<p>ES5中加入了一个新API用来实现原型继承：<a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create">Object.create</a>。可以用它替代上面自实现的create函数，如下</p>


<div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">var parent = {<br>    name: 'jack',<br>    age: 30,<br>    isMarried: false<br>}<br>var child = Object.create(parent)<br>console.log(child)<br></div>


<p> </p>


<p><img src="http://www.cnblogs.com/snandy/aggbug/2666747.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/snandy/archive/2012/09/02/2666747.html">本文链接</a></p></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
