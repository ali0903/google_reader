<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>码农干货系列【3】--割绳子(cut the rope)制作点滴:旋转(rotation)</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Your New Jekyll Site</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>码农干货系列【3】--割绳子(cut the rope)制作点滴:旋转(rotation)</h2>
<p class="meta">11 Jun 2012</p>

<div class="post">
<h2>码农干货系列【3】--割绳子(cut the rope)制作点滴:旋转(rotation)</h2>

<h3>by 【当耐特】</h3>

<h3>at 2012-06-11 07:44:00</h3>

<h3>original <a href="http://www.cnblogs.com/iamzhanglei/archive/2012/06/11/2544304.html">http://www.cnblogs.com/iamzhanglei/archive/2012/06/11/2544304.html</a></h3>

<h1>旋转</h1>


<p>  <p>在大量的游戏开发过程当中，旋转是经常被开发者使用的，通常需要得到旋转后目标点的坐标。旋转分很多种类：2D游戏世界中，以某一点为旋转目标；3D游戏世界中，以轴为旋转目标。所以本文将旋转分为四类，涵盖所有旋转的情况：</p>  <blockquote>   <p>绕点旋转（2D）</p>    <p>绕坐标轴（x/y/z）旋转（3D）</p>    <p>绕坐标轴的平行轴旋转（3D）</p>    <p>绕任意轴旋转（3D）</p> </blockquote>  <p><a href="http://images.cnblogs.com/cnblogs_com/iamzhanglei/201206/201206102134004979.png"><img style="border-right-width:0px;display:block;float:none;border-top-width:0px;border-bottom-width:0px;margin-left:auto;border-left-width:0px;margin-right:auto" title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/iamzhanglei/201206/201206102134141547.png" width="405" height="362"></a> </p>  <p></p>  <h1>绕点旋转</h1>  <p>在绕点旋转的时候，需要传入两个参数，一个是目标中心点p（即绕着哪个点旋转），另一个参数是旋转的角度theta。所以为Vector2扩展如下方法：</p>  <div>   <pre style="border-bottom-style:none;text-align:left;padding-bottom:0px;line-height:12pt;background-color:#f4f4f4;margin:0em;border-left-style:none;padding-left:0px;width:100%;padding-right:0px;font-family:&#39;Courier New&#39;,courier,monospace;direction:ltr;border-top-style:none;color:black;border-right-style:none;font-size:10pt;overflow:visible;padding-top:0px"><br>        rotateSelf: <span style="color:#0000ff">function</span> (p, theta) {<br>            <span style="color:#0000ff">var</span> v = <span style="color:#0000ff">this</span>.sub(p);<br>            theta <em>= Math.PI / 180;<br>            <span style="color:#0000ff">var</span> R = [[Math.cos(theta), -Math.sin(theta)], [Math.sin(theta), Math.cos(theta)]];<br>            <span style="color:#0000ff">this</span>.x = p.x + R[0][0] * v.x + R[0][1] * v.y;<br>            <span style="color:#0000ff">this</span>.y = p.y + R[1][0] * v.x + R[1][1] * v.y;<br>        },</pre></div><div>以上代码的具体的流程如下：</div><blockquote>  <div><font size="2">a.var v=this.sub(p)===&gt;先过原点(把p点当作原点)，v是相对于原点p点的坐标</font></div>  <div><font size="2">b.var R=[……..]===&gt;根据角度生成旋转矩阵</font></div>  <div><font size="2">c.求出v点绕着原点(p点)旋转后的向量坐标（R[0][0] * v.x + R[0][1] * v.y，R[1][0] * v.x + R[1][1] * v.y）</font></div>  <div><font size="2">d.把v点的向量坐标累加回p点，即得出最后旋转后点的坐标</font></div></blockquote><p>要理解好过原点，要追溯到线性函数。最简单的例子就是我们把f(x)=kx+b的b割舍掉，成为f(x)=kx的形式。只有过原点的直线才能被成为一元线性函数。因为不过原点的直线不满足我们对线性函数比例性的要求。而矩阵是向量的数组，向量的表达方式是基于原点的。</p><p>所以：<strong><font color="#800080">矩阵变换的核心和基础就是理解好过原点，所以才会有上面来回移动的这个过程。</font></strong></p><h1>绕坐标轴（x/y/z）旋转</h1><p>在3D世界中，绕坐标轴旋转的的本质就是3D中的2D切面中的旋转。通常我们定义一个矩阵类来辅助向量类的计算：</p><div>  <pre style="border-bottom-style:none;text-align:left;padding-bottom:0px;line-height:12pt;background-color:#f4f4f4;margin:0em;border-left-style:none;padding-left:0px;width:100%;padding-right:0px;font-family:&#39;Courier New&#39;,courier,monospace;direction:ltr;border-top-style:none;color:black;border-right-style:none;font-size:10pt;overflow:visible;padding-top:0px">Matrix.RotationX = <span style="color:#0000ff">function</span>(t) {<br>  <span style="color:#0000ff">var</span> c = Math.cos(t), s = Math.sin(t);<br>  <span style="color:#0000ff">return</span> Matrix.create([<br>    [  1,  0,  0 ],<br>    [  0,  c, -s ],<br>    [  0,  s,  c ]<br>  ]);<br>};<br>Matrix.RotationY = <span style="color:#0000ff">function</span>(t) {<br>  <span style="color:#0000ff">var</span> c = Math.cos(t), s = Math.sin(t);<br>  <span style="color:#0000ff">return</span> Matrix.create([<br>    [  c,  0,  s ],<br>    [  0,  1,  0 ],<br>    [ -s,  0,  c ]<br>  ]);<br>};<br>Matrix.RotationZ = <span style="color:#0000ff">function</span>(t) {<br>  <span style="color:#0000ff">var</span> c = Math.cos(t), s = Math.sin(t);<br>  <span style="color:#0000ff">return</span> Matrix.create([<br>    [  c, -s,  0 ],<br>    [  s,  c,  0 ],<br>    [  0,  0,  1 ]<br>  ]);<br>};</pre></div><div>可以看到：</div><blockquote>  <div>绕着X轴旋转矩阵变换，x坐标不变</div>  <div>绕着Y轴旋转矩阵变换，y坐标不变</div>  <div>绕着Z轴旋转矩阵变换，z坐标不变</div></blockquote><h1>绕坐标轴的平行轴旋转</h1><p>绕坐标轴的平行轴的思路和绕点旋转的思路一致，我们为Vector3扩展如下方法：</p><div>  <pre style="border-bottom-style:none;text-align:left;padding-bottom:0px;line-height:12pt;background-color:#f4f4f4;margin:0em;border-left-style:none;padding-left:0px;width:100%;padding-right:0px;font-family:&#39;Courier New&#39;,courier,monospace;direction:ltr;border-top-style:none;color:black;border-right-style:none;font-size:10pt;overflow:visible;padding-top:0px">rotateXSelf: <span style="color:#0000ff">function</span> (p, theta) {<br>    <span style="color:#0000ff">var</span> v = <span style="color:#0000ff">this</span>.sub(p);         <br>    theta </em>= Math.PI / 180;<br>    <span style="color:#0000ff">var</span> R = [[Math.cos(theta), -Math.sin(theta)], [Math.sin(theta), Math.cos(theta)]];<br>    <span style="color:#0000ff">this</span>.y = p.y + R[0][0] * v.y + R[0][1] * v.z;<br>    <span style="color:#0000ff">this</span>.z = p.z + R[1][0] * v.y + R[1][1] * v.z;<br>},<br>rotateYSelf: <span style="color:#0000ff">function</span> (p, theta) {<br>    <span style="color:#0000ff">var</span> v = <span style="color:#0000ff">this</span>.sub(p);       <br>    theta <em>= Math.PI / 180;<br>    <span style="color:#0000ff">var</span> R = [[Math.cos(theta), -Math.sin(theta)], [Math.sin(theta), Math.cos(theta)]];<br>    <span style="color:#0000ff">this</span>.x = p.x + R[0][0] * v.x + R[0][1] * v.z;<br>    <span style="color:#0000ff">this</span>.z = p.z + R[1][0] * v.x + R[1][1] * v.z;<br>},<br>rotateZSelf: <span style="color:#0000ff">function</span> (p, theta) {<br>    <span style="color:#0000ff">var</span> v = <span style="color:#0000ff">this</span>.sub(p);         <br>    theta </em>= Math.PI / 180;<br>    <span style="color:#0000ff">var</span> R = [[Math.cos(theta), -Math.sin(theta)], [Math.sin(theta), Math.cos(theta)]];<br>    <span style="color:#0000ff">this</span>.x = p.x + R[0][0] * v.x + R[0][1] * v.y;<br>    <span style="color:#0000ff">this</span>.y = p.y + R[1][0] * v.x + R[1][1] * v.y;<br>}</pre>  <br></div><p></p><p>这里的p点满足的条件是：要旋转的点与p点的连线垂直于旋转轴，旋转轴过p点。</p><div>以上代码的具体的流程如下：</div><blockquote>  <div><font size="2">a.var v=this.sub(p)===&gt;先过原点(把p点当作原点)，v是相对于原点p点的坐标</font></div>  <div><font size="2">b.var R=[……..]===&gt;根据角度生成旋转矩阵</font></div>  <div><font size="2">c.求出v点绕着原点(p点)旋转后的向量坐标</font></div>  <div><font size="2">d.把v点的向量坐标累加回p点，即得出最后旋转后点的坐标</font></div></blockquote><p></p><p>和2D绕点旋转一样。</p><h1>绕任意轴旋转</h1><div>  <pre style="border-bottom-style:none;text-align:left;padding-bottom:0px;line-height:12pt;background-color:#f4f4f4;margin:0em;border-left-style:none;padding-left:0px;width:100%;padding-right:0px;font-family:&#39;Courier New&#39;,courier,monospace;direction:ltr;border-top-style:none;color:black;border-right-style:none;font-size:10pt;overflow:visible;padding-top:0px">Matrix.Rotation = <span style="color:#0000ff">function</span>(theta, a) {<br>  <span style="color:#0000ff">var</span> axis = a.dup();<br>  <span style="color:#0000ff">if</span> (axis.elements.length != 3) { <span style="color:#0000ff">return</span> <span style="color:#0000ff">null</span>; }<br>  <span style="color:#0000ff">var</span> mod = axis.modulus();<br>  <span style="color:#0000ff">var</span> x = axis.elements[0]/mod, y = axis.elements[1]/mod, z = axis.elements[2]/mod;<br>  <span style="color:#0000ff">var</span> s = Math.sin(theta), c = Math.cos(theta), t = 1 - c;<br>  <span style="color:#0000ff">return</span> Matrix.create([<br>    [ t<em>x</em>x + c, t<em>x</em>y - s<em>z, t</em>x<em>z + s</em>y ],<br>    [ t<em>x</em>y + s<em>z, t</em>y<em>y + c, t</em>y<em>z - s</em>x ],<br>    [ t<em>x</em>z - s<em>y, t</em>y<em>z + s</em>x, t<em>z</em>z + c ]<br>  ]);<br>};</pre></div><p><a href="http://images.cnblogs.com/cnblogs_com/iamzhanglei/201206/201206110731581494.gif"><img style="border-bottom:0px;border-left:0px;display:block;float:none;margin-left:auto;border-top:0px;margin-right:auto;border-right:0px" title="image025" border="0" alt="image025" src="http://images.cnblogs.com/cnblogs_com/iamzhanglei/201206/201206110731593163.gif" width="333" height="222"></a> </p><p>详细推导过程传送门：<a title=" http://www.gamedev.net/reference/articles/article1199.asp" href="http://www.gamedev.net/reference/articles/article1199.asp">http://www.gamedev.net/reference/articles/article1199.asp</a></p><h1>举一个栗子</h1><p>这是我制作《割绳子》的第一关中的部分效果，比IE官网的难度稍大一点，三颗星星不是闭着眼睛割就能够得到，也要找准时机果断割绳子。</p>请使用现代浏览器观看在线演示！ <h1>小结</h1><p>本文主要是通过一点点线性代数的知识，解决旋转相关的问题。线性代数的应用非常广泛，在光线追踪、物理引擎、图像识别、实时碰撞检测等重要领域都有着不可替代的作用和地位。当然，除了计算机行业，在其他行业，比如电子工程、3D影片制作渲染、土木工程等，都有这重要的作用和地位。</p><p><font color="#ff0000" size="3"><strong>更多干货，敬请期待~~~</strong></font></p><img src="http://www.cnblogs.com/iamzhanglei/aggbug/2544304.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/iamzhanglei/archive/2012/06/11/2544304.html">本文链接</a></p></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
