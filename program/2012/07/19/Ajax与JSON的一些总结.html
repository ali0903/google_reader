<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Ajax与JSON的一些总结</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>Ajax与JSON的一些总结</h2>
<p class="meta">2012-07-19 23:26</p>

<div class="post">
<h2>Ajax与JSON的一些总结</h2>

<h3>by</h3>

<h3>at 2012-07-19 15:26:39</h3>

<h3>original <a href="http://kb.cnblogs.com/page/150964/">http://kb.cnblogs.com/page/150964/</a></h3>

<p><strong>　　1.1.1 摘要</strong></p>


<p>　　Ajax技术的核心是<a href="http://www.w3.org/TR/XMLHttpRequest/">XMLHttpRequest</a>对象（简称XHR），可以通过使用XHR对象获取到服务器的数据，然后再通过DOM将数据插入到页面中呈现。虽然名字中包含XML，但Ajax通讯与数据格式无关，所以我们的数据格式可以是XML或JSON等格式。</p>


<p>　　XMLHttpRequest对象用于在后台与服务器交换数据，具体作用如下：</p>


<ul><li>在不重新加载页面的情况下更新网页</li><li>在页面已加载后从服务器请求数据</li><li>在页面已加载后从服务器接收数据</li><li>在后台向服务器发送数据</li></ul>


<p><strong>　　本文目录</strong></p>


<ul><li><a href="http://kb.cnblogs.com/#lb1">XMLHttpRequest的用法</a></li><li><a href="http://kb.cnblogs.com/#lb2">Ajax同源请求</a></li><li><a href="http://kb.cnblogs.com/#lb3">同源策略与跨源策略</a></li><li><a href="http://kb.cnblogs.com/#lb4">Ajax跨源请求</a></li></ul>


<p><strong>　　1.1.2 正文</strong></p>


<p>　　XMLHttpRequest是一个JavaScript对象，它是由微软设计，并且被Mozilla、Apple和Google采纳，W3C正在标准化它。它提供了一种简单的方法来检索URL中的数据。</p>


<p>　　我们要创建一个XMLHttpRequest实例，只需new一个就OK了：</p>


<pre><span style="color:green">//// Creates a XMLHttpRequest object.</span><span style="color:blue">var </span>req = <span style="color:blue">new </span>XMLHttpRequest();</pre>


<p>　　也许有人会说：“这可不行啊！IE6不支持原始的XHR对象”，确实是这样，我们在后面将会介绍支持IE6或更老版本创建XHR对象的方法。</p>


<h2>　　XMLHttpRequest的用法<p>　　在创建XHR对象后，接着我们要调用一个初始化方法open()，它接受五个参数具体定义如下：</p><pre><span style="color:blue">void </span>open(   DOMString method, <span style="color:green">//"GET", "POST", "PUT", "DELETE"   </span>DOMString url,   optional <span style="color:blue">boolean </span>async,   optional DOMString user,   optional DOMString password);</pre><p>　　通过上面的定义我们知道open()方法的签名包含五个参数，其中有参数method和url地址是必填的，假设我们针对URL: myxhrtest.aspx发送GET请求获取数据，具体定义如下：</p><pre><span style="color:blue">var </span>req = <span style="color:blue">new </span>XMLHttpRequest();req.open(    <span style="color:#a31515">"GET"</span>,    <span style="color:#a31515">"myxhrtest.aspx"</span>,    <span style="color:blue">false</span>);</pre><p>　　通过上述代码会启动一个针对myxhrtest.aspx的GET请求，这里有两点要注意：一是URL相对于执行代码的当前页面（使用绝对路径）；二是调用open()方法并不会真正发送请求，而只是启动一个请求准备发送。</p><blockquote><p>只能向同一个域中使用相同端口和协议的URL中发送请求；如果URL与启动请求的页面有任何差别，都会引发安全错误。</p></blockquote><p>　　要真正发送请求要使用send()方法，send()方法接受一个参数，即要作为请求主体发送的数据，如果不需要通过请求主体发送数据，我们必须传递一个null值。在调用send()之后，请求就会被分派到服务器，完整Ajax请求代码如下：</p><pre><span style="color:blue">var </span>req = <span style="color:blue">new </span>XMLHttpRequest();req.open(    <span style="color:#a31515">"GET"</span>,    <span style="color:#a31515">"myxhrtest.aspx"</span>,    <span style="color:blue">false</span>);req.send(<span style="color:blue">null</span>);</pre><p>　　在发送请求之后，我们需要检查请求是否执行成功，首先可以通过status属性判断，一般来说，可以将HTTP状态代码为200作为成功标志。这时，响应主体内容会保存到responseText中。此外，状态代码为304表示请求的资源并没有被修改，可以直接使用浏览器缓存的数据，Ajax的同步请求代码如下：</p><pre><span style="color:blue">if </span>(req != <span style="color:blue">null</span>) {        req.onreadystatechange = <span style="color:blue">function</span>() {            <span style="color:blue">if </span>((req.status &gt;= 200 &amp;&amp; req.status &lt; 300) || req.status == 304) {                <span style="color:green">//// Do something.            </span>} <span style="color:blue">else </span>{                alert(<span style="color:#a31515">"Request was unsuccessful: " </span>+ req.status);            }    };    req.open(<span style="color:#a31515">"GET"</span>, <span style="color:#a31515">"www.myxhrtest.aspx"</span>, <span style="color:blue">true</span>);    req.send(<span style="color:blue">null</span>);}</pre><p>　　前面我们定义了Ajax的同步请求，如果我们发送异步请求，那么在请求过程中javascript代码会继续执行，这时可以通过readyState属性判断请求的状态，当readyState = 4时，表示收到全部响应数据，属性值的定义如下：</p><div align="center"><table border="1" cellspacing="0" cellpadding="0" align="center"><tbody><tr><td valign="top" width="284"><p>readyState值</p></td><td valign="top" width="284"><p>描述</p></td></tr><tr><td valign="top" width="284"><p>0</p></td><td valign="top" width="284"><p>未初始化；尚未调用open()方法</p></td></tr><tr><td valign="top" width="284"><p>1</p></td><td valign="top" width="284"><p>启动；尚未调用send()方法</p></td></tr><tr><td valign="top" width="284"><p>2</p></td><td valign="top" width="284"><p>已发送；但尚未收到响应</p></td></tr><tr><td valign="top" width="284"><p>3</p></td><td valign="top" width="284"><p>接收；已经收到部分响应数据</p></td></tr><tr><td valign="top" width="284"><p>4</p></td><td valign="top" width="284"><p>完成；收到全部响应数据</p></td></tr></tbody></table></div><p align="center">表1 readyState属性值</p><blockquote><p>同步请求：发生请求后，要等待服务器执行完毕才继续执行当前代码。</p><p>异步请求：发生请求后，无需等到服务器执行完毕，可以继续执行当前代码。</p></blockquote><p>　　现在我们要增加判断readyState属性值，当readyState = 4时，表示全部数据接收完成， 所以Ajax的异步请求代码如下：</p><pre><span style="color:blue">if </span>(req != <span style="color:blue">null</span>) {    req.onreadystatechange = <span style="color:blue">function</span>() {        <span style="color:green">//// Checks the asyn request completed or not.        </span><span style="color:blue">if </span>(req.readyState == 4) {            <span style="color:blue">if </span>((req.status &gt;= 200 &amp;&amp; req.status &lt; 300) || req.status == 304) {                <span style="color:green">//// Do something.            </span>} <span style="color:blue">else </span>{                alert(<span style="color:#a31515">"Request was unsuccessful: " </span>+ req.status);            }        }    };    req.open(<span style="color:#a31515">"GET"</span>, <span style="color:#a31515">"www.myxhrtest.aspx"</span>, <span style="color:blue">true</span>);    req.send(<span style="color:blue">null</span>);}</pre><h2>　　Ajax同源请求<p>　　现在我们对Ajax的请求实现有了初步的了解，接下来我们将通过具体的例子说明Ajax请求的应用场合和局限。</p><p>　　在日常网络生活中，我们在浏览器的地址中输入要访问的URL并且回车，浏览器会向服务器发送请求，当服务器收到请求后，把相应的请求页面发送回浏览器，我们会发现页面大部分加载完毕，有些还没有加载完毕。总的来说，采用异步加载方式不会影响已加载完毕的页面浏览，我们可以通过Ajax实现异步加载。</p><p>　　这里我们以AdventureWorks数据库为例，把产品表（Product）中的数据通过报表呈现给用户，我们可以通过多种方法实现该报表需求，这里我们将通过Ajax实现该功能。</p><p>　　首先，我们要把后台数据转换为JSON格式，接下来我们定义Product表的数据库访问对象（DAO），具体的实现代码如下：</p><pre><span style="color:gray">/// &lt;summary&gt;/// </span><span style="color:green">The product datatable dao.</span><span style="color:gray">/// &lt;/summary&gt;</span><span style="color:blue">public class </span><span style="color:#2b91af">ProductDao</span>{    <span style="color:gray">/// &lt;summary&gt;    /// </span><span style="color:green">Initializes a new instance of the </span><span style="color:gray">&lt;see cref=&quot;ProductDao&quot;/&gt; </span><span style="color:green">class.    </span><span style="color:gray">/// &lt;/summary&gt;    </span><span style="color:blue">public </span>ProductDao()    {    }    <span style="color:gray">/// &lt;summary&gt;    /// </span><span style="color:green">Gets or sets the product id.    </span><span style="color:gray">/// &lt;/summary&gt;    </span><span style="color:blue">public int </span>Id { <span style="color:blue">get</span>; <span style="color:blue">set</span>; }    <span style="color:gray">/// &lt;summary&gt;    /// </span><span style="color:green">Gets or sets the product name.    </span><span style="color:gray">/// &lt;/summary&gt;    </span><span style="color:blue">public string </span>Name { <span style="color:blue">get</span>; <span style="color:blue">set</span>; }    <span style="color:gray">/// &lt;summary&gt;    /// </span><span style="color:green">Gets or sets the product serial number.    </span><span style="color:gray">/// &lt;/summary&gt;    </span><span style="color:blue">public string </span>SerialNumber { <span style="color:blue">get</span>; <span style="color:blue">set</span>; }    <span style="color:gray">/// &lt;summary&gt;    /// </span><span style="color:green">Gets or sets the product qty.    </span><span style="color:gray">/// &lt;/summary&gt;    </span><span style="color:blue">public short </span>Qty { <span style="color:blue">get</span>; <span style="color:blue">set</span>; }}</pre><p>　　前面我们定义了Product表的数据库访问对象——ProductDao，它包含四个属性分别是产品的Id，名称，序列号和销售数量。</p><p>　　接下来，让我们实现Product表的数据库操作类。</p><pre><span style="color:gray">/// &lt;summary&gt;/// </span><span style="color:green">Product table data access manager.</span><span style="color:gray">/// &lt;/summary&gt;</span><span style="color:blue">public class </span><span style="color:#2b91af">ProductManager</span>{    <span style="color:gray">/// &lt;summary&gt;    /// </span><span style="color:green">The query sql.    </span><span style="color:gray">/// &lt;/summary&gt;    </span><span style="color:blue">private const string </span>Query =         <span style="color:#a31515">"SELECT ProductID, Name, ProductNumber, SafetyStockLevel FROM Production.Product"</span>;    <span style="color:gray">/// &lt;summary&gt;    /// </span><span style="color:green">Stores the object of </span><span style="color:gray">&lt;see cref=&quot;ProductDao&quot;/&gt; </span><span style="color:green">into list.    </span><span style="color:gray">/// &lt;/summary&gt;    </span><span style="color:blue">private </span><span style="color:#2b91af">IList</span>&lt;<span style="color:#2b91af">ProductDao</span>&gt; _products = <span style="color:blue">new </span><span style="color:#2b91af">List</span>&lt;<span style="color:#2b91af">ProductDao</span>&gt;();    <span style="color:gray">/// &lt;summary&gt;    /// </span><span style="color:green">Gets all products in product table.    </span><span style="color:gray">/// &lt;/summary&gt;    /// &lt;returns&gt;    /// </span><span style="color:green">The list of </span><span style="color:gray">&lt;see cref=&quot;ProductDao&quot;/&gt; </span><span style="color:green">object.    </span><span style="color:gray">/// &lt;/returns&gt;    </span><span style="color:blue">public </span><span style="color:#2b91af">IList</span>&lt;<span style="color:#2b91af">ProductDao</span>&gt; GetAllProducts()    {        <span style="color:blue">using </span>(<span style="color:blue">var </span>con = <span style="color:blue">new </span><span style="color:#2b91af">SqlConnection</span>(<span style="color:#2b91af">ConfigurationManager</span>.ConnectionStrings[<span style="color:#a31515">"SQLCONN"</span>].ToString()))        <span style="color:blue">using </span>(<span style="color:blue">var </span>com = <span style="color:blue">new </span><span style="color:#2b91af">SqlCommand</span>(Query, con))        {            con.Open();            <span style="color:blue">using </span>(<span style="color:blue">var </span>reader = com.ExecuteReader(<span style="color:#2b91af">CommandBehavior</span>.CloseConnection))            {                <span style="color:blue">while </span>(reader.Read())                {                    <span style="color:blue">var </span>product = <span style="color:blue">new </span><span style="color:#2b91af">ProductDao                        </span>{                            Id = (<span style="color:blue">int</span>)reader[<span style="color:#a31515">"ProductID"</span>],                            Name = (<span style="color:blue">string</span>)reader[<span style="color:#a31515">"Name"</span>],                            SerialNumber = (<span style="color:blue">string</span>)reader[<span style="color:#a31515">"ProductNumber"</span>],                            Qty = (<span style="color:blue">short</span>)reader[<span style="color:#a31515">"SafetyStockLevel"</span>]                        };                    _products.Add(product);                }            }        }        <span style="color:blue">return </span>_products;    }}</pre><p>　　前面我们实现了Product表的数据库操作类——ProductManager，它包含两个私有字段Quey和_products，还有一个获取Product表中数据的方法——GetAllProducts()。</p><p>　　通过实现ProductDao和ProductManager，而且我们提供GetAllProducts()方法，获取Product表中的数据，接下来我们要调用该方法获取数据。</p><p>　　为了使数据通过JSON格式传递给页面，这里我们要创建一般处理程序（ASHX文件），</p><p>　　一般处理程序适用场合：</p><ul><li>创建动态图片</li><li>返回REST风格的XML或JSON数据</li><li>自定义HTML</li></ul><p align="center"><a href="http://images.cnblogs.com/cnblogs_com/rush/201205/201205152123278501.png"><img style="display:block;float:none;margin-left:auto;margin-right:auto" title="ajax1" src="http://images.cnblogs.com/cnblogs_com/rush/201205/201205152123307614.png" alt="ajax1" width="660" height="447"></a>图1一般处理程序</p><p>　　把一般处理程序文件添加到项目中时，会添加一个扩展名为.ashx的文件，现在我们创建一个一般处理程序ProductInfo，具体代码如下：</p><pre><span style="background:#ffee62">&lt;%</span><span style="color:blue">@ </span><span style="color:#a31515">WebHandler </span><span style="color:red">Language</span><span style="color:blue">="C#" </span><span style="color:red">Class</span><span style="color:blue">="ProductInfo" </span><span style="background:#ffee62">%&gt;</span><span style="color:blue">using </span>System.Runtime.Serialization.Json;<span style="color:blue">using </span>System.Web;<span style="color:blue">using </span>ASP.App_Code;<span style="color:gray">/// &lt;summary&gt;/// </span><span style="color:green">The product data handler.</span><span style="color:gray">/// &lt;/summary&gt;</span><span style="color:blue">public class </span><span style="color:#2b91af">ProductInfo </span>: <span style="color:#2b91af">IHttpHandler </span>{        <span style="color:blue">public void </span>ProcessRequest (<span style="color:#2b91af">HttpContext </span>context) {        context.Response.ContentType = <span style="color:#a31515">"application/json"</span>;        <span style="color:green">// Creates a &lt;see cref=&quot;ProductManager&quot;/&gt; oject.        </span><span style="color:blue">var </span>manager = <span style="color:blue">new </span><span style="color:#2b91af">ProductManager</span>();        <span style="color:green">// Invokes the GetAllProducts method.        </span><span style="color:blue">var </span>products = manager.GetAllProducts();        <span style="color:green">// Serializes data to json format.        </span><span style="color:blue">var </span>json = <span style="color:blue">new </span><span style="color:#2b91af">DataContractJsonSerializer</span>(products.GetType());        json.WriteObject(context.Response.OutputStream, products);    }    <span style="color:green">// Whether can resuable by other handler or not.    </span><span style="color:blue">public bool </span>IsReusable {        <span style="color:blue">get </span>{            <span style="color:blue">return false</span>;        }    }}</pre><p>　　大家注意到ProductInfo类实现了IHttpHandler接口，该接口包含一个方法ProcessRequest()方法和一个属性IsReusable。ProcessRequest()方法用于处理入站的Http请求。在默认情况下，ProductInfo类会把内容类型改为application/json，然后我们把数据通过JSON格式写入输入流中；IsReusable属性表示相同的处理程序是否可以用于多个请求，这里我们设置为false，如果为了提高性能也可以设置为true。</p><p>　　如下图所示，我们通过ProductInfo类成功地实现获取数据到响应流中，并且以JSON格式显示出来。</p><p align="center"><a href="http://images.cnblogs.com/cnblogs_com/rush/201205/201205152123379919.png"><img style="display:block;float:none;margin-left:auto;margin-right:auto;border-width:0px" title="ajax2" src="http://images.cnblogs.com/cnblogs_com/rush/201205/201205152123404082.png" alt="ajax2" width="598" height="515" border="0"></a>图2 Http请求</p><p>　　当我们请求ProductInfo时， 首先它会调用ProcessRequest()方法，接着调用GetAllProducts()方法从数据库中获取数据，然后把数据通过JSON格式写入到响应流中。</p><p>　　现在，我们已经成功地把数据通过JSON格式写入到响应流当中，接着我们将通过Ajax方式请求数据并且把数据显示到页面中。</p><p>　　首先，我们定义方法createXHR()用来创建XMLHttpRequest对象，前面我们提到IE6或者更老的版本不支持XMLHttpRequest()方法来创建XMLHttpRequest对象，所以我们要在createXHR()方法中，增加判断当前浏览器是否IE6或更老的版本，如果是，就要通过MSXML库的一个ActiveX对象实现。因此，在IE中可能遇到三种不同版本的XHR对象（MSXML2.XMLHttp6.0，MSXML2.XMLHttp3.0和MSXML2.XMLHttp）。</p><pre><span style="color:green">// Creates a XMLHttpRequest object bases on web broswer.</span><span style="color:blue">function </span>createXHR() {    <span style="color:green">// Checks whether support XMLHttpRequest or not.    </span><span style="color:blue">if </span>(<span style="color:blue">typeof </span>XMLHttpRequest != <span style="color:#a31515">"undefined"</span>) {        <span style="color:blue">return new </span>XMLHttpRequest();    }    <span style="color:green">// IE6 and elder version.    </span><span style="color:blue">else if </span>(<span style="color:blue">typeof </span>ActiveXObject != <span style="color:#a31515">"undefined"</span>) {        <span style="color:blue">if </span>(<span style="color:blue">typeof </span>arguments.callee.activeXString != <span style="color:#a31515">"string"</span>) {            <span style="color:blue">var </span>versions = [        <span style="color:#a31515">"MSXML2.XMLHttp6.0"</span>,        <span style="color:#a31515">"MSXML2.XMLHttp3.0"</span>,        <span style="color:#a31515">"MSXML2.XMLHttp"</span>];            <span style="color:blue">for </span>(<span style="color:blue">var </span>i = 0; i &lt; versions.length; i++) {                <span style="color:blue">try </span>{                    <span style="color:blue">var </span>xhr = <span style="color:blue">new </span>ActiveXObject(versions[i]);                    arguments.callee.activeXString = versions[i];                    <span style="color:blue">return </span>xhr;                }                <span style="color:blue">catch </span>(ex) {                    <span style="color:blue">throw new </span>Error(ex.toString());                }            }            <span style="color:blue">return new </span>ActiveXObject(arguments.callee.activeXString);        }        <span style="color:blue">else </span>{            <span style="color:blue">throw new </span>Error(<span style="color:#a31515">"No XHR object available"</span>);        }    }    <span style="color:blue">return null</span>;}$(document).ready(<span style="color:blue">function</span>() {    GetDataFromServer();});</pre><p>　　前面我们定义了一个比较通用的方法用来创建XMLHttpRequest对象，并且它支持IE6或更老版本创建XMLHttpRequest对象，接下来我们将通过Ajax方法请求数据。</p><pre><span style="color:blue">function </span>GetDataFromServer() {    <span style="color:green">// Creates a XMLHttpRequest object.    </span><span style="color:blue">var </span>req = <span style="color:blue">new </span>createXHR();          <span style="color:blue">if </span>(req != <span style="color:blue">null</span>) {        req.onreadystatechange = <span style="color:blue">function</span>() {            <span style="color:blue">if </span>(req.readyState == 4) {                <span style="color:blue">if </span>((req.status &gt;= 200 &amp;&amp; req.status &lt; 300) || req.status == 304) {                    <span style="color:green">////alert(req.responseText);                    </span><span style="color:blue">var </span>jsonTextDiv = document.getElementById(<span style="color:#a31515">"jsonText"</span>);                    <span style="color:green">// Deserializes JavaScript Object Notation (JSON) text to produce a JavaScript value.                    </span><span style="color:blue">var </span>data = JSON.parse(req.responseText);                    <span style="color:blue">for </span>(<span style="color:blue">var </span>i = 0; i &lt; data.length; i++) {                        <span style="color:blue">var </span>item = data[i];                        <span style="color:blue">var </span>div = document.createElement(<span style="color:#a31515">"div"</span>);                        div.setAttribute(<span style="color:#a31515">"class"</span>, <span style="color:#a31515">"dataItem"</span>);                        <span style="color:green">// Inserts data into the html.                        </span>div.innerHTML = item.Name + <span style="color:#a31515">" sold " </span>+ item.Qty + <span style="color:#a31515">"; Product number: " </span>+ item.SerialNumber;                        jsonTextDiv.appendChild(div);                    }                }                <span style="color:blue">else </span>{                    alert(<span style="color:#a31515">"Request was unsuccessful: " </span>+ req.status);                }            }        };                <span style="color:green">// Sends a asyn request.         </span>req.open(<span style="color:#a31515">"GET"</span>, <span style="color:#a31515">"ProductInfo.ashx"</span>, <span style="color:blue">true</span>);        req.send(<span style="color:blue">null</span>);    }}</pre><p>　　由于前面我们介绍过Ajax发生请求的方法，所以不再重复介绍了，但我们注意到GetDataFromServer()方法中，获取responseText数据（JSON格式），然后通过<a href="http://msdn.microsoft.com/en-us/library/windows/apps/cc836466%28v=vs.85%29.aspx">parse()</a>方法把JSON格式数据转换为Javascript对象，最后把数据插入到div中，页面呈现效果如下：</p><p align="center"><a href="http://images.cnblogs.com/cnblogs_com/rush/201205/201205152123421376.png"><img style="display:block;float:none;margin-left:auto;margin-right:auto;border-width:0px" title="ajax3" src="http://images.cnblogs.com/cnblogs_com/rush/201205/201205152123448670.png" alt="ajax3" width="564" height="362" border="0"></a>图3 Ajax请求结果</p><p>　　现在，我们成功地把数据输出到页面当中，也许用户还会觉得用户体验不好，那么我们给就该页面增加CSS样式。</p><p>　　由于时间的关系，我们已经把CSS样式定义好了，具体如下：</p><pre><span style="color:#a31515">#header </span>{    <span style="color:red">width</span>: <span style="color:blue">100%</span>;    <span style="color:red">margin-left</span>: <span style="color:blue">10px</span>;    <span style="color:red">margin-right</span>: <span style="color:blue">10px</span>;    <span style="color:red">background-color</span>:<span style="color:blue">#480082</span>;    <span style="color:red">color</span>: <span style="color:blue">#FFFFFF</span>;}<span style="color:#a31515">body </span>{    <span style="color:red">margin-left</span>: <span style="color:blue">40px</span>;    <span style="color:red">margin-right</span>: <span style="color:blue">40px</span>;}<span style="color:#a31515">div#jsonText </span>{    <span style="color:red">background-color</span>: <span style="color:blue">#d9d9d9</span>;    <span style="color:red">-webkit-border-radius</span>: <span style="color:blue">6px</span>;    <span style="color:red">border-radius</span>: <span style="color:blue">6px</span>;    <span style="color:red">margin</span>: <span style="color:blue">10px 0px 0px 0px</span>;    <span style="color:red">padding</span>: <span style="color:blue">0px</span>;    <span style="color:red">border</span>: <span style="color:blue">1px solid #d9d9d9</span>;}<span style="color:#a31515">div.dataItem </span>{    <span style="color:red">font-family</span>: <span style="color:blue">Verdana, Helvetica, sans-serif</span>;    <span style="color:red">color</span>: <span style="color:blue">#434343</span>;    <span style="color:red">padding</span>: <span style="color:blue">10px</span>;}<span style="color:#a31515">div.dataItem:nth-child(2n) </span>{    <span style="color:red">background-color</span>: <span style="color:blue">#fafafa</span>;}<span style="color:#a31515">div.dataItem:first-child </span>{    <span style="color:red">-webkit-border-top-left-radius</span>: <span style="color:blue">6px</span>;    <span style="color:red">-webkit-border-top-right-radius</span>: <span style="color:blue">6px</span>;    <span style="color:red">border-top-left-radius</span>: <span style="color:blue">6px</span>;    <span style="color:red">border-top-right-radius</span>: <span style="color:blue">6px</span>;}<span style="color:#a31515">div.dataItem:last-child </span>{    <span style="color:red">-webkit-border-bottom-left-radius</span>: <span style="color:blue">6px</span>;    <span style="color:red">-webkit-border-bottom-right-radius</span>: <span style="color:blue">6px</span>;    <span style="color:red">border-bottom-left-radius</span>: <span style="color:blue">6px</span>;    <span style="color:red">border-bottom-right-radius</span>: <span style="color:blue">6px</span>;}</pre><p>　　我们刷新一下页面，OK现在页面效果好多了。</p><p align="center"><a href="http://images.cnblogs.com/cnblogs_com/rush/201205/20120515212346108.png"><img style="display:block;float:none;margin-left:auto;margin-right:auto;border-width:0px" title="ajax4" src="http://images.cnblogs.com/cnblogs_com/rush/201205/201205152123481861.png" alt="ajax4" width="604" height="322" border="0"></a>图4 Ajax请求结果</p><h2>　　同源策略与跨源策略<p>　　上面我们获取页面和数据都是在<strong>同源请求</strong>情况下，也就是说，客户端浏览器请求的页面和数据都是属于<strong>同一域名</strong>、<strong>同一端口</strong>和<strong>同协议</strong>。</p><p>　　<a href="http://en.wikipedia.org/wiki/Same_origin_policy">同源策略</a>：阻止从一个域上加载的脚本获取或操作另一个域上的文档属性。也就是说，受到请求的URL的域必须与当前Web页面的域相同、相同端口。这意味着浏览器隔离来自不同源的内容，以防止它们之间的操作。</p><p align="center"><a href="http://images.cnblogs.com/cnblogs_com/rush/201205/201205152123503615.png"><img style="display:block;float:none;margin-left:auto;margin-right:auto;border-width:0px" title="ajax6" src="http://images.cnblogs.com/cnblogs_com/rush/201205/201205152123515369.png" alt="ajax6" width="519" height="363" border="0"></a>图5同源请求过程</p><p>　　在一些情况下，我们不可以避免地要地需要从其他域名或服务器中跨域请求数据，但前面提到Ajax只能向同一个域中使用相同端口和协议的URL中发送请求；如果URL与启动请求的页面有任何差别，都会引发安全错误。</p><p>　　<a href="http://en.wikipedia.org/wiki/Cross-Origin_Resource_Sharing">跨源策略</a>（CORS）：是一个Web浏览器技术规范，它定义了一个方法让Web服务器允许其他域名页面访问它的资源。跨源策略定义了一个方法让浏览器和服务器可以交互决定是否允许跨源请求。</p><p align="center"><a href="http://images.cnblogs.com/cnblogs_com/rush/201205/2012051521235522.png"><img style="display:block;float:none;margin-left:auto;margin-right:auto;border-width:0px" title="ajax5" src="http://images.cnblogs.com/cnblogs_com/rush/201205/20120515212357281.png" alt="ajax5" width="562" height="564" border="0"></a>图6跨源请求过程</p><p>　　大家注意到同源请求中我们使用的是JSON格式，但在跨源请求中却是使用JSONP，这时大家可能有点困惑，坦然我刚开始学习的时候也是这样的。</p><p>　　首先我们必须理解JSON和JSONP的区别：JSON是一种数据格式，而JSONP像是通过一个方法名来封装JSON格式；由于浏览器允许跨源请求&lt;script&gt;资源，如我们的HTML页面代码中使用了Google的jQuery库，当我们Web程序发送跨源请求后，服务器给我们提供响应数据，但服务器无法预知接受JSON数据的方法名，所以我们要提供一个方法名。</p><h2>　　Ajax跨源请求<p>　　跨域请求数据解决方案主要有如下解决方法：</p><ol><li>JSONP方式</li><li>表单POST方式</li><li>服务器代理</li><li>Html5的XDomainRequest</li><li>Flash request</li></ol><p>　　在介绍JSONP方式解决跨域请求数据之前，首先我们看看JSONP的定义。</p><p>　　JSONP（JSON with Padding）是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过Javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。</p><p>　　由于同源策略的限制，XMLHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。</p><p>　　假设博客园提供一个API接口：http://www.cnblogs.com/hotblogs/json?，供开发者调用获取热门博文。</p><p>　　这里我们可以通过两种方式调用该接口：</p><p><strong>　　1. 用Javascript定义回调函数</strong></p><p>　　其实，通过Javascript定义回调函数调用该接口比较直观，我们只需告诉服务器接收数据的方法名就OK了，比如：</p><p>　　http://www.cnblogs.com/hotblogs/json? callback=myFunction</p><p>　　其中myFunction是我们在页面自定义的函数用来接收服务器回传的数据，myFunction的定义如下：</p><pre><span style="color:green">// The call back function.</span><span style="color:blue">function </span>myFunction(data) {    <span style="color:green">// Your code here.</span>}</pre><p><strong>　　2. 使用jQuery的Ajax方法</strong></p><p>　　假设我们想在博客中增加显示浪微博的公共微博信息，我们可以在博客中调用微博提供的API获取跨源数据，接下来，我们将使用jQuery的Ajax方法获取跨域数据。</p><p>　　首先，查看微博<a href="http://open.weibo.com/wiki/API%E6%96%87%E6%A1%A3">API文档</a>找到了公共微博的API接口<a href="http://open.weibo.com/wiki/Statuses/public_timeline">statuses/public_timeline</a> 获取最新的公共微博消息，它支持JSON或XML格式数据。</p><div align="center"><table border="1" cellspacing="0" cellpadding="0" align="center"><tbody><tr><td valign="top" width="142"><p align="left">参数</p></td><td valign="top" width="142"><p align="left">必选</p></td><td valign="top" width="142"><p align="left">类型及范围</p></td><td valign="top" width="142"><p align="left">说明</p></td></tr><tr><td valign="top" width="142"><p align="left">source</p></td><td valign="top" width="142"><p align="left">true</p></td><td valign="top" width="142"><p align="left">string</p></td><td valign="top" width="142"><p align="left">申请应用时分配的AppKey，调用接口时候代表应用的唯一身份。（采用OAuth授权方式不需要此参数）</p></td></tr><tr><td valign="top" width="142"><p align="left">count</p></td><td valign="top" width="142"><p align="left">false</p></td><td valign="top" width="142"><p align="left">int，缺省值20，最大值200</p></td><td valign="top" width="142"><p align="left">每次返回的记录数</p></td></tr><tr><td valign="top" width="142"><p align="left">count</p></td><td valign="top" width="142"><p align="left">false</p></td><td valign="top" width="142"><p align="left">int，缺省值20，最大值200</p></td><td valign="top" width="142"><p align="left">每次返回的记录数</p></td></tr></tbody></table></div><p align="center">表2请求参数</p><p>　　上面的请求参数只有source（AppKey）是必须的，所以我们需要向微博申请AppKey，在调用API时，只需把我们的AppKey传递给接口就OK了。</p><p>　　接下来让我们看一下微博数据组成，这里我们使用<a href="http://jsonviewer.stack.hu/">JSON viewer</a>查看微博的数据组成，具体数据如下：</p><p align="center"><a href="http://images.cnblogs.com/cnblogs_com/rush/201205/201205152124029819.png"><img style="display:block;float:none;margin-left:auto;margin-right:auto" title="ajax8" src="http://images.cnblogs.com/cnblogs_com/rush/201205/201205152124046731.png" alt="ajax8" width="660" height="614"></a>图7微博JSON数据</p><p>　　通过上图，我们知道微博的数据信息很丰富，它是由一些基础数据类型和复杂数据类型user组成的，接下来我们将使用jQuery实现调用微博接口方法。</p><p>　　首先，我们定义一个全局的对象，它包含三个属性分别是：numWeibo、appendTo和appKey，还有三个方法loadWeibo()、timeAgo()和clean()，具体定义如下：</p><pre> JQWeibo = {     <span style="color:green">// The number of weibos display in the page.     // Sets the number of weibos, append class and app key.     </span>numWeibo: 15,     appendTo: <span style="color:#a31515">'#jsWeibo'</span>,     <span style="color:green">// The appkey you apply from weibo.     </span>appKey: YourAppKey,     <span style="color:green">// The function to get weibo data.     </span>loadWeibo: <span style="color:blue">function</span>() {     },     <span style="color:green">/**     * Convert the time to relative time.     * @return {string} relative time like "8 minutes ago"     */     </span>timeAgo: <span style="color:blue">function</span>(dateString) {     },     ify: {         clean: <span style="color:blue">function</span>(weibo) {             <span style="color:blue">return this</span>.hash(<span style="color:blue">this</span>.at(<span style="color:blue">this</span>.list(<span style="color:blue">this</span>.link(weibo))));         }     } <span style="color:green">// ify</span>};</pre><p>　　上面我们定义了一个对象JQWeibo，其中loadWeibo()方法使用jQuery的Ajax方法向微博API发送跨源请求，接下来让我们实现该方法吧。</p><pre><span style="color:green">// The function to get weibo data.</span>loadWeibo: <span style="color:blue">function</span>() {    $.ajax({        <span style="color:green">// Weibo API.        </span>url: <span style="color:#a31515">"http://api.t.sina.com.cn/statuses/public_timeline.json"</span>,        type: <span style="color:#a31515">"GET"</span>,        dataType: <span style="color:#a31515">"jsonp"</span>,        data: {            source: JQWeibo.appKey,            count: JQWeibo.numWeibo        },        <span style="color:green">// When the requet completed, then invokes success function.        </span>success: <span style="color:blue">function</span>(data, textStatus, xhr) {            <span style="color:green">// Sets html structure.            </span><span style="color:blue">var </span>html =            <span style="color:#a31515">&#39;&lt;div class=&quot;weibo&quot;&gt;&#39; </span>+            <span style="color:#a31515">&#39;&lt;a href=&quot;http://weibo.com/DOMAIN&quot; target=&quot;_blank&quot;&gt;USER&lt;/a&gt;&#39; </span>+            <span style="color:#a31515">&#39;：WEIBO_TEXT&lt;div class=&quot;time&quot;&gt;AGO&lt;/div&gt;&#39;</span>;            <span style="color:green">// Appends weibos into html page.            </span><span style="color:blue">for </span>(<span style="color:blue">var </span>i = 0; i &lt; data.length; i++) {                $(JQWeibo.appendTo).append(                html.replace(<span style="color:#a31515">'WEIBO_TEXT'</span>, JQWeibo.ify.clean(data[i].text))                <span style="color:green">// Uses regex and declare DOMAIN as global, if found replace all.                    </span>.replace(/DOMAIN/g, data[i].user.domain)                    .replace(/USER/g, data[i].user.screen_name)                    .replace(<span style="color:#a31515">'AGO'</span>, JQWeibo.timeAgo(data[i].created_at))            );            }        }    })}</pre><p>　　现在，我们使用$.ajax()方法向微博API发送跨源请求，而且我们向API传递了JQWeibo.appKey和JQWeibo.numWeibo，当请求完成后，调用Success()方法把JSON数据插入的页面当中。</p><p>　　页面的HTML代码如下：</p><pre><span style="color:blue">&lt;!</span><span style="color:#a31515">DOCTYPE </span><span style="color:red">HTML PUBLIC </span><span style="color:blue">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;        &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;</span><span style="color:#a31515">html</span><span style="color:blue">&gt;&lt;</span><span style="color:#a31515">head</span><span style="color:blue">&gt;    &lt;</span><span style="color:#a31515">meta </span><span style="color:red">http-equiv</span><span style="color:blue">="Content-Type" </span><span style="color:red">content</span><span style="color:blue">=&quot;text/html;charset=UTF-8&quot;&gt;    &lt;</span><span style="color:#a31515">title</span><span style="color:blue">&gt;</span>Weibo Feed<span style="color:blue">&lt;/</span><span style="color:#a31515">title</span><span style="color:blue">&gt;    &lt;</span><span style="color:#a31515">script </span><span style="color:red">type</span><span style="color:blue">="text/javascript" </span><span style="color:red">src</span><span style="color:blue">=&quot;http://ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.min.js&quot;&gt;&lt;/</span><span style="color:#a31515">script</span><span style="color:blue">&gt;    &lt;</span><span style="color:#a31515">link </span><span style="color:red">rel</span><span style="color:blue">="stylesheet" </span><span style="color:red">type</span><span style="color:blue">="text/css" </span><span style="color:red">href</span><span style="color:blue">=&quot;css/WeiboFeed.css&quot;&gt;&lt;/</span><span style="color:#a31515">head</span><span style="color:blue">&gt;&lt;</span><span style="color:#a31515">body</span><span style="color:blue">&gt;    &lt;</span><span style="color:#a31515">div </span><span style="color:red">id</span><span style="color:blue">=&quot;jsWeibo&quot;&gt;&lt;/</span><span style="color:#a31515">div</span><span style="color:blue">&gt;&lt;/</span><span style="color:#a31515">body</span><span style="color:blue">&gt;&lt;/</span><span style="color:#a31515">html</span><span style="color:blue">&gt;</span></pre><p align="center"><a href="http://images.cnblogs.com/cnblogs_com/rush/201205/201205152124091502.png"><img style="display:block;float:none;margin-left:auto;margin-right:auto;border-width:0px" title="ajax9" src="http://images.cnblogs.com/cnblogs_com/rush/201205/201205152124122351.png" alt="ajax9" width="371" height="596" border="0"></a>图8 跨源数据</p><p>　　如上图所示，我们使用$.ajax()方法调用公共微博接口，当成功获取服务器回调数据插入到我们的页面当中。</p><p><strong>　　1.1.3 总结</strong></p><p>　　本文主要介绍了Ajax在同源请求适用性，但在跨源请求中其存在的局限性，进而介绍Ajax和JSONP在跨源请求下解决方法。</p><p>　　回答qianlifeng关于跨源请求的几个问题：</p><p>　　1. 一般的跨源不用jsonp请求为什么会报错？和同源的不都是一个请求么？（可能对ajax了解不深）</p><p>　　答：首先跨源请求的解决方法不仅仅有JSON，本文中提及了其他方法，如：表单POST方式、服务器代理、Html5的XDomainRequest和Flash request等；而你提到报错，我觉得你首先要确认数据格式是否正确。关于跨原请求和同源请求本文已经给出了介绍。</p><p>　　2. 关于“用Javascript定义回调函数”那块看的不是很明白。传递当前页面的一个js方法给跨源服务器，为什么就能跨源请求了呢？（JSONP？） 服务端根据这个js方法做了什么操作啊？</p><p>　　答：首先我们理解JSON是一种数据格式，而JSONP像似通过一个方法名来封装JSON格式；而跨源请求不是说指定一个回调函数实现的，而是我们利用了浏览器允许跨源请求&lt;script&gt;资源，你也可以我的HTML代码中使用的是Google提供的jQuery库，这也说明了&lt;script&gt;资源可以跨源请求。当我们发送跨源请求后，服务器会返回JSONP，但服务器无法预知接受JSON数据的方法名，所有我们要把函数名告诉（传递）服务器。</p><pre><span style="color:green">//JSON </span><span style="color:black">{</span><span style="color:#dc1414">"name"</span><span style="color:black">:</span><span style="color:#dc1414">"JK_Rush"</span><span style="color:black">,</span><span style="color:#dc1414">"id"</span><span style="color:black">:</span><span style="color:#c81efa">23</span><span style="color:black">} </span><span style="color:green">//JSONP </span><span style="color:black">func({</span><span style="color:#dc1414">"name"</span><span style="color:black">:</span><span style="color:#dc1414">"JK_Rush"</span><span style="color:black">,</span><span style="color:#dc1414">"id"</span><span style="color:black">:</span><span style="color:#c81efa">23</span><span style="color:black">}); </span></pre><p>　　3. 看你新浪微博的那个例子，是jquery的ajax对跨源做了处理？能不能说说您提到的两种跨源方式的区别或者不同的应用场景，还是随便都一样？</p><p>　　答：是通过$.ajax()方法实现的，如果你想使用动态Javascript实现也可以；至于两种跨源的区别已经在博文中指出了。</p><p>　　回答@On the road....关于JSON反序列化为对象的实现：</p><p>　　答：一般我们可以通过三种方法把JSON数据反序列化为对象，分别是：ASP.NET AJAX中引入的JavaScriptSerializer，WCF中引入的DataContractJsonSerializer，以及Json.NET。</p><p>　　假设，我们获取到员工信息（employee）的JSON数据，它包含两个属性分别是id和复杂属性name，具体如下所示：</p><pre><span style="color:black">[  {    </span><span style="color:#dc1414">"id"</span><span style="color:black">: </span><span style="color:#dc1414">"82105"</span><span style="color:black">,    </span><span style="color:#dc1414">"name"</span><span style="color:black">: {      </span><span style="color:#dc1414">"lastName"</span><span style="color:black">: </span><span style="color:#dc1414">"Huang"</span><span style="color:black">,      </span><span style="color:#dc1414">"firstName"</span><span style="color:black">: </span><span style="color:#dc1414">"JK"    </span><span style="color:black">}  },  {    </span><span style="color:#dc1414">"id"</span><span style="color:black">: </span><span style="color:#dc1414">"82106"</span><span style="color:black">,    </span><span style="color:#dc1414">"name"</span><span style="color:black">: {      </span><span style="color:#dc1414">"lastName"</span><span style="color:black">: </span><span style="color:#dc1414">"Leung"</span><span style="color:black">,      </span><span style="color:#dc1414">"firstName"</span><span style="color:black">: </span><span style="color:#dc1414">"Cindy"    </span><span style="color:black">}  }]</span><span style="color:blue">string </span><span style="color:black">data = </span><span style="color:#dc1414">"[{\"id\":\"82105\",\"fullname\":{\"lastName\":\"Huang\",\"firstName\":\"JK\"}}," </span><span style="color:black">+     </span><span style="color:#dc1414">"{\"id\":\"82106\",\"fullname\":{\"lastName\":\"Leung\",\"firstName\":\"Cindy\"}}]"</span><span style="color:black">;</span></pre><p>　　根据上述JSON数据的组成，我们定义出相应的对象模型，具体定义如下：</p><pre><span style="color:green">// The Employee model.</span><span style="color:blue">public class </span><span style="color:black">Employee{    </span><span style="color:blue">public int </span><span style="color:black">Id { </span><span style="color:blue">get</span><span style="color:black">; </span><span style="color:blue">set</span><span style="color:black">; }    </span><span style="color:blue">public </span><span style="color:black">Name FullName { </span><span style="color:blue">get</span><span style="color:black">; </span><span style="color:blue">set</span><span style="color:black">; }}</span><span style="color:green">// The Name model.</span><span style="color:blue">public class </span><span style="color:black">Name{    </span><span style="color:blue">public string </span><span style="color:black">FirstName { </span><span style="color:blue">get</span><span style="color:black">; </span><span style="color:blue">set</span><span style="color:black">; }    </span><span style="color:blue">public string </span><span style="color:black">LastName { </span><span style="color:blue">get</span><span style="color:black">; </span><span style="color:blue">set</span><span style="color:black">; }}</span></pre><p>　　接下来，我们将介绍使用JavaScriptSerializer，Json.NET和DataContractJsonSerializer反序列化JSON数据为对象。</p><p><strong>　　JavaScriptSerializer</strong></p><pre><span style="color:blue">var </span><span style="color:black">serializer = </span><span style="color:blue">new </span><span style="color:black">JavaScriptSerializer();</span><span style="color:blue">var </span><span style="color:black">employees= serializer.Deserialize&lt;Employee[]&gt;(data);</span></pre><p><strong>　　Json.NET</strong></p><pre><span style="color:blue">using </span><span style="color:black">(</span><span style="color:blue">var </span><span style="color:black">stringReader = </span><span style="color:blue">new </span><span style="color:black">StringReader(data))</span><span style="color:blue">using </span><span style="color:black">(</span><span style="color:blue">var </span><span style="color:black">jsonTextReader = </span><span style="color:blue">new </span><span style="color:black">JsonTextReader(stringReader)){    </span><span style="color:blue">var </span><span style="color:black">serializer = </span><span style="color:blue">new </span><span style="color:black">JsonSerializer();    </span><span style="color:blue">var </span><span style="color:black">employees = serializer.Deserialize&lt;Employee[]&gt;(jsonTextReader);}</span></pre><p><strong>　　DataContractJsonSerializer</strong></p><p>　　对于使用WCF的DataContractJsonSerializer方法，我们需要在对象模型添加DataContract和DataMember属性，具体定义如下：</p><pre><span style="color:black">[DataContract]</span><span style="color:blue">public class </span><span style="color:black">Employee{    [DataMember(Name = </span><span style="color:#dc1414">"id"</span><span style="color:black">)]    </span><span style="color:blue">public int </span><span style="color:black">Id { </span><span style="color:blue">get</span><span style="color:black">; </span><span style="color:blue">set</span><span style="color:black">; }    [DataMember(Name = </span><span style="color:#dc1414">"fullname"</span><span style="color:black">)]    </span><span style="color:blue">public </span><span style="color:black">Name FullName { </span><span style="color:blue">get</span><span style="color:black">; </span><span style="color:blue">set</span><span style="color:black">; }}[DataContract]</span><span style="color:blue">public class </span><span style="color:black">Name{    [DataMember(Name = </span><span style="color:#dc1414">"firstName"</span><span style="color:black">)]    </span><span style="color:blue">public string </span><span style="color:black">FirstName { </span><span style="color:blue">get</span><span style="color:black">; </span><span style="color:blue">set</span><span style="color:black">; }    [DataMember(Name = </span><span style="color:#dc1414">"lastName"</span><span style="color:black">)]    </span><span style="color:blue">public string </span><span style="color:black">LastName { </span><span style="color:blue">get</span><span style="color:black">; </span><span style="color:blue">set</span><span style="color:black">; }}</span></pre><p>　　接着我们使用ReadObjects()方法把JSON数据转换为对象。</p><pre><span style="color:blue">using </span><span style="color:black">(MemoryStream ms = </span><span style="color:blue">new </span><span style="color:black">MemoryStream(Encoding.UTF8.GetBytes(data))) {     DataContractJsonSerializer serializer = </span><span style="color:blue">new </span><span style="color:black">DataContractJsonSerializer(</span><span style="color:blue">typeof</span><span style="color:black">(List&lt;Employee&gt;));    </span><span style="color:blue">var </span><span style="color:black">employee = (List&lt;Employee&gt;)serializer.ReadObject(ms); }</span></pre><p><strong>　　参考</strong></p><ul><li><a href="https://developer.mozilla.org/en/XMLHttpRequest">https://developer.mozilla.org/en/XMLHttpRequest</a></li><li><a href="http://www.w3schools.com/xml/xml_http.asp">http://www.w3schools.com/xml/xml_http.asp</a></li><li><a href="http://msdn.microsoft.com/en-us/library/windows/apps/cc836466%28v=vs.85%29.aspx">http://msdn.microsoft.com/en-us/library/windows/apps/cc836466%28v=vs.85%29.aspx</a></li><li><a href="http://ntesmailfetc.blog.163.com/blog/static/206287061201241011546581/">http://ntesmailfetc.blog.163.com/blog/static/206287061201241011546581/</a></li><li><a title="http://justcoding.iteye.com/blog/1366102" href="http://justcoding.iteye.com/blog/1366102">http://justcoding.iteye.com/blog/1366102</a></li><li><a title="http://www.queness.com/post/8567/create-a-dead-simple-twitter-feed-with-jquery" href="http://www.queness.com/post/8567/create-a-dead-simple-twitter-feed-with-jquery">http://www.queness.com/post/8567/create-a-dead-simple-twitter-feed-with-jquery</a></li></ul></h2></h2></h2></h2>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
