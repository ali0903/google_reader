<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>深入理解JavaScript系列（50）：Function模式（下篇）</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>深入理解JavaScript系列（50）：Function模式（下篇）</h2>
<p class="meta">2012-07-24 17:07</p>

<div class="post">
<h2>深入理解JavaScript系列（50）：Function模式（下篇）</h2>

<h3>by 汤姆大叔</h3>

<h3>at 2012-07-24 09:07:00</h3>

<h3>original <a href="http://www.cnblogs.com/TomXu/archive/2012/07/24/2581239.html">http://www.cnblogs.com/TomXu/archive/2012/07/24/2581239.html</a></h3>

<h1>介绍</h1>


<p><br><p>本篇我们介绍的一些模式称为初始化模式和性能模式，主要是用在初始化以及提高性能方面，一些模式之前已经提到过，这里只是做一下总结。</p><br><h1>立即执行的函数</h1><br><p>在本系列第4篇的《<a href="http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html">立即调用的函数表达式</a>》中，我们已经对类似的函数进行过详细的描述，这里我们只是再举两个简单的例子做一下总结。</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#008000">//</span><span style="color:#008000"> 声明完函数以后，立即执行该函数</span><br>(<span style="color:#0000ff">function</span><span style="color:#000000"> () {<br>    console.log(</span>'watch out!'<span style="color:#000000">);<br>} ());<br><br></span><span style="color:#008000">//</span><span style="color:#008000">这种方式声明的函数，也可以立即执行</span><br>!<span style="color:#0000ff">function</span><span style="color:#000000"> () {<br>    console.log(</span>'watch out!'<span style="color:#000000">);<br>} ();<br><br></span><span style="color:#008000">//</span><span style="color:#008000"> 如下方式也都可以哦</span><br>~<span style="color:#0000ff">function</span> () { <span style="color:#008000">/<em></span><span style="color:#008000"> code </span><span style="color:#008000"></em>/</span><span style="color:#000000"> } ();<br></span>-<span style="color:#0000ff">function</span> () { <span style="color:#008000">/<em></span><span style="color:#008000"> code </span><span style="color:#008000"></em>/</span><span style="color:#000000"> } ();<br></span>+<span style="color:#0000ff">function</span> () { <span style="color:#008000">/<em></span><span style="color:#008000"> code </span><span style="color:#008000"></em>/</span> } ();</pre><br></div><br><h1>立即执行的对象初始化</h1><br><p>该模式的意思是指在声明一个对象（而非函数）的时候，立即执行对象里的某一个方法来进行初始化工作，通常该模式可以用在一次性执行的代码上。</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#000000">({<br>    </span><span style="color:#008000">//</span><span style="color:#008000"> 这里你可以定义常量，设置其它值</span><br>    maxwidth: 600<span style="color:#000000">,<br>    maxheight: </span>400<span style="color:#000000">,<br><br>    </span><span style="color:#008000">//</span><span style="color:#008000">  当然也可以定义utility方法</span><br>    gimmeMax: <span style="color:#0000ff">function</span><span style="color:#000000"> () {<br>        </span><span style="color:#0000ff">return</span> <span style="color:#0000ff">this</span>.maxwidth + "x" + <span style="color:#0000ff">this</span><span style="color:#000000">.maxheight;<br>    },<br><br>    </span><span style="color:#008000">//</span><span style="color:#008000"> 初始化</span><br>    init: <span style="color:#0000ff">function</span><span style="color:#000000"> () {<br>        console.log(</span><span style="color:#0000ff">this</span><span style="color:#000000">.gimmeMax());<br>        </span><span style="color:#008000">//</span><span style="color:#008000"> 更多代码...</span><br><span style="color:#000000">    }<br>}).init();  </span><span style="color:#008000">//</span><span style="color:#008000"> 这样就开始初始化咯</span></pre><br></div><br><h1>分支初始化</h1><br><p>分支初始化是指在初始化的时候，根据不同的条件（场景）初始化不同的代码，也就是所谓的条件语句赋值。之前我们在做事件处理的时候，通常使用类似下面的代码：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">var</span> utils =<span style="color:#000000"> {<br>    addListener: </span><span style="color:#0000ff">function</span><span style="color:#000000"> (el, type, fn) {<br>        </span><span style="color:#0000ff">if</span> (<span style="color:#0000ff">typeof</span> window.addEventListener === 'function'<span style="color:#000000">) {<br>            el.addEventListener(type, fn, </span><span style="color:#0000ff">false</span><span style="color:#000000">);<br>        } </span><span style="color:#0000ff">else</span> <span style="color:#0000ff">if</span> (<span style="color:#0000ff">typeof</span> document.attachEvent !== 'undefined'<span style="color:#000000">) {<br>            el.attachEvent(</span>'on' +<span style="color:#000000"> type, fn);<br>        } </span><span style="color:#0000ff">else</span><span style="color:#000000"> {<br>            el[</span>'on' + type] =<span style="color:#000000"> fn;<br>        }<br>    },<br>    removeListener: </span><span style="color:#0000ff">function</span><span style="color:#000000"> (el, type, fn) {<br>    }<br>};</span></pre><br></div><br><p>我们来改进一下，首先我们要定义两个接口，一个用来add事件句柄，一个用来remove事件句柄，代码如下：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">var</span> utils =<span style="color:#000000"> {<br>    addListener: </span><span style="color:#0000ff">null</span><span style="color:#000000">,<br>    removeListener: </span><span style="color:#0000ff">null</span><span style="color:#000000"><br>};</span></pre><br></div><br><p>实现代码如下：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">if</span> (<span style="color:#0000ff">typeof</span> window.addEventListener === 'function'<span style="color:#000000">) {<br>    utils.addListener </span>= <span style="color:#0000ff">function</span><span style="color:#000000"> (el, type, fn) {<br>        el.addEventListener(type, fn, </span><span style="color:#0000ff">false</span><span style="color:#000000">);<br>    };<br>} </span><span style="color:#0000ff">else</span> <span style="color:#0000ff">if</span> (<span style="color:#0000ff">typeof</span> document.attachEvent !== 'undefined') { <span style="color:#008000">//</span><span style="color:#008000"> IE</span><br>    utils.addListener = <span style="color:#0000ff">function</span><span style="color:#000000"> (el, type, fn) {<br>        el.attachEvent(</span>'on' +<span style="color:#000000"> type, fn);<br>    };<br>    utils.removeListener </span>= <span style="color:#0000ff">function</span><span style="color:#000000"> (el, type, fn) {<br>        el.detachEvent(</span>'on' +<span style="color:#000000"> type, fn);<br>    };<br>} </span><span style="color:#0000ff">else</span> { <span style="color:#008000">//</span><span style="color:#008000"> 其它旧浏览器</span><br>    utils.addListener = <span style="color:#0000ff">function</span><span style="color:#000000"> (el, type, fn) {<br>        el[</span>'on' + type] =<span style="color:#000000"> fn;<br>    };<br>    utils.removeListener </span>= <span style="color:#0000ff">function</span><span style="color:#000000"> (el, type, fn) {<br>        el[</span>'on' + type] = <span style="color:#0000ff">null</span><span style="color:#000000">;<br>    };<br>}</span></pre><br></div><br><p>用起来，是不是就很方便了？代码也优雅多了。</p><br><h1>自声明函数</h1><br><p>一般是在函数内部，重写同名函数代码，比如：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">var</span> scareMe = <span style="color:#0000ff">function</span><span style="color:#000000"> () {<br>    alert(</span>"Boo!"<span style="color:#000000">);<br>    scareMe </span>= <span style="color:#0000ff">function</span><span style="color:#000000"> () {<br>        alert(</span>"Double boo!"<span style="color:#000000">);<br>    };<br>};</span></pre><br></div><br><p>这种代码，非常容易使人迷惑，我们先来看看例子的执行结果：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#008000">//</span><span style="color:#008000"> 1. 添加新属性</span><br>scareMe.property = "properly"<span style="color:#000000">;<br></span><span style="color:#008000">//</span><span style="color:#008000"> 2. scareMe赋与一个新值</span><br><span style="color:#0000ff">var</span> prank =<span style="color:#000000"> scareMe;<br></span><span style="color:#008000">//</span><span style="color:#008000"> 3. 作为一个方法调用</span><br><span style="color:#0000ff">var</span> spooky =<span style="color:#000000"> {<br>    boo: scareMe<br>};<br></span><span style="color:#008000">//</span><span style="color:#008000"> 使用新变量名称进行调用</span><br>prank(); <span style="color:#008000">//</span><span style="color:#008000"> "Boo!"</span><br>prank(); <span style="color:#008000">//</span><span style="color:#008000"> "Boo!"</span><br>console.log(prank.property); <span style="color:#008000">//</span><span style="color:#008000"> "properly"</span><span style="color:#008000"><br>//</span><span style="color:#008000"> 使用方法进行调用</span><br>spooky.boo(); <span style="color:#008000">//</span><span style="color:#008000"> "Boo!"</span><br>spooky.boo(); <span style="color:#008000">//</span><span style="color:#008000"> "Boo!"</span><br>console.log(spooky.boo.property); <span style="color:#008000">//</span><span style="color:#008000"> "properly"</span></pre><br></div><br><p>通过执行结果，可以发现，将定于的函数赋值与新变量（或内部方法），代码并不执行重载的scareMe代码，而如下例子则正好相反：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#008000">//</span><span style="color:#008000"> 使用自声明函数</span><br>scareMe(); <span style="color:#008000">//</span><span style="color:#008000"> Double boo!</span><br>scareMe(); <span style="color:#008000">//</span><span style="color:#008000"> Double boo!</span><br>console.log(scareMe.property); <span style="color:#008000">//</span><span style="color:#008000"> undefined</span></pre><br></div><br><p>大家使用这种模式时，一定要非常小心才行，否则实际结果很可能和你期望的结果不一样，当然你也可以利用这个特殊做一些特殊的操作。</p><br><h1>内存优化</h1><br><p>该模式主要是利用函数的属性特性来避免大量的重复计算。通常代码形式如下：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">var</span> myFunc = <span style="color:#0000ff">function</span><span style="color:#000000"> (param) {<br>    </span><span style="color:#0000ff">if</span> (!<span style="color:#000000">myFunc.cache[param]) {<br>        </span><span style="color:#0000ff">var</span> result =<span style="color:#000000"> {};<br>        </span><span style="color:#008000">//</span><span style="color:#008000"> ... 复杂操作 ...</span><br>        myFunc.cache[param] =<span style="color:#000000"> result;<br>    }<br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> myFunc.cache[param];<br>};<br><br></span><span style="color:#008000">//</span><span style="color:#008000"> cache 存储</span><br>myFunc.cache = {};</pre><br></div><br><p>但是上述代码有个问题，如果传入的参数是toString或者其它类似Object拥有的一些公用方法的话，就会出现问题，这时候就需要使用传说中的<code>hasOwnProperty</code>方法了，代码如下：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">var</span> myFunc = <span style="color:#0000ff">function</span><span style="color:#000000"> (param) {<br>    </span><span style="color:#0000ff">if</span> (!<span style="color:#000000">myFunc.cache.hasOwnProperty(param)) {<br>        </span><span style="color:#0000ff">var</span> result =<span style="color:#000000"> {};<br>        </span><span style="color:#008000">//</span><span style="color:#008000"> ... 复杂操作 ...</span><br>        myFunc.cache[param] =<span style="color:#000000"> result;<br>    }<br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> myFunc.cache[param];<br>};<br><br></span><span style="color:#008000">//</span><span style="color:#008000"> cache 存储</span><br>myFunc.cache = {};</pre><br></div><br><p>或者如果你传入的参数是多个的话，可以将这些参数通过JSON的stringify方法生产一个cachekey值进行存储，代码如下：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">var</span> myFunc = <span style="color:#0000ff">function</span><span style="color:#000000"> () {<br>    </span><span style="color:#0000ff">var</span> cachekey =<span style="color:#000000"> JSON.stringify(Array.prototype.slice.call(arguments)),<br>        result;<br>    </span><span style="color:#0000ff">if</span> (!<span style="color:#000000">myFunc.cache[cachekey]) {<br>        result </span>=<span style="color:#000000"> {};<br>        </span><span style="color:#008000">//</span><span style="color:#008000"> ... 复杂操作 ...</span><br>        myFunc.cache[cachekey] =<span style="color:#000000"> result;<br>    }<br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> myFunc.cache[cachekey];<br>};<br><br></span><span style="color:#008000">//</span><span style="color:#008000"> cache 存储</span><br>myFunc.cache = {};</pre><br></div><br><p>或者多个参数的话，也可以利用arguments.callee特性：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">var</span> myFunc = <span style="color:#0000ff">function</span><span style="color:#000000"> (param) {<br>    </span><span style="color:#0000ff">var</span> f =<span style="color:#000000"> arguments.callee,<br>        result;<br>    </span><span style="color:#0000ff">if</span> (!<span style="color:#000000">f.cache[param]) {<br>        result </span>=<span style="color:#000000"> {};<br>        </span><span style="color:#008000">//</span><span style="color:#008000"> ... 复杂操作 ...</span><br>        f.cache[param] =<span style="color:#000000"> result;<br>    }<br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> f.cache[param];<br>};<br><br></span><span style="color:#008000">//</span><span style="color:#008000"> cache 存储</span><br>myFunc.cache = {};</pre><br></div><br><h1>总结</h1><br><p>就不用总结了吧，大家仔细看代码就行咯</p><br><h1>同步与推荐</h1><br><p>本文已同步至目录索引：<span style="font-size:14pt"><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html">深入理解JavaScript系列</a></span></p><br><p>深入理解JavaScript系列文章，包括了原创，翻译，转载等各类型的文章，如果对你有用，请推荐支持一把，给大叔写作的动力。</p><img src="http://www.cnblogs.com/TomXu/aggbug/2581239.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/TomXu/archive/2012/07/24/2581239.html">本文链接</a></p></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
