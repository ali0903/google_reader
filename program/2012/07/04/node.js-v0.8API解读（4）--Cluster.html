<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>node.js-v0.8API解读（4）- Cluster</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>node.js-v0.8API解读（4）- Cluster</h2>
<p class="meta">2012-07-04 00:41</p>

<div class="post">
<h2>node.js-v0.8API解读（4）- Cluster</h2>

<h3>by snoopyxdy</h3>

<h3>at 2012-07-03 16:41:18</h3>

<h3>original <a href="http://snoopyxdy.blog.163.com/blog/static/601174402012631365989">http://snoopyxdy.blog.163.com/blog/static/601174402012631365989</a></h3>

<div>在node-v0.7版本中就对cluster模块增加了不少功能，由于一直是unstable版本，所以也没仔细看，这次0.8版本将cluster放进了doc中，官网的0.8介绍页单独将cluster模块作为介绍一条了：<div><b>4、The cluster module is much more awesome.</b></div><div>我们来看下cluster现在健壮到什么程度了。</div><div><br></div><div>接下来，我们就对cluster模块做一些说明：</div><div>1、很遗憾，目前cluster模块还是处于<span style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:1.5438em;background-color:rgb(248,248,248);text-align:-webkit-auto">Stability</span><span style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;background-color:rgb(248,248,248);text-align:-webkit-auto;color:rgb(51,51,51)">:</span><span style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:1.5438em;background-color:rgb(248,248,248);text-align:-webkit-auto"> </span><span style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;background-color:rgb(248,248,248);text-align:-webkit-auto;color:rgb(102,153,0)">1</span><span style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:1.5438em;background-color:rgb(248,248,248);text-align:-webkit-auto"> </span><span style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;background-color:rgb(248,248,248);text-align:-webkit-auto;color:rgb(51,51,51)">-</span><span style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:1.5438em;background-color:rgb(248,248,248);text-align:-webkit-auto"> Experimental 实验阶段，所以大家在使用这个模块的时候还是悠着点吧，不过至少我目前用在项目中的情况来看，还是比较稳定的，没有DOWN，我开了4个worker用来监听不同的端口，做在线聊天的服务器。</span></div><div><span style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:1.5438em;background-color:rgb(248,248,248);text-align:-webkit-auto"><br></span></div><div><span style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:1.5438em;background-color:rgb(248,248,248);text-align:-webkit-auto">2、</span><font face="Monaco, Consolas, Lucida Console, monospace"><span style="line-height:21px">cluster.settings<br>是一个只读的对象，对象有3个key</span></font></div><div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px">exec String file path to worker file. (Default=__filename)</div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px"><font color="#3366ff">//执行程序的路径，默认是__filename</font></div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px">args Array string arguments passed to worker. (Default=process.argv.slice(2))</div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px"><font color="#3366ff">//参数的数组，就是执行这个程序所带的参数</font></div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px">silent Boolean whether or not to send output to parent's stdio. (Default=false)</div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px"><font color="#3366ff">//是否silent启动，如果是silent启动则不会再控制台输出消息</font></div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px"><br></div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px">这个属性要设置的话，需要使用cluster.setupMaster([settings])来进行设置，这个settings就是上面这3个key的对象。</div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px"><br></div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px">3、cluster.isMaster<br>返回一个布尔值，表示当前进程是否是Master主进程，同理cluster.isWorker</div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px"><br></div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px">4、fork事件</div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px">当一个新的worker fork了，主进程就会受到一个fork的事件，官方给出了下面这些代码用来处理fork一个子进程超时的情况的：</div><div><pre><p>var timeouts = [];<br>function errorMsg() {<br>  console.error("Something must be wrong with the connection ...");<br>}<br><br>cluster.on('fork', function(worker) {<br>  timeouts[worker.id] = setTimeout(errorMsg, 2000);<br>});<br>cluster.on('listening', function(worker, address) {<br>  clearTimeout(timeouts[worker.id]);<br>});<br>cluster.on('exit', function(worker, code, signal) {<br>  clearTimeout(timeouts[worker.id]);<br>  errorMsg();<br>});</p></pre>简单解释下以上代码，当我们批量fork了几个worker后，就会触发fork事件了，于是我们为每一个worker设定了一个timeout。</div><div>在此之前，我们还添加了listening和exit的事件监听，一旦触发了这些事件，都将把这个worker的定时器清零。</div><div><br></div><div>5、online 事件</div><div>当worker被fork后，会通知master，于是master就会触发online事件，当online事件触发，就说明子进程已经完全建立起来了。可以说是onready事件。</div><div><pre><p>cluster.on('online', function(worker) {<br>  console.log("Yay, the worker responded after it was forked");<br>});</p></pre><br></div><div>6、listening 事件</div><div>当worker有.listen()方法执行后，就会向Master告知，并触发listening事件，我们可以拿到woker的对象和监听的地址以及端口。</div><div><pre><p>cluster.on('listening', function(worker, address) {<br>  console.log("A worker is now connected to " + address.address + ":" + address.port);<br>});</p></pre><br></div><div>7、disconnect 事件</div><div>disconnect 事件是0.6版本以后添加的，当主进程执行disconnect()方法时，主进程就会触发disconnect事件</div><div><br></div><div>8、exit 事件</div><div>当worker退出触发此事件，</div><div><br></div><div>9、setup 事件</div><div>当主进程执行.setupMaster()方法时，就吹触发setup事件</div><div><br></div><div>10、cluster.setupMaster([settings])</div><div>见上面</div><div><br></div><div>11、cluster.fork([env])</div><div>这个产生一个新的worker，这个方法只能在master中执行，env是一个key/value对，用来添加到worker中，这个方法将返回一个worker的对象。</div><div>比如，我们这样fork子进程 cluster.fork({name:'snoopy'})</div><div>这样在worker进程中获取变量：process.env.name //snoopy</div><div><br></div><div>12、cluster.disconnect([callback])</div><div>执行这个方法将让所有的worker优雅的自杀，等素有worker都死了之后执行callback函数。</div><div><br></div><div>13、cluster.workers</div><div>返回一个对象，work的id为key的work对象为value的对象。</div><div><br></div><div>14、worker.id</div><div>work子进程的id</div><div><br></div><div>15、worker.process</div><div>返回一个ChildProcess 对象</div><div><br></div><div>16、worker.suicide</div><div>一个布尔值，表示worker是否自杀了，在worker.destroy()或者.disconnect()方法执行后设置为true</div><div><br></div><div>17、worker.send(message, [sendHandle])</div><div>在主进程将对指定的worker发送msg，在worker，则可以执行process.send(msg);</div><div><br></div><div>18、worker.destroy()</div><div>杀死指定的worker进程，官方代码判断是否真被杀死：</div><div><pre><p>cluster.on('exit', function(worker, code, signal) {<br>  if (worker.suicide === true) {<br>    console.log('Oh, it was just suicide\' – no need to worry').<br>  }<br>});<br><br>// destroy worker<br>worker.destroy();</p></pre><br></div><div>19、worker.disconnect()</div><div>优雅的杀死worker，此worker进程不会接受其他请求，会在处理完当前事情之后自杀，下面是一段代码，用来优雅自杀，并且超时时间2秒：</div><div><br></div><div><pre><p>if (cluster.isMaster) {<br>  var worker = cluser.fork();<br>  var timeout;<br><br>  worker.on('listening', function(address) {<br>    worker.disconnect();<br>    timeout = setTimeout(function() {<br>      worker.send('force kill');<br>    }, 2000);<br>  });<br><br>  worker.on('disconnect', function() {<br>    clearTimeout(timeout);<br>  });<br><br>} else if (cluster.isWorker) {<br>  var net = require('net');<br>  var server = net.createServer(function(socket) {<br>    // connection never end<br>  });<br><br>  server.listen(8000);<br><br>  server.on('close', function() {<br>    // cleanup<br>  });<br><br>  process.on('message', function(msg) {<br>    if (msg === 'force kill') {<br>      server.destroy();<br>    }<br>  });<br>}</p></pre><br></div><div>20、message 事件</div><div>当worker收到message执行</div><div><br></div><div>21、online\listening\disconnect</div><div>和上面的cluster的事件相同，只不过这里的监听是针对单个worker进程的</div><div><br></div><div>22、exit 事件</div><div>相关的worker进程死掉之后触发</div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px"><br></div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px"><br></div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px"><br></div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px"><br></div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px"><br></div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px"><br></div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px"><br></div><div style="font-family:Monaco,Consolas,&#39;Lucida Console&#39;,monospace;line-height:21px"><br></div></div><div><br><div><br><br></div></div></div>


</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
