<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>深入理解JavaScript系列（49）：Function模式（上篇）</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>深入理解JavaScript系列（49）：Function模式（上篇）</h2>
<p class="meta">2012-07-23 19:43</p>

<div class="post">
<h2>深入理解JavaScript系列（49）：Function模式（上篇）</h2>

<h3>by 汤姆大叔</h3>

<h3>at 2012-07-23 11:43:00</h3>

<h3>original <a href="http://www.cnblogs.com/TomXu/archive/2012/07/23/2580701.html">http://www.cnblogs.com/TomXu/archive/2012/07/23/2580701.html</a></h3>

<h1>介绍</h1>


<p><br><p>本篇主要是介绍Function方面使用的一些技巧（上篇），利用Function特性可以编写出很多非常有意思的代码，本篇主要包括：回调模式、配置对象、返回函数、分布程序、柯里化（Currying）。</p><br><h1>回调函数</h1><br><p>在JavaScript中，当一个函数A作为另外一个函数B的其中一个参数时，则函数A称为回调函数，即A可以在函数B的周期内执行（开始、中间、结束时均可）。</p><br><p>举例来说，有一个函数用于生成node</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">var</span> complexComputation = <span style="color:#0000ff">function</span> () { <span style="color:#008000">/<em></span><span style="color:#008000"> 内部处理，并返回一个node</span><span style="color:#008000"></em>/</span>};</pre><br></div><br><p>有一个findNodes函数声明用于查找所有的节点，然后通过callback回调进行执行代码。</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">var</span> findNodes =<span style="color:#000000"><span style="color:#0000ff"> function</span> (callback) {<br></span><span style="color:#0000ff">var</span> nodes =<span style="color:#000000"> [];<br><br></span><span style="color:#0000ff">var</span> node =<span style="color:#000000"> complexComputation();<br><br></span><span style="color:#008000">//</span><span style="color:#008000"> 如果回调函数可用，则执行它</span><br><span style="color:#0000ff">if</span> (<span style="color:#0000ff">typeof</span> callback === <span style="color:#800000">"</span><span style="color:#800000">function</span><span style="color:#800000">"</span><span style="color:#000000">) {<br>callback(node);<br>}<br><br>nodes.push(node);<br></span><span style="color:#0000ff">return</span><span style="color:#000000"> nodes;<br>};</span></pre><br></div><br><p>关于callback的定义，我们可以事先定义好来用：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#008000">//</span><span style="color:#008000"> 定义callback</span><br><span style="color:#0000ff">var</span> hide =<span style="color:#000000"> function (node) {<br>node.style.display </span>= <span style="color:#800000">"</span><span style="color:#800000">none</span><span style="color:#800000">"</span><span style="color:#000000">;<br>};<br><br></span><span style="color:#008000">//</span><span style="color:#008000"> 查找node，然后隐藏所有的node</span><br><span style="color:#0000ff">var</span> hiddenNodes = findNodes(hide);</pre><br></div><br><p>也可以直接在调用的时候使用匿名定义，如下：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#008000">//</span><span style="color:#008000"> 使用匿名函数定义callback</span><br><span style="color:#0000ff">var</span> blockNodes =<span style="color:#000000"> findNodes(function (node) {<br>node.style.display </span>= <span style="color:#800000">'</span><span style="color:#800000">block</span><span style="color:#800000">'</span><span style="color:#000000">;<br>});</span></pre><br></div><br><p>我们平时用的最多的，估计就数jQuery的ajax方法的调用了，通过在done/faild上定义callback，以便在ajax调用成功或者失败的时候做进一步处理，代码如下(本代码基于jquery1.8版)：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">var</span> menuId = $(<span style="color:#800000">"</span><span style="color:#800000">ul.nav</span><span style="color:#800000">"</span>).first().attr(<span style="color:#800000">"</span><span style="color:#800000">id</span><span style="color:#800000">"</span><span style="color:#000000">);<br></span><span style="color:#0000ff">var</span> request =<span style="color:#000000"> $.ajax({<br>  url: </span><span style="color:#800000">"</span><span style="color:#800000">script.php</span><span style="color:#800000">"</span><span style="color:#000000">,<br>  type: </span><span style="color:#800000">"</span><span style="color:#800000">POST</span><span style="color:#800000">"</span><span style="color:#000000">,<br>  data: {id : menuId},<br>  dataType: </span><span style="color:#800000">"</span><span style="color:#800000">html</span><span style="color:#800000">"</span><span style="color:#000000"><br>});<br><br></span><span style="color:#008000">//</span><span style="color:#008000">调用成功时的回调处理</span><br><span style="color:#000000">request.done(function(msg) {<br>  $(</span><span style="color:#800000">"</span><span style="color:#800000">#log</span><span style="color:#800000">"</span><span style="color:#000000">).html( msg );<br>});<br><br></span><span style="color:#008000">//</span><span style="color:#008000">调用失败时的回调处理</span><br><span style="color:#000000">request.fail(function(jqXHR, textStatus) {<br>  alert( </span><span style="color:#800000">"</span><span style="color:#800000">Request failed: </span><span style="color:#800000">"</span> +<span style="color:#000000"> textStatus );<br>});</span></pre><br></div><br><h1>配置对象</h1><br><p>如果一个函数（或方法）的参数只有一个参数，并且参数为对象字面量，我们则称这种模式为配置对象模式。例如，如下代码：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">var</span> conf =<span style="color:#000000"> {<br>    username:</span><span style="color:#800000">"</span><span style="color:#800000">shichuan</span><span style="color:#800000">"</span><span style="color:#000000">,<br>    first:</span><span style="color:#800000">"</span><span style="color:#800000">Chuan</span><span style="color:#800000">"</span><span style="color:#000000">,<br>    last:</span><span style="color:#800000">"</span><span style="color:#800000">Shi</span><span style="color:#800000">"</span><span style="color:#000000"><br>};<br>addPerson(conf);</span></pre><br></div><br><p>则在addPerson内部，就可以随意使用conf的值了，一般用于初始化工作，例如jquery里的ajaxSetup也就是这种方式来实现的：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#008000">//</span><span style="color:#008000"> 事先设置好初始值</span><br><span style="color:#000000">$.ajaxSetup({<br>   url: </span><span style="color:#800000">"</span><span style="color:#800000">/xmlhttp/</span><span style="color:#800000">"</span><span style="color:#000000">,<br>   </span><span style="color:#0000ff">global</span>: <span style="color:#0000ff">false</span><span style="color:#000000">,<br>   type: </span><span style="color:#800000">"</span><span style="color:#800000">POST</span><span style="color:#800000">"</span><span style="color:#000000"><br><br> });<br><br></span><span style="color:#008000">//</span><span style="color:#008000"> 然后再调用</span><br> $.ajax({ data: myData });</pre><br></div><br><p>另外，很多jquery的插件也有这种形式的传参，只不过也可以不传，不传的时候则就使用默认值了。</p><br><h1>返回函数</h1><br><p>返回函数，则是指在一个函数的返回值为另外一个函数，或者根据特定的条件灵活创建的新函数，示例代码如下：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">var</span> setup =<span style="color:#000000"><span style="color:#0000ff"> function</span> () {<br>    console.log(</span><span style="color:#800080">1</span><span style="color:#000000">);<br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> function () {<br>        console.log(</span><span style="color:#800080">2</span><span style="color:#000000">);<br>    };<br>};<br><br></span><span style="color:#008000">//</span><span style="color:#008000"> 调用setup 函数</span><br><span style="color:#0000ff">var</span> my = setup(); <span style="color:#008000">//</span><span style="color:#008000"> 输出 1</span><br>my(); <span style="color:#008000">//</span><span style="color:#008000"> 输出 2<br>// 或者直接调用也可<br>setup()();</span></pre><br></div><br><p>或者你可以利用闭包的特性，在setup函数里记录一个私有的计数器数字，通过每次调用来增加计数器，代码如下：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">var</span> setup =<span style="color:#000000"><span style="color:#0000ff"> function</span> () {<br>    </span><span style="color:#0000ff">var</span> count = <span style="color:#800080">0</span><span style="color:#000000">;<br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> function () {<br>        </span><span style="color:#0000ff">return</span> ++<span style="color:#000000">count;<br>    };<br>};<br><br></span><span style="color:#008000">//</span><span style="color:#008000"> 用法</span><br><span style="color:#0000ff">var</span> next =<span style="color:#000000"> setup();<br>next(); </span><span style="color:#008000">//</span><span style="color:#008000"> 返回 1</span><br>next(); <span style="color:#008000">//</span><span style="color:#008000"> 返回 2</span><br>next(); <span style="color:#008000">//</span><span style="color:#008000"> 返回 3</span></pre><br></div><br><h1>偏应用</h1><br><p>这里的偏应用，其实是将参数的传入工作分开进行，在有的时候一系列的操作可能会有某一个或几个参数始终完全一样，那么我们就可以先定义一个偏函数，然后再去执行这个函数（执行时传入剩余的不同参数）。</p><br><p>举个例子，代码如下：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">var</span> partialAny =<span style="color:#000000"> (function (aps) {<br><br>    </span><span style="color:#008000">//</span><span style="color:#008000"> 该函数是你们自执行函数表达式的结果，并且赋值给了partialAny变量</span><br><span style="color:#000000"><span style="color:#0000ff">    function</span> func(fn) {<br>        </span><span style="color:#0000ff">var</span> argsOrig = aps.call(arguments, <span style="color:#800080">1</span><span style="color:#000000">);<br>        </span><span style="color:#0000ff">return</span><span style="color:#000000"><span style="color:#0000ff"> function</span> () {<br>            </span><span style="color:#0000ff">var</span> args =<span style="color:#000000"> [],<br>                argsPartial </span>=<span style="color:#000000"> aps.call(arguments),<br>                i </span>= <span style="color:#800080">0</span><span style="color:#000000">;<br><br>            </span><span style="color:#008000">//</span><span style="color:#008000"> 变量所有的原始参数集，<br>            </span><span style="color:#008000">//</span><span style="color:#008000"> 如果参数是partialAny.<em> 占位符，则使用下一个函数参数对应的值<br>            </span><span style="color:#008000">//</span><span style="color:#008000"> 否则使用原始参数里的值</span><br>            <span style="color:#0000ff">for</span> (; i &lt; argsOrig.length; i++<span style="color:#000000">) {<br>                args[i] </span>= argsOrig[i] ===<span style="color:#000000"> func.</em><br>                            </span>?<span style="color:#000000"> argsPartial.shift()<br>                            : argsOrig[i];<br>            }<br><br>            </span><span style="color:#008000">//</span><span style="color:#008000"> 如果有任何多余的参数，则添加到尾部</span><br>            <span style="color:#0000ff">return</span> fn.apply(<span style="color:#0000ff">this</span><span style="color:#000000">, args.concat(argsPartial));<br>        };<br>    }<br><br>    </span><span style="color:#008000">//</span><span style="color:#008000"> 用于占位符设置</span><br>    func.<em> =<span style="color:#000000"> {};<br><br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> func;<br>})(Array.prototype.slice);</span></pre><br></div><br><p>使用方式如下：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#008000">//</span><span style="color:#008000"> 定义处理函数</span><br><span style="color:#000000">function hex(r, g, b) {<br>    </span><span style="color:#0000ff">return</span> <span style="color:#800000">'</span><span style="color:#800000">#</span><span style="color:#800000">'</span> + r + g +<span style="color:#000000"> b;<br>}<br><br></span><span style="color:#008000">//</span><span style="color:#008000">定义偏函数, 将hex的第一个参数r作为不变的参数值ff</span><br><span style="color:#0000ff">var</span> redMax = partialAny(hex, <span style="color:#800000">'</span><span style="color:#800000">ff</span><span style="color:#800000">'</span><span style="color:#000000">, partialAny.</em>, partialAny.<em>);<br><br></span><span style="color:#008000">//</span><span style="color:#008000"> 新函数redMax的调用方式如下，只需要传入2个参数了：</span><br>console.log(redMax(<span style="color:#800000">'</span><span style="color:#800000">11</span><span style="color:#800000">'</span>, <span style="color:#800000">'</span><span style="color:#800000">22</span><span style="color:#800000">'</span>)); <span style="color:#008000">//</span><span style="color:#008000"> "#ff1122"</span></pre><br></div><br><p>如果觉得partialAny.</em>太长，可以用<strong>代替哦。</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">var</span> </strong> =<span style="color:#000000"> partialAny._;<br><br></span><span style="color:#0000ff">var</span> greenMax = partialAny(hex, <strong>, 'ff'<span style="color:#000000">);<br>console.log(greenMax(</span>'33', '44'<span style="color:#000000">));<br><br></span><span style="color:#0000ff">var</span> blueMax = partialAny(hex, </strong>, <strong>, 'ff'<span style="color:#000000">);<br>console.log(blueMax(</span>'55', '66'<span style="color:#000000">));<br><br></span><span style="color:#0000ff">var</span> magentaMax = partialAny(hex, 'ff', </strong>, 'ff'<span style="color:#000000">);<br>console.log(magentaMax(</span>'77')); </pre><br></div><br><p>这样使用，就简洁多了吧。</p><br><h1>Currying</h1><br><p>Currying是函数式编程的一个特性，将多个参数的处理转化成单个参数的处理，类似链式调用。</p><br><p>举一个简单的add函数的例子：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">function</span><span style="color:#000000"> add(x, y) {<br>    </span><span style="color:#0000ff">var</span> oldx = x, oldy =<span style="color:#000000"> y;<br>    </span><span style="color:#0000ff">if</span> (<span style="color:#0000ff">typeof</span> oldy === "undefined") { <span style="color:#008000">//</span><span style="color:#008000"> partial</span><br>        <span style="color:#0000ff">return</span> <span style="color:#0000ff">function</span><span style="color:#000000"> (newy) {<br>            </span><span style="color:#0000ff">return</span> oldx +<span style="color:#000000"> newy;<br>        }<br>    }<br>    </span><span style="color:#0000ff">return</span> x +<span style="color:#000000"> y;<br>}</span></pre><br></div><br><p>这样调用方式就可以有多种了，比如：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#008000">//</span><span style="color:#008000"> 测试</span><br><span style="color:#0000ff">typeof</span> add(5); <span style="color:#008000">//</span><span style="color:#008000"> "function"</span><br>add(3)(4); <span style="color:#008000">//</span><span style="color:#008000"> 7</span><br><br><span style="color:#008000">//</span><span style="color:#008000"> 也可以这样调用</span><br><span style="color:#0000ff">var</span> add2000 = add(2000<span style="color:#000000">);<br>add2000(</span>10); <span style="color:#008000">//</span><span style="color:#008000"> 2010</span></pre><br></div><br><p>接下来，我们来定义一个比较通用的currying函数：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#008000">//</span><span style="color:#008000"> 第一个参数为要应用的function，第二个参数是需要传入的最少参数个数</span><br><span style="color:#0000ff">function</span><span style="color:#000000"> curry(func, minArgs) {<br>    </span><span style="color:#0000ff">if</span> (minArgs ==<span style="color:#000000"> undefined) {<br>        minArgs </span>= 1<span style="color:#000000">;<br>    }<br><br>    </span><span style="color:#0000ff">function</span><span style="color:#000000"> funcWithArgsFrozen(frozenargs) {<br>        </span><span style="color:#0000ff">return</span> <span style="color:#0000ff">function</span><span style="color:#000000"> () {<br>            </span><span style="color:#008000">//</span><span style="color:#008000"> 优化处理，如果调用时没有参数，返回该函数本身</span><br>            <span style="color:#0000ff">var</span> args =<span style="color:#000000"> Array.prototype.slice.call(arguments);<br>            </span><span style="color:#0000ff">var</span> newArgs =<span style="color:#000000"> frozenargs.concat(args);<br>            </span><span style="color:#0000ff">if</span> (newArgs.length &gt;=<span style="color:#000000"> minArgs) {<br>                </span><span style="color:#0000ff">return</span> func.apply(<span style="color:#0000ff">this</span><span style="color:#000000">, newArgs);<br>            } </span><span style="color:#0000ff">else</span><span style="color:#000000"> {<br>                </span><span style="color:#0000ff">return</span><span style="color:#000000"> funcWithArgsFrozen(newArgs);<br>            }<br>        };<br>    }<br><br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> funcWithArgsFrozen([]);<br>}</span></pre><br></div><br><p>这样，我们就可以随意定义我们的业务行为了，比如定义加法：</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">var</span> plus = curry(<span style="color:#0000ff">function</span><span style="color:#000000"> () {<br>    </span><span style="color:#0000ff">var</span> result = 0<span style="color:#000000">;<br>    </span><span style="color:#0000ff">for</span> (<span style="color:#0000ff">var</span> i = 0; i &lt; arguments.length; ++<span style="color:#000000">i) {<br>        result </span>+=<span style="color:#000000"> arguments[i];<br>    }<br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> result;<br>}, </span>2);</pre><br></div><br><p>使用方式，真实多种多样哇。</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre>plus(3, 2) <span style="color:#008000">//</span><span style="color:#008000"> 正常调用</span><br>plus(3) <span style="color:#008000">//</span><span style="color:#008000"> 偏应用，返回一个函数（返回值为3+参数值）</span><br>plus(3)(2) <span style="color:#008000">//</span><span style="color:#008000"> 完整应用（返回5）</span><br>plus()(3)()()(2) <span style="color:#008000">//</span><span style="color:#008000"> 返回 5</span><br>plus(3, 2, 4, 5) <span style="color:#008000">//</span><span style="color:#008000"> 可以接收多个参数</span><br>plus(3)(2, 3, 5) <span style="color:#008000">//</span><span style="color:#008000"> 同理</span></pre><br></div><br><p>如下是减法的例子</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">var</span> minus = curry(<span style="color:#0000ff">function</span><span style="color:#000000"> (x) {<br>    </span><span style="color:#0000ff">var</span> result =<span style="color:#000000"> x;<br>    </span><span style="color:#0000ff">for</span> (<span style="color:#0000ff">var</span> i = 1; i &lt; arguments.length; ++<span style="color:#000000">i) {<br>        result </span>-=<span style="color:#000000"> arguments[i];<br>    }<br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> result;<br>}, </span>2);</pre><br></div><br><p>或者如果你想交换参数的顺序，你可以这样定义</p><br><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><br><pre><span style="color:#0000ff">var</span> flip = curry(<span style="color:#0000ff">function</span><span style="color:#000000"> (func) {<br>    </span><span style="color:#0000ff">return</span> curry(<span style="color:#0000ff">function</span><span style="color:#000000"> (a, b) {<br>        </span><span style="color:#0000ff">return</span><span style="color:#000000"> func(b, a);<br>    }, </span>2<span style="color:#000000">);<br>});</span></pre><br></div><br><p>更多资料，可以参考如下地址：</p><br><p><a href="http://www.cnblogs.com/rubylouvre/archive/2009/11/09/1598761.html">http://www.cnblogs.com/rubylouvre/archive/2009/11/09/1598761.html</a></p><br><p><a href="http://www.cnblogs.com/sanshi/archive/2009/02/17/javascript_currying.html">http://www.cnblogs.com/sanshi/archive/2009/02/17/javascript_currying.html</a></p><br><h1>总结</h1><br><p>JavaScript里的Function有很多特殊的功效，可以利用闭包以及arguments参数特性实现很多不同的技巧，下一篇我们将继续介绍利用Function进行初始化的技巧。</p><br><p>参考地址：http://shichuan.github.com/javascript-patterns/#function-patterns</p><br><h1>同步与推荐</h1><br><p>本文已同步至目录索引：<span style="font-size:14pt"><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html">深入理解JavaScript系列</a></span></p><br><p>深入理解JavaScript系列文章，包括了原创，翻译，转载等各类型的文章，如果对你有用，请推荐支持一把，给大叔写作的动力。</p><img src="http://www.cnblogs.com/TomXu/aggbug/2580701.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/TomXu/archive/2012/07/23/2580701.html">本文链接</a></p></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
