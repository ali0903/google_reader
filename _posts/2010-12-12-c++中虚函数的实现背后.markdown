---
layout: post
title:  "c++中虚函数的实现背后"
date:   2010-12-12 18:50:00
author: Repository
categories: program
---

## c++中虚函数的实现背后
### by Repository
### at 2010-12-12 18:50:00
### original <http://www.cnblogs.com/repository/archive/2010/12/12/1903843.html>

<p><p>　　虚函数是很多编程语言中一个特性，比如c#,java，当然在c++语言中也有。这三种语言都是面向对象的语言。我们都知道面向对象语言有三个最基本的特征就是：继承，多态，封装。在c++语言中，这种多态的特征就是通过虚函数（virtual）来实现的。这种实现方法在其它语言中(比如c#)中也是如此。</p><p> 　　我要说的就是虚函数到底是怎么实现的。还是以例子来说明。我引用了上一篇随笔中的代码。</p><p> </p><div><div><span style="color:#0000ff">class</span><span style="color:#000000"> ClassA<br>{<br></span><span style="color:#0000ff">public</span><span style="color:#000000">:<br>    </span><span style="color:#0000ff">void</span><span style="color:#000000"> fun1();<br>    </span><span style="color:#0000ff">void</span><span style="color:#000000"> fun2();<br>    </span><span style="color:#0000ff">virtual</span><span style="color:#000000"> </span><span style="color:#0000ff">void</span><span style="color:#000000"> fun3();<br>};<br><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> ClassA::fun1()<br>{<br>    cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> </span><span style="color:#800000">"</span><span style="color:#800000">ClassA.fun1</span><span style="color:#800000">"</span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000">endl;<br>};<br><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> ClassA::fun2()<br>{<br>    cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> </span><span style="color:#800000">"</span><span style="color:#800000">ClassA.fun2</span><span style="color:#800000">"</span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000">endl;<br>};<br><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> ClassA::fun3()<br>{<br>    cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> </span><span style="color:#800000">"</span><span style="color:#800000">ClassA.fun3</span><span style="color:#800000">"</span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000">endl;<br>};<br><br><br></span><span style="color:#0000ff">class</span><span style="color:#000000"> ClassB : </span><span style="color:#0000ff">public</span><span style="color:#000000"> ClassA<br>{<br></span><span style="color:#0000ff">public</span><span style="color:#000000">:<br>    </span><span style="color:#0000ff">void</span><span style="color:#000000"> fun1();<br>    </span><span style="color:#0000ff">void</span><span style="color:#000000"> fun2();<br>    </span><span style="color:#0000ff">virtual</span><span style="color:#000000"> </span><span style="color:#0000ff">void</span><span style="color:#000000"> fun3();<br>};<br><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> ClassB::fun3()<br>{<br>    cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> </span><span style="color:#800000">"</span><span style="color:#800000">ClassB.fun3</span><span style="color:#800000">"</span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000">endl;<br>};<br><br></span><span style="color:#0000ff">class</span><span style="color:#000000"> ClassC : </span><span style="color:#0000ff">public</span><span style="color:#000000"> ClassB<br>{<br></span><span style="color:#0000ff">public</span><span style="color:#000000">:<br>    </span><span style="color:#0000ff">void</span><span style="color:#000000"> fun1();<br>    </span><span style="color:#0000ff">void</span><span style="color:#000000"> fun2();<br>    </span><span style="color:#0000ff">virtual</span><span style="color:#000000"> </span><span style="color:#0000ff">void</span><span style="color:#000000"> fun3();<br>};<br><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> ClassC::fun3()<br>{<br>    cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> </span><span style="color:#800000">"</span><span style="color:#800000">ClassC.fun3</span><span style="color:#800000">"</span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000">endl;<br>};<br><br></span><span style="color:#0000ff">void</span><span style="color:#000000"> main()<br>{<br>    ClassA </span><span style="color:#000000">*</span><span style="color:#000000">a[</span><span style="color:#800080">3</span><span style="color:#000000">];<br>    ClassA a1;<br>    ClassB b1;<br>    ClassC c1;<br><br><br>    a1.fun3();<br>    b1.fun3();<br>    c1.fun3();<br><br>    a[</span><span style="color:#800080">0</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#000000">&amp;</span><span style="color:#000000">a1;<br>    a[</span><span style="color:#800080">1</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#000000">&amp;</span><span style="color:#000000">b1;<br>    a[</span><span style="color:#800080">2</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#000000">&amp;</span><span style="color:#000000">c1;<br>    cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> </span><span style="color:#800000">"</span><span style="color:#800000">virtual function array test</span><span style="color:#800000">"</span><span style="color:#000000"> </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000">endl;<br>    </span><span style="color:#0000ff">for</span><span style="color:#000000">(</span><span style="color:#0000ff">int</span><span style="color:#000000"> i</span><span style="color:#000000">=</span><span style="color:#800080">0</span><span style="color:#000000">;i</span><span style="color:#000000">&lt;</span><span style="color:#800080">3</span><span style="color:#000000">;i</span><span style="color:#000000">++</span><span style="color:#000000">)<br>    {<br>        a[i]</span><span style="color:#000000">-&gt;</span><span style="color:#000000">fun3();<br>    }<br><br>    cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> </span><span style="color:#800000">"</span><span style="color:#800000">((ClassA)&amp;b1).fun3():</span><span style="color:#800000">"</span><span style="color:#000000">;<br>    ((ClassA</span><span style="color:#000000">*</span><span style="color:#000000">)</span><span style="color:#000000">&amp;</span><span style="color:#000000">b1)</span><span style="color:#000000">-&gt;</span><span style="color:#000000">fun3();<br>    </span><span style="color:#008000">//</span><span style="color:#008000">object slicing</span><span style="color:#008000"><br></span><span style="color:#000000">    cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> </span><span style="color:#800000">"</span><span style="color:#800000">object slicing</span><span style="color:#800000">"</span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000">endl;<br>    cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#800000">"</span><span style="color:#800000">((ClassA)b1).fun3():</span><span style="color:#800000">"</span><span style="color:#000000">; <br>    ((ClassA)b1).fun3();<br>}</span></div></div><p>　　类继承结构图如下：<br></p><p> <img alt="" src="http://images.cnblogs.com/cnblogs_com/repository/classdiagram.png" width="171" height="436"></p><p>　　其中fun3是虚拟函数，对ClassB,ClassC子类中分别进行了重写。</p><p> 　　下面我解释一下虚函数的背后是怎么实现的：<br></p><p>　　我们都知道，虚函数可以做到动态绑定，为了实现动态绑定，编译器是通过一个表格（虚拟函数表），在运行时间接的调用实际上绑定的函数来达到动态绑定，其中这个我刚所说的表格其实现就是一个“虚拟函数表”。这张表对我们程序来说是透明的。是编译器为我们的代码自动加上去的（更准确的讲，并不是为所有的代码都添加一张虚拟函数表，而是只针对那些包括虚函数的代码才加上这张表的）。 <br></p><p>　　既然有了这么一张虚拟函数表，自然而然我们就会想到，这个虚拟函数表里到底是存放一些什么东西呢？很简单，即然叫做虚拟函数表，当然是存放虚拟函数了，呵呵，在c++中，该表每一行的元素应该就是我们代码中虚拟函数地址了，也就是一个指针。有了这个地址，我们可以调用实际代码中的虚拟函数了。</p><p>　　编译器既然为我们的代码加了一张虚拟函数表，那这张虚拟函数表怎么与我们的代码关联起来呢？ 要实现动态绑定，我们应该利用这张虚拟函数表来调用虚拟函数，为了达到目的，编译器又会为我们的代码增加一个成员变量，这个成员变量就是一个指向该虚拟函数表的指针，该成员变量通常被命名为：vptr。<br></p><p>　　</p><p>　　说到了这里，上面代码中的ClassA中的在内存中应该如下图所示： <br></p><p> </p><p> <img alt="" src="http://images.cnblogs.com/cnblogs_com/repository/memory.png" width="532" height="292"></p><p> </p><div> 每一个ClassA的实例，都会有一个虚拟函数表vptr，当我们在代码中通过这个实例来调用虚拟函数时，都是通过vptr先找到虚拟函数表，接着在虚拟函数表中再找出指向的某个真正的虚拟函数地址。虚拟函数表中的内容就是类中按顺序声明的虚拟函数组织起来的。在派生的时候，子类都会继承父类的虚拟函数表vptr，我们只在把这个vptr成员在继承体系中一般看待就成了。<p>　　有一点要说明一下，当子类在改写了父类中的虚拟函数时，同时子类的vptr成员也会作修改，此时，子类的vptr成员指向的虚拟函数表中的存放的虚拟函数指针不再是父类的虚拟函数地址了，而是子类所改写父类的虚拟函数地址。理解这一点就很容易想到了：原来多态体现在这里！<br> </p><p>　　有了上面的说明，接下来ClassB,ClassC类的内存占据空间应该如下图所示：</p></div><p> </p><p> <img alt="" src="http://images.cnblogs.com/cnblogs_com/repository/classB.png" width="536" height="296"></p><p> 　　同理，ClassC也一样。（这些图画得真是丑啊！）</p><p>　　于是一个指向ClassA的对象的实例，调用 fun3就是ClassA::fun3()，一个指向ClassB的对象的实例，调用 fun3就是ClassB::fun3()，一个指向ClassC的对象的实例，调用 fun3就是ClassC::fun3()，这些调用通过都是通过虚拟函数表来进行的。</p><p>　　最后，上面代码中main函数的示例的执行结果也就是恍然大悟了，答案就在上一篇随笔的回复里面。已经有人帮我回复了，就此谢过了！ 欢迎大家一起探讨！<br></p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><img src="http://www.cnblogs.com/repository/aggbug/1903843.html?type=1" width="1" height="1" alt=""><p>作者: <a href="http://www.cnblogs.com/repository/">Repository</a> 发表于 2010-12-12 18:50 <a href="http://www.cnblogs.com/repository/archive/2010/12/12/1903843.html">原文链接</a></p><p>评论: 4　<a href="http://www.cnblogs.com/repository/archive/2010/12/12/1903843.html#pagedcomment">查看评论</a>　<a href="http://www.cnblogs.com/repository/archive/2010/12/12/1903843.html#commentform">发表评论</a></p><hr><p>最新新闻：<br>· <a href="http://news.cnblogs.com/n/84360/">你怎么理解 Facebook 的社交图景内涵？</a><span style="color:gray">(2010-12-12 18:41)</span><br>· <a href="http://news.cnblogs.com/n/84358/">麦当劳客户数据遭黑客窃取</a><span style="color:gray">(2010-12-12 15:45)</span><br>· <a href="http://news.cnblogs.com/n/84357/">Google Maps 5.0手机地图全3D界面演示</a><span style="color:gray">(2010-12-12 15:25)</span><br>· <a href="http://news.cnblogs.com/n/84356/">Twitter高管移动应用开发心得：需走出5大误区</a><span style="color:gray">(2010-12-12 15:17)</span><br>· <a href="http://news.cnblogs.com/n/84355/">雅虎员工否认展开新一轮裁员</a><span style="color:gray">(2010-12-12 15:12)</span><br></p><p>编辑推荐：<a href="http://www.cnblogs.com/wsky/archive/2010/12/11/1902969.html">Velocity China 2010大会回顾</a><br></p><p>网站导航：<a href="http://www.cnblogs.com">博客园首页</a>  <a href="http://home.cnblogs.com/">我的园子</a>  <a href="http://news.cnblogs.com">新闻</a>  <a href="http://home.cnblogs.com/ing/">闪存</a>  <a href="http://home.cnblogs.com/group/">小组</a>  <a href="http://space.cnblogs.com/q/">博问</a>  <a href="http://kb.cnblogs.com">知识库</a></p></p>