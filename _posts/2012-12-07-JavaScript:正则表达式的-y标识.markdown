---
layout: post
title:  "JavaScript:正则表达式的/y标识"
date:   2012-12-07 17:59:00
author: 紫云飞
categories: program
---

## JavaScript:正则表达式的/y标识
### by 紫云飞
### at 2012-12-07 17:59:00
### original <http://www.cnblogs.com/ziyunfei/archive/2012/12/07/2807313.html>

<p>本文要讲的是一个ES6特性——正则表达式对象的/y标志的作用.该特性同时也是一个ES4特性,所以Firefox3+都原生支持,其他浏览器目前还没有实现.</p><p>和/i对应于re.ingoreCase类似,/y标识对应的属性是re.sticky(实际上<a href="http://wiki.ecmascript.org/doku.php?id=discussion:extend_regexps#issues_with_y_flag">这个y来自于yylex</a>),sticky的意思是"粘滞".</p><p>和"全局匹配"类似,sticky属性为true的正则表达式对象(有/y标识)的匹配过程称之为"粘滞匹配"(反正我就这么叫了).</p><p>粘滞匹配会从两个方面影响正则表达式的匹配方式.如下:</p><p><strong>1.读取和设置lastIndex属性的值</strong></p><p>以防你不知道lastIndex的作用,首先给一个最简单的例子:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> re = /o/<span style="color:#000000">;<br></span><span style="color:#000000">print(re.lastIndex);     </span><span style="color:#008000">//</span><span style="color:#008000">0,lastIndex属性的初始值为0</span><span style="color:#000000"><br>print(re.test(</span><span style="color:#800000">"</span><span style="color:#800000">foo</span><span style="color:#800000">"</span>));   <span style="color:#008000">//</span><span style="color:#008000">true</span><br>print(re.test(<span style="color:#800000">"</span><span style="color:#800000">foo</span><span style="color:#800000">"</span>));   <span style="color:#008000">//</span><span style="color:#008000">true</span><br>print(re.test(<span style="color:#800000">"</span><span style="color:#800000">foo</span><span style="color:#800000">"</span>));   <span style="color:#008000">//</span><span style="color:#008000">true</span><br>print(re.lastIndex);     <span style="color:#008000">//</span><span style="color:#008000">0,</span><span style="color:#008000">lastIndex属性的值</span><span style="color:#008000">没有被更新<br></span>re.lastIndex = 10;       <span style="color:#008000">//</span><span style="color:#008000">手动修改</span><span style="color:#008000">lastIndex属性的值 <br></span>print(re.test(<span style="color:#800000">"</span><span style="color:#800000">foo</span><span style="color:#800000">"</span>));   <span style="color:#008000">//</span><span style="color:#008000">true,同样可以匹配</span><span style="color:#008000"><br></span>print(re.lastIndex);     <span style="color:#008000">//1</span><span style="color:#008000">0</span></div><p>这应该是最常见的情况,如果一个正则对象不是全局(global)的,则其lastIndex属性会被完全忽略(不会读取,也不会赋值).但如果:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> re = /o/<span style="color:#000000">g;           </span><span style="color:#008000">//全局匹配</span><span style="color:#008000"><br></span><span style="color:#000000">print(re.lastIndex);     </span><span style="color:#008000">//</span><span style="color:#008000">0,lastIndex属性的初始值为0</span><br>print(re.test("foo"));   <span style="color:#008000">//</span><span style="color:#008000">true,匹配了第二个字符</span><br>print(re.lastIndex);     <span style="color:#008000">//</span><span style="color:#008000">2,lastIndex属性的值被设置为2,也就是第二个字符之后</span><br>print(re.test("foo"));   <span style="color:#008000">//</span><span style="color:#008000">true,从第二个字符(lastIndex属性的值)之后开始匹配,匹配了第三个字符</span><br>print(re.lastIndex);     <span style="color:#008000">//</span><span style="color:#008000">3,lastIndex属性的值被设置为2,也就是字符串的末尾</span><br>print(re.test("foo"));   <span style="color:#008000">//</span><span style="color:#008000">false,已经没有字符了,匹配失败.</span><br>print(re.lastIndex);     <span style="color:#008000">//</span><span style="color:#008000">0,lastIndex属性的值被重置为0</span><br>print(re.test("foo"));   <span style="color:#008000">//</span><span style="color:#008000">true,又一次重新开始匹配</span><br>print(re.lastIndex);     <span style="color:#008000">//</span><span style="color:#008000">2,一直循环下去</span><br>re.lastIndex = 3;        <span style="color:#008000">//</span><span style="color:#008000">手动修改为3</span><br>print(re.test("foo"));   <span style="color:#008000">//</span><span style="color:#008000">false,从第三个字符后开始匹配,所以匹配失败</span></div><p>从上例中可以看出,全局匹配(/g)操作会读取还会更新lastIndex属性的值.类似于全局匹配,粘滞匹配(/y)也会让这样做.不过会有点区别,就是如果是全局匹配,在匹配失败后,lastIndex属性的值会被重置为0,但粘滞匹配不会.看下面的例子:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> re = /./<span style="color:#000000">y;           </span><span style="color:#008000">//</span><span style="color:#008000">粘滞匹配<br></span><span style="color:#000000">print(re.test(</span>"foo"));   <span style="color:#008000">//</span><span style="color:#008000">true</span><br>print(re.lastIndex);     <span style="color:#008000">//</span><span style="color:#008000">1</span><br>print(re.test("foo"));   <span style="color:#008000">//</span><span style="color:#008000">true</span><br>print(re.lastIndex);     <span style="color:#008000">//</span><span style="color:#008000">2</span><br>print(re.test("foo"));   <span style="color:#008000">//</span><span style="color:#008000">true</span><br>print(re.lastIndex);     <span style="color:#008000">//</span><span style="color:#008000">3</span><br>print(re.test("foo"));   <span style="color:#008000">//</span><span style="color:#008000">false</span><br>print(re.lastIndex);     <span style="color:#008000">//</span><span style="color:#008000">3,匹配失败后,lastIndex属性没有归零</span><br>print(re.test("foo"));   <span style="color:#008000">//</span><span style="color:#008000">false,所以匹配会一直失败下去</span><br>re.lastIndex = 0;        <span style="color:#008000">//</span><span style="color:#008000">同样可以手动修改</span><span style="color:#008000">lastIndex属性的值<br></span>print(re.test("foo"));   <span style="color:#008000">//</span><span style="color:#008000">true</span></div><p>只有全局匹配和粘滞匹配才会让引擎在匹配过程执行完毕后更新正则对象的lastIndex属性的值,我们可以从SpiderMonkey源码(jsregexp.cpp)中清晰的看到这一过程:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#008000">/*</span><span style="color:#008000"> Update lastIndex. </span><span style="color:#008000">*/</span><br><span style="color:#0000ff">if</span> (re-&gt;<span style="color:#0000ff">global</span>() || (!rval-&gt;isNull() &amp;&amp; re-&gt;sticky())) {    <span style="color:#008000">//</span><span style="color:#008000">如果是全局匹配或者(粘滞匹配且匹配成功时),才会进入下面的语句块</span><br>    <span style="color:#0000ff">if</span> (rval-&gt;isNull())                                     <span style="color:#008000">//</span><span style="color:#008000">如果匹配失败,也就是全局匹配的匹配失败</span><br>        obj-&gt;zeroRegExpLastIndex();                         <span style="color:#008000">//</span><span style="color:#008000">则把lastIndex属性的值归零</span><br>    <span style="color:#0000ff">else</span>                                                    <span style="color:#008000">//</span><span style="color:#008000">否则,也就是全局匹配或者粘滞匹配匹配成功的情况</span><br>        obj-&gt;setRegExpLastIndex(lastIndexInt);              <span style="color:#008000">//</span><span style="color:#008000">则把lastIndexInt属性的值设置为成功匹配的子字符串</span><span style="color:#008000">在原字符串中</span><span style="color:#008000">的偏移量</span><br>}</div><p><strong>2."粘滞"的真正意义</strong></p><p>看了第一节的介绍,你会发现我只提到了全局匹配和粘滞匹配的一个区别,就是在匹配失败后要不要将lastIndex属性的值重置为0.只有这些吗?当然不是.这根本没有体现出"粘滞"到底是什么意思.</p><p>我只用一个超简单的例子就能演示出"粘滞"到底表现为什么:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">/o/.test("foo")     <span style="color:#008000">//</span><span style="color:#008000">true</span><br>/o/y.test("foo")    <span style="color:#008000">//</span><span style="color:#008000">false</span></div><p>这个表现你能想通吗?我用文字表述一下就是:粘滞匹配不能像普通正则那样,跳过那些匹配失败的字符后接着执行后面字符的匹配操作.在本例中就是,/o/在匹配字符f失败之后,就完全失败了,不会接着匹配f后面的o.为什么会这样?我们还得和全局匹配比较一下:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> re = /^./<span style="color:#000000">g;<br>print(re.test(</span>"foo"));   <span style="color:#008000">//</span><span style="color:#008000">true</span><br>print(re.lastIndex);     <span style="color:#008000">//</span><span style="color:#008000">1</span><br>print(re.test("foo"));   <span style="color:#008000">//</span><span style="color:#008000">false</span><br>print(re.lastIndex);     <span style="color:#008000">//</span><span style="color:#008000">0</span></div><p>这个例子应该好懂,因为有^锚点(匹配字符串的开头位置),所以第二次的匹配会失败.然而:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> re = /^./<span style="color:#000000">y;<br>print(re.test(</span>"foo"));   <span style="color:#008000">//</span><span style="color:#008000">true</span><br>print(re.lastIndex);     <span style="color:#008000">//</span><span style="color:#008000">1</span><br>print(re.test("foo"));   <span style="color:#008000">//</span><span style="color:#008000">true</span><br>print(re.lastIndex);     <span style="color:#008000">//</span><span style="color:#008000">2</span></div><p>结论就是:全局匹配和粘滞匹配都会从字符串中由正则对象的lastIndex属性的值指定的偏移位置处开始匹配,但区别是:粘滞匹配中,^元字符的意义变了,它代表的不是整个字符串的开头位置,而代表的就是这个偏移位置.所以上面的两次匹配都能成功.同时,每个粘滞正则中不管第一个字符是不是^元字符,都会被隐式的加上^.回到刚才那个让然费解的例子就是:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">/o/y.test("foo") </div><p>就相当于</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">/^o/y.test("foo") </div><p>这下能看懂了吧.^f才能匹配,^o不行.</p><p>为了再次证明一下粘滞匹配中的^的位置会动态改变,看下面的例子:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> re = /o/y;           <span style="color:#008000">//</span><span style="color:#008000">相当于/^o/y</span><br>print(re.test("foo"));   <span style="color:#008000">//</span><span style="color:#008000">false</span><br>print(re.lastIndex);     <span style="color:#008000">//</span><span style="color:#008000">0</span><br>re.lastIndex = 1;        <span style="color:#008000">//</span><span style="color:#008000">手动跳过了第一个字符f,^现在匹配的位置就是f和o之间的位置,所以^o能匹配.</span><br>print(re.test("foo"));   <span style="color:#008000">//</span><span style="color:#008000">true</span><br>print(re.lastIndex);     <span style="color:#008000">//</span><span style="color:#008000">2,^现在匹配的位置就是o和o之间的位置,所以^o能匹配.</span><br>print(re.test("foo"));   <span style="color:#008000">//</span><span style="color:#008000">true</span><br>print(re.lastIndex);     <span style="color:#008000">//</span><span style="color:#008000">3</span><br>print(re.test("foo"));   <span style="color:#008000">//</span><span style="color:#008000">false</span><br>print(re.lastIndex);     <span style="color:#008000">//</span><span style="color:#008000">3</span></div><p>现在懂了吧,粘滞的意思就是"使用隐式的^锚点把正则锚定在了lastIndex所指定的偏移位置处".</p><p><strong>总结</strong></p><p>网上几乎没有讲正则的/y标识的帖子或文章,Brendan Eich说的<a href="https://mail.mozilla.org/pipermail/es-discuss/2007-December/005191.html">一段话</a>给了我很大帮助来理解这个东西.</p><blockquote>/y标识让一个未锚定的正则只在目标字符串的当前位置匹配成功或匹配失败./g或其他东西也会影响当前位置具体在哪里.但比起其他因素,/y是完全独立的(更底层).</blockquote><p>本文中我只使用了正则的test方法来讲解/y标识,你应该再用其他正则相关的方法试验一下:RegExp.prototype.exec,String.prototype.search,String.prototype.split,String.prototype.match,String.prototype.replace.以及gy标识同时存在的情况等.</p><p>另外,其他语言比如Perl(正则表达式最强大最灵活的语言)中,怎么没有这个标识呢?答案是:人家有\G元字符,\G是个零宽断言,表示的是上次成功匹配时的偏移位置.</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">my</span> <span style="color:#800080">$str</span> = <span style="color:#000000;font-weight:bold">"</span><span style="color:#000000;font-weight:bold">foo</span><span style="color:#000000;font-weight:bold">"</span><span style="color:#000000">;<br></span><span style="color:#0000ff">pos</span>(<span style="color:#800080">$str</span>) = <span style="color:#800000">0</span>;               <span style="color:#008000">#</span><span style="color:#008000">相当于设置lastIndex为0</span><br><span style="color:#0000ff">while</span> (<span style="color:#800080">$str</span> =~ /(\Go)/g) {   <span style="color:#008000">#</span><span style="color:#008000">匹配失败,不会进入这个循环</span><br>    <span style="color:#0000ff">print</span> $<span style="color:#800000">1</span><span style="color:#000000">;<br>}<br></span><span style="color:#0000ff">pos</span>(<span style="color:#800080">$str</span>) = <span style="color:#800000">1</span>;               <span style="color:#008000">#</span><span style="color:#008000">相当于设置lastIndex为1,跳过字符f</span><br><span style="color:#0000ff">while</span>(<span style="color:#800080">$str</span> =~ /(\Go)/g) {    <span style="color:#008000">#</span><span style="color:#008000">匹配成功,进入循环</span><br>    <span style="color:#0000ff">print</span> $<span style="color:#800000">1</span>;                <span style="color:#008000">#</span><span style="color:#008000">输出两次o</span><br>    <span style="color:#0000ff">print</span> <span style="color:#0000ff">pos</span>(<span style="color:#800080">$str</span>)          <span style="color:#008000">#</span><span style="color:#008000">第一次输出2,第二次输出3</span><br>}</div><p>还有,比起其他语言中的正则,JavaScript中的正则其实是"弱爆了",如果这都学不会,呵呵...</p><p>对我来说,没有正则几乎相当于没有Google.</p><img src="http://www.cnblogs.com/ziyunfei/aggbug/2807313.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/ziyunfei/archive/2012/12/07/2807313.html">本文链接</a></p>