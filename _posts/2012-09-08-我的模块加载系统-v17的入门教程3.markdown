---
layout: post
title:  "我的模块加载系统 v17的入门教程3"
date:   2012-09-08 16:58:00
author: 司徒正美
categories: program
---

## 我的模块加载系统 v17的入门教程3
### by 司徒正美
### at 2012-09-08 16:58:00
### original <http://www.cnblogs.com/rubylouvre/archive/2012/09/08/2676728.html>

<p>本节将介绍如何支持“<a href="http://blog.millermedeiros.com/amd-is-better-for-the-web-than-commonjs-modules/">simplified CommonJS wrapper</a>”模块，node.js的<a href="https://github.com/joyent/node/blob/master/lib/module.js">SJS模块</a>实质在内部包一层构成一个SCW模块，而seajs提倡的 CMD 也源自于它。</p><br>//http://blog.millermedeiros.com/amd-is-better-for-the-web-than-commonjs-modules/<br>//一个遵循SCW规范的模块，SCW是CommonJS关于模块定义的一个子规范<br>define(function(require, exports, module){<br>    var myLib = require('myPackage/myLib');<br>    function foo(){<br>        console.log('foo');<br>        myLib.doSomething();<br>    }<br>    //expose module API<br>    exports.foo = foo;<br><br>});<br><br><p>我们也可以顺带看一下老外正在搞到的es6中有关模块的部分：</p><br>//http://calculist.org/blog/2012/03/29/synchronous-module-loading-in-es6/<br><br>import $ from "jquery.js";<br>$('myelement').style({ 'background-color': 'yellow' })<br><br><br>// http://wiki.ecmascript.org/doku.php?id=harmony:private_name_objects <br>import Name from "@name";<br>var key = new Name();<br>...<br>Proxy.create({<br>    ...<br>    get: function(receiver, name) {<br>        if (name === key.public)<br>            ...<br>        else<br>            ...<br>    },<br>    ...<br>});<br><br><p>它们通过引入新的关键字方式来处理，这不是个好主意，估计以后像访问器一下，加到Object或某个对象上成为一个方法进行调用。</p><p>如果浏览器真的支持它们，我们可以通过特征侦测，然后整到我的加载器内部就行了，保证全平台前后兼容！</p><p>好了，我们回归正题，怎么通过mass.js实现SCW规范的模块加载，之前两节是前端社区提供的AMD规范，而SCW规范则是兼容node.js的重要手段。</p><p>建立一个index.html，内容如下：</p><br>&lt;!DOCTYPE HTML&gt;<br>&lt;html&gt;<br>    &lt;head&gt;<br>        &lt;title&gt;SAW规范的模块加载例子 by 司徒正美&lt;/title&gt;<br>        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;<br>        &lt;style&gt;<br>            html,body{<br>                height:100%;<br>            }<br>        &lt;/style&gt;<br>        &lt;script src=&quot;mass.js&quot;&gt;<br><br>        &lt;/script&gt;<br>        &lt;script&gt;<br>            //加载当前目录下的more目录的aaa.js<br>            $.require("./more/aaa", function(a){<br>                $.log(a)<br>            })<br><br>        &lt;/script&gt;<br>    &lt;/head&gt;<br>    &lt;body&gt;<br>        &lt;h1&gt;SAW规范的模块加载例子 by 司徒正美&lt;/h1&gt;<br>    &lt;/body&gt;<br>&lt;/html&gt;<br><p>mass.js应该与此html文件在同一目录下，然后在此目录下建more目录，然后再建aaa.js文件，内容如下：</p><br>define(function(require,exports,module){<br>    var b = require("./bbb").bbb;<br>    $.log(b);<br>    $.log(exports);<br>    $.log(module)<br>    return "aaa"<br>})<br><p>我们可以看到依赖模块的加载放到模块工厂内部了，这意味着在前端如何要实现这语法只能提前把这个函数的源码全部分析一遍，用正则把require语句抽取出来，也意味着它无法做到按需加载，所有if分支都无法阻挡正则的解析。</p><p>再建一个bbb.js，它与aaa.js是在同一目录下</p><br>define(function(){<br>    var c = require("./more/ccc").ccc;<br>    $.log("已加载bbb模块")<br>    $.log(c)<br>    exports.bbb = "bbb"<br>})<br><p>我们会看到它bbb.js依赖于ccc.js，我们要记住一点，依赖模块总是根据父模块的位置定位的。谁是引入者（或被依赖者），谁就是父模块。相反，依赖模块是被引入者的子模块，我们可以在module中得到它们的关系，里面有parent与children属性。bbb.js已经在more目录下了，ccc那个路径意味着它还要在此more目录下再建一个more目录，里面有个ccc.js文件。</p><br>define(function(){<br>   $.log("已加载ccc模块")<br>    exports.ccc = "ccc"<br>})<br><br><p>好了，我们用firefox打开index.html，在firebug看到以下输出：</p><div><img src="http://images.cnblogs.com/cnblogs_com/rubylouvre/205314/o_amd_7.jpg"></div><p>我们再在firebug中展开那个Object{xxxxxxx}什么的，可以看到module对象里面的内容：</p><div><img src="http://images.cnblogs.com/cnblogs_com/rubylouvre/205314/o_amd_8.jpg"></div><p>你们可以把module, exports, require为模块工厂内部的变量就行了，参数里面不写它们也完全OK，你总是能引用到它们的！</p><img src="http://www.cnblogs.com/rubylouvre/aggbug/2676728.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/rubylouvre/archive/2012/09/08/2676728.html">本文链接</a></p>