---
layout: post
title:  "你必须知道的【闭包】陷阱和案例"
date:   2012-02-27 07:39:00
author: 【当耐特砖家】
categories: program
---

## 你必须知道的【闭包】陷阱和案例
### by 【当耐特砖家】
### at 2012-02-27 07:39:00
### original <http://www.cnblogs.com/iamzhanglei/archive/2012/02/27/2368566.html>

<p><strong>闭包</strong></p>  <p>In some languages, a closure may occur when a function is defined within another function, and the inner function refers to local variables of the outer function. </p>  <p>At run-time, when the outer function executes, a closure is formed, consisting of the inner function’s code and references (the upvalues) to any variables of the outer function required by the closure.</p>  <p> </p>  <p>翻译：</p>  <p>在一些编程语言当中，闭包发生  ：在一个函数内部定义了另外一个函数，并且内部的函数引用了外部函数的本地变量。</p>  <p>在运行的时候，当外部函数执行，这个时候形成了一个闭包，由内部函数的代码和对外部函数任意变量引用组成，这写引用都依赖于此闭包。    <br></p>  <pre style="background-color:#fbfbfb;margin:0em;width:100%;font-family:consolas,&#39;Courier New&#39;,courier,monospace;font-size:16px"><span style="color:#008000">// ECMAScript </span><br><span style="color:#0000ff">var</span> f, g; <br><span style="color:#0000ff">function</span> foo() { <br>    <span style="color:#0000ff">var</span> x = 0; <br>    f = <span style="color:#0000ff">function</span> () { <span style="color:#0000ff">return</span> ++x; }; <br>    g = <span style="color:#0000ff">function</span> () { <span style="color:#0000ff">return</span> --x; }; <br>    x = 1; <br>    <span style="color:#0000ff">alert</span>('inside foo, call to f(): ' + f()); <span style="color:#008000">// &quot;2&quot; </span><br>} <br><span style="color:#008000">//外部函数执行，这个时候形成了闭包</span><br>foo(); <br><span style="color:#008000">//因为有了闭包，所以才访问到了 foo中的x </span><br><span style="color:#0000ff">alert</span>('call to g(): ' + g()); <span style="color:#008000">// &quot;1&quot; </span><br><span style="color:#008000">//因为有了闭包，所以才访问到了 foo中的x </span><br><span style="color:#0000ff">alert</span>('call to f(): ' + f()); <span style="color:#008000">// &quot;2&quot; </span></pre><p> </p><p> </p><p><strong>  <p>javascript闭包陷阱与案例</p></strong></p><p><strong>在很多时候，由于内部函数的变量覆盖了闭包的变量，我们如果需要引用外部函数同名的变量，需要通过执行匿名函数，不外部函数的变量作为参数传递进来。如下所示：</strong></p><pre style="background-color:#fbfbfb;margin:0em;width:100%;font-family:consolas,&#39;Courier New&#39;,courier,monospace;font-size:16px">（<span style="color:#0000ff">function</span>(out_xxx){<br><span style="color:#008000">//这里面就可以使用out_xxx</span><br> }(xxx)）</pre><p>可以看得出来，使用这种方式最多的地方是在我们定义对象的时候：</p><pre style="background-color:#fbfbfb;margin:0em;width:100%;font-family:consolas,&#39;Courier New&#39;,courier,monospace;font-size:16px">(<span style="color:#0000ff">function</span> (<span style="color:#0000ff">window</span>) {<br>    <span style="color:#0000ff">var</span> MyObject = <span style="color:#0000ff">function</span> () {<br>        <span style="color:#0000ff">this</span>.initialize();<br>    }<br>    <span style="color:#0000ff">var</span> p = MyObject.<span style="color:#0000ff">prototype</span>;<br>    p.initialize = <span style="color:#0000ff">function</span> () { <br>    <br>    }<br>    <span style="color:#0000ff">window</span>.MyObject = MyObject;<br>} (<span style="color:#0000ff">window</span>));</pre><p>这样定义对象有两个好处：</p><blockquote style="border:2px solid #efefef;color:#333333;padding:5px 10px">  <p>1.避免污染外部变量</p>  <p>2.传递参数的形式减少作用域查找</p></blockquote><p>javascript为我们埋了很多坑，在许多场景下，我们需要利用以上的形式去解决问题，下面依依列出。</p><p> </p><p><strong>场景1 :</strong></p><p>如下所示，我需要在cc方法中调用到外面的name：   <br></p><pre style="background-color:#fbfbfb;margin:0em;width:100%;font-family:consolas,&#39;Courier New&#39;,courier,monospace;font-size:16px">    <span style="color:#0000ff">var</span> bb, cc;<br>    <span style="color:#0000ff">function</span> aa() {<br>        <span style="color:#0000ff">var</span> <span style="color:#0000ff">name</span> = &quot;<span style="color:#8b0000">当耐特</span>&quot;;<br>        bb = <span style="color:#0000ff">function</span> () {<br>            <span style="color:#0000ff">var</span> <span style="color:#0000ff">name</span> = &quot;<span style="color:#8b0000">砖家</span>&quot;;<br>            cc = <span style="color:#0000ff">function</span> () {<br>                <span style="color:#0000ff">var</span> <span style="color:#0000ff">name</span> = &quot;<span style="color:#8b0000">张磊</span>&quot;;<br>                <span style="color:#0000ff">alert</span>(<span style="color:#0000ff">name</span>);<br>            }<br>        }<br>    }<br>        aa();<br>        bb();<br>        cc();<span style="color:#008000">//输出 “张磊”</span></pre>因为内部的函数定义的变量覆盖了外部函数的变量，所以结果输出“张磊”。 <br><p><strong>解决办法：</strong></p><pre style="background-color:#fbfbfb;margin:0em;width:100%;font-family:consolas,&#39;Courier New&#39;,courier,monospace;font-size:16px">    <span style="color:#0000ff">var</span> bb, cc;<br>    <span style="color:#0000ff">function</span> aa() {<br>        <span style="color:#0000ff">var</span> <span style="color:#0000ff">name</span> = &quot;<span style="color:#8b0000">当耐特</span>&quot;;<br>        (<span style="color:#0000ff">function</span> (aa_name) {<br>            bb = <span style="color:#0000ff">function</span> () {<br>                <span style="color:#0000ff">var</span> <span style="color:#0000ff">name</span> = &quot;<span style="color:#8b0000">砖家</span>&quot;;<br>                (<span style="color:#0000ff">function</span> (bb_name, aa_name) {<br>                    cc = <span style="color:#0000ff">function</span> () {<br>                        <span style="color:#0000ff">var</span> <span style="color:#0000ff">name</span> = &quot;<span style="color:#8b0000">张磊</span>&quot;;<br>                        <span style="color:#0000ff">alert</span>(aa_name);<br>                        <span style="color:#0000ff">alert</span>(bb_name);<br>                        <span style="color:#0000ff">alert</span>(<span style="color:#0000ff">name</span>);<br>                    }<br>                })(<span style="color:#0000ff">name</span>, aa_name);<br>            }<br>        })(<span style="color:#0000ff">name</span>);<br>    }<br>        aa();<br>        bb();<br>        cc();<span style="color:#008000">//输出“当耐特” “砖家”  “张磊”</span></pre><p> </p><p><strong>真实案例：</strong></p><p>记得上周，我的一个同事（实习生），对下面一段代码产生疑惑，所以咨询我。如下所示：</p><pre style="background-color:#fbfbfb;margin:0em;width:100%;font-family:consolas,&#39;Courier New&#39;,courier,monospace;font-size:16px">    $(&quot;<span style="color:#8b0000">#dialog-form</span>&quot;).dialog({<br>        autoOpen: <span style="color:#0000ff">false</span>,<br>        height: 300,<br>        width: 350,<br>        modal: <span style="color:#0000ff">true</span>,<br>        buttons: {<br>            &quot;<span style="color:#8b0000">Create an account</span>&quot;: <span style="color:#0000ff">function</span> () {<br>                <span style="color:#0000ff">var</span> bValid = <span style="color:#0000ff">true</span>;<br>                allFields.removeClass(&quot;<span style="color:#8b0000">ui-state-error</span>&quot;);<br>                bValid = bValid &amp;&amp; checkLength(<span style="color:#0000ff">name</span>, &quot;<span style="color:#8b0000">username</span>&quot;, 3, 16);<br>                bValid = bValid &amp;&amp; checkLength(email, &quot;<span style="color:#8b0000">email</span>&quot;, 6, 80);<br>                bValid = bValid &amp;&amp; checkLength(password, &quot;<span style="color:#8b0000">password</span>&quot;, 5, 16);<br>                <span style="color:#0000ff">if</span> (bValid) {<br>                    $.ajax({<br>                        type: &quot;<span style="color:#8b0000">POST</span>&quot;,<br>                        url: &quot;<span style="color:#8b0000">xxxxx.aspx</span>&quot;,<br>                        data: &quot;<span style="color:#8b0000">name=xxxxx&amp;email=xxxxx&amp;password=xxxx</span>&quot;<br>                    }).done(<span style="color:#0000ff">function</span> (msg) {<br>                        <span style="color:#0000ff">alert</span>(&quot;<span style="color:#8b0000">Data Saved: </span>&quot; + msg);<br>                        $(<span style="color:#0000ff">this</span>).dialog(&quot;<span style="color:#8b0000">close</span>&quot;);<br>                    });<br>                }<br>            },<br>            Cancel: <span style="color:#0000ff">function</span> () {<br>                $(<span style="color:#0000ff">this</span>).dialog(&quot;<span style="color:#8b0000">close</span>&quot;);<br>            }<br>        },<br>        <span style="color:#0000ff">close</span>: <span style="color:#0000ff">function</span> () {<br>            allFields.val(&quot;<span style="color:#8b0000"></span>&quot;).removeClass(&quot;<span style="color:#8b0000">ui-state-error</span>&quot;);<br>        }<br>    });</pre><p>这里用的是JqueryUI的dialog插件。详见： <a title=" http://jqueryui.com/demos/dialog/#modal-form" href="http://jqueryui.com/demos/dialog/#modal-form">http://jqueryui.com/demos/dialog/#modal-form</a>   </p><p><img style="background-image:none;border-right-width:0px;margin:0px auto;padding-left:0px;padding-right:0px;display:block;float:none;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;padding-top:0px" title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/iamzhanglei/201202/201202262020391513.png" width="357" height="311"></p><p> </p><p>他想要的效果是点击create发起一个异步提交，然后在回调的时候关闭弹出层。令他困惑的地方是，弹出层关闭不了。</p><p>他抱怨着说：</p><pre style="background-color:#fbfbfb;margin:0em;width:100%;font-family:consolas,&#39;Courier New&#39;,courier,monospace;font-size:16px">Cancel: <span style="color:#0000ff">function</span> () {<br>                $(<span style="color:#0000ff">this</span>).dialog(&quot;<span style="color:#8b0000">close</span>&quot;);<br>            }</pre><p>我的cancel都能关闭。为什么</p><pre style="background-color:#fbfbfb;margin:0em;width:100%;font-family:consolas,&#39;Courier New&#39;,courier,monospace;font-size:16px">                <span style="color:#0000ff">if</span> (bValid) {<br>                    $.ajax({<br>                        type: &quot;<span style="color:#8b0000">POST</span>&quot;,<br>                        url: &quot;<span style="color:#8b0000">xxxxx.aspx</span>&quot;,<br>                        data: &quot;<span style="color:#8b0000">name=xxxxx&amp;email=xxxxx&amp;password=xxxx</span>&quot;<br>                    }).done(<span style="color:#0000ff">function</span> (msg) {<br>                        <span style="color:#0000ff">alert</span>(&quot;<span style="color:#8b0000">Data Saved: </span>&quot; + msg);<br>                        $(<span style="color:#0000ff">this</span>).dialog(&quot;<span style="color:#8b0000">close</span>&quot;);<br>                    });<br>                }</pre><p>这里面的$(this).dialog(&quot;close&quot;)为什么就不能关闭？   <br>这是一个很典型的场景，解决办法：</p><pre style="background-color:#fbfbfb;margin:0em;width:100%;font-family:consolas,&#39;Courier New&#39;,courier,monospace;font-size:16px">                <span style="color:#0000ff">if</span> (bValid) {<br>                    (<span style="color:#0000ff">function</span> (outThis) {<br>                        $.ajax({<br>                            type: &quot;<span style="color:#8b0000">POST</span>&quot;,<br>                            url: &quot;<span style="color:#8b0000">xxxxx.aspx</span>&quot;,<br>                            data: &quot;<span style="color:#8b0000">name=xxxxx&amp;email=xxxxx&amp;password=xxxx</span>&quot;<br>                        }).done(<span style="color:#0000ff">function</span> (msg) {<br>                            <span style="color:#0000ff">alert</span>(&quot;<span style="color:#8b0000">Data Saved: </span>&quot; + msg);<br>                            $(outThis).dialog(&quot;<span style="color:#8b0000">close</span>&quot;);<br>                        });<br>                    } <br>                }(<span style="color:#0000ff">this</span>))<br>            },</pre><p> </p><p>除了上面的解决方案，我们完全可以使用 </p><p>var _name=name;</p><p>var __name=name;</p><p>var _this =this; </p><p>然后内部函数使用新定义的变量就可以。然而，下面的几种场景却必须使用匿名函数。</p><p><strong>场景2---循环中的内部函数</strong></p><pre style="background-color:#fbfbfb;margin:0em;width:100%;font-family:consolas,&#39;Courier New&#39;,courier,monospace;font-size:16px">    <span style="color:#0000ff">function</span> TestObj(<span style="color:#0000ff">name</span>) {<br>        <span style="color:#0000ff">this</span>.<span style="color:#0000ff">name</span> = <span style="color:#0000ff">name</span>;<br>    }<br>    <span style="color:#0000ff">var</span> objs = [];<br>    <span style="color:#0000ff">var</span> obj;<br>    <span style="color:#0000ff">function</span> test() {<br>        <span style="color:#0000ff">for</span> (<span style="color:#0000ff">var</span> i = 0; i &lt; 100; i++) {<br>            <span style="color:#0000ff">var</span> <span style="color:#0000ff">name</span> = &quot;<span style="color:#8b0000">张磊</span>&quot; + i;<br>            obj = <span style="color:#0000ff">new</span> TestObj(<span style="color:#0000ff">name</span>);<br>            obj.printName = <span style="color:#0000ff">function</span> () {<br>                    console.log(obj.<span style="color:#0000ff">name</span>);<br>                }<br>            objs.push(obj);<br>        }<br>    }<br>    <span style="color:#008000">//外部函数执行，闭包形成。内部函数obj.printName中的obj全部指向最后一次new TestObj(name);</span><br>    test();<br>    <span style="color:#008000">//所以这里会输出100次-----&quot;张磊99&quot;</span><br>    <span style="color:#0000ff">for</span> (<span style="color:#0000ff">var</span> i <span style="color:#0000ff">in</span> objs) {<br>        objs[i].printName();<br>    }</pre><p>解决办法</p><pre style="background-color:#fbfbfb;margin:0em;width:100%;font-family:consolas,&#39;Courier New&#39;,courier,monospace;font-size:16px">    <span style="color:#0000ff">function</span> TestObj(<span style="color:#0000ff">name</span>) {<br>        <span style="color:#0000ff">this</span>.<span style="color:#0000ff">name</span> = <span style="color:#0000ff">name</span>;<br>    }<br>    <span style="color:#0000ff">var</span> objs = [];<br>    <span style="color:#0000ff">var</span> obj;<br>    <span style="color:#0000ff">function</span> test() {<br>        <span style="color:#0000ff">for</span> (<span style="color:#0000ff">var</span> i = 0; i &lt; 100; i++) {<br>            <span style="color:#0000ff">var</span> <span style="color:#0000ff">name</span> = &quot;<span style="color:#8b0000">张磊</span>&quot; + i;<br>            obj = <span style="color:#0000ff">new</span> TestObj(<span style="color:#0000ff">name</span>);<br>              (<span style="color:#0000ff">function</span> (target) {<br>            obj.printName = <span style="color:#0000ff">function</span> () {<br>                console.log(target.<span style="color:#0000ff">name</span>);<br>            }<br>               } (obj))<br>            objs.push(obj);<br>        }<br>    }<br>    test();<br>    <span style="color:#0000ff">for</span> (<span style="color:#0000ff">var</span> i <span style="color:#0000ff">in</span> objs) {<br>        objs[i].printName();<br>    }</pre><p> </p><p>真实案例：   <br></p><pre style="background-color:#fbfbfb;margin:0em;width:100%;font-family:consolas,&#39;Courier New&#39;,courier,monospace;font-size:16px"><span style="color:#008000">// create and populate the screen with random daisies: </span><br><span style="color:#0000ff">for</span>(<span style="color:#0000ff">var</span> i = 0; i &lt; 100; i++){ <br>    bitmap = <span style="color:#0000ff">new</span> Bitmap(image); <br>    container.addChild(bitmap); <br>    bitmap.x = canvas.width * <span style="color:#0000ff">Math</span>.random()|0; <br>    bitmap.y = canvas.height * <span style="color:#0000ff">Math</span>.random()|0; <br>    bitmap.rotation = 360 * <span style="color:#0000ff">Math</span>.random()|0; <br>    bitmap.regX = bitmap.image.width/2|0; <br>    bitmap.regY = bitmap.image.height/2|0; <br>    bitmap.scaleX = bitmap.scaleY = bitmap.scale = <span style="color:#0000ff">Math</span>.random()*0.4+0.6; <br>    bitmap.<span style="color:#0000ff">name</span> = &quot;<span style="color:#8b0000">bmp_</span>&quot;+i;<br>    <span style="color:#008000">// wrapper function to provide scope for the event handlers: </span><br>    (<span style="color:#0000ff">function</span>(target) { <br>        bitmap.onPress = <span style="color:#0000ff">function</span>(evt) { <br>            <span style="color:#008000">// bump the target in front of it's siblings: </span><br>            container.addChild(target); <br>            <span style="color:#0000ff">var</span> offset = {x:target.x-evt.stageX, y:target.y-evt.stageY};<br>            <span style="color:#008000">// add a handler to the event object's onMouseMove callback </span><br>            <span style="color:#008000">// this will be active until the user releases the mouse button: </span><br>            evt.onMouseMove = <span style="color:#0000ff">function</span>(ev) { <br>                target.x = ev.stageX+offset.x; <br>                target.y = ev.stageY+offset.y; <br>                <span style="color:#008000">// indicate that the stage should be updated on the next tick: </span><br>                update = <span style="color:#0000ff">true</span>; <br>            } <br>        } <br>        bitmap.onMouseOver = <span style="color:#0000ff">function</span>() { <br>            target.scaleX = target.scaleY = target.scale*1.2; <br>            update = <span style="color:#0000ff">true</span>; <br>        } <br>        bitmap.onMouseOut = <span style="color:#0000ff">function</span>() { <br>            target.scaleX = target.scaleY = target.scale; <br>            update = <span style="color:#0000ff">true</span>; <br>        } <br>    })(bitmap); <br>}</pre><p>这是Easeljs官网demo的一段代码，因为内部函数不会立即执行，所以当执行的时候,内部函数引用外部函数变量的时候，该变量已经被外层的for循环覆盖了N次，所以要通过上面的方式来解决这个问题。</p><p> </p><p><strong>小结</strong></p><p><font size="4">这是javascript蹩脚的一个方面，除了这个，还有javascript的 getter和setter也是该语言语法特性中令人憋屈的地方。另外，在javascript 的一些OOP方式中，我们经常用下划线（_xxxx）的方式代表其为私有变量，但是外部却可以访问，用约定来弥补其语法上的不足。</font></p><p><font size="4">我相信经过人类的不懈努力，总有那么一天：static 、namespace、interface、private、protected 、class、enum·············都能成为javascript的关键字，而不是五花八门的技巧，对应这些关键字的所有 文章 笔记  心得  日记 技巧 随笔 后门  都将沉尸谷底、永无翻身之日。相信那个时候，HTML5已经成熟。正如小胖所说:<em>什么时候做html5游戏的朋友能够不再纠结于什么js技巧 canvas性能优化的，那就说明html5游戏这个领域成熟了。</em></font></p><img src="http://www.cnblogs.com/iamzhanglei/aggbug/2368566.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/iamzhanglei/archive/2012/02/27/2368566.html">本文链接</a></p>