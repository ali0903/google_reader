---
layout: post
title:  "AndroidNDK开发之“文件操作”"
date:   2011-02-28 17:18:00
author: duicky
categories: program
---

## AndroidNDK开发之“文件操作”
### by duicky
### at 2011-02-28 17:18:00
### original <http://www.cnblogs.com/luxiaofeng54/archive/2011/02/28/1967190.html>

<p><p>其实和上层没什么关系，主要是通过C来完成文件的基本操作。不好意思大家，时间不够，不多说，贴上关键代码。</p>
<p>关键文件代码：</p>
<p>MainActivity.java</p>
<p>package com.scan.file;<br><br>import android.app.Activity;<br>import android.os.Bundle;<br>import android.view.View;<br>import android.view.View.OnClickListener;<br>import android.widget.Button;<br>import android.widget.Toast;<br><br>public class MainActivity extends Activity {<br><br>    private static final String TAG = &quot;File&quot;;<br>    private Button doc = null;<br><br>    /** Called when the activity is first created. */<br>    @Override<br>    public void onCreate(Bundle savedInstanceState) {<br>        super.onCreate(savedInstanceState);<br>        setContentView(R.layout.main);<br><br>        initControls();<br>    }<br><br>    /**<br>     * 初始化控件<br>     */<br>    public void initControls() {<br>        doc = (Button) this.findViewById(R.id.btn_do_c);<br>        doc.setOnClickListener(new MyButtonOnClickListener());<br>    }<br><br>    /**<br>     * 监听ButtonOnClick<br>     * <br>     * @author lxf<br>     * <br>     */<br>    class MyButtonOnClickListener implements OnClickListener {<br><br>        @Override<br>        public void onClick(View v) {<br>            switch (v.getId()) {<br><br>            case R.id.btn_do_c:<br>                String do_c_result = doCMethod();<br>                displayMessage(do_c_result);<br>                break;<br>            }<br><br>        }<br><br>    }<br><br>    /*<br>     * Toast显示消息<br>     */<br>    private void displayMessage(String msg) {<br>        Toast.makeText(this, msg, Toast.LENGTH_SHORT).show();<br>    }<br><br>    /**<br>     * 测试方法<br>     * <br>     * @return<br>     */<br>    public native String sayHello();<br><br>    /**<br>     * 执行C底层的方法<br>     * <br>     * @return<br>     */<br>    public native String doCMethod();<br><br>    /*<br>     * 载人本地库文件<br>     */<br>    static {<br>        System.loadLibrary(&quot;AndroidJni&quot;);<br>    }<br>}</p>

<p>file.h</p>
<p>#include &lt;string.h&gt;<br>#include &lt;stdio.h&gt;<br>#include "define.h"<br><br>unsigned short File_Open(FILE_HANDLE** FileHandle, char* name, unsigned short flag,unsigned short mode);<br><br>unsigned short File_Close(FILE_HANDLE* FileHandle);<br><br>unsigned short File_GetSize(FILE_HANDLE* FileHandle, unsigned long* FileSize);<br><br>unsigned short File_Read(FILE_HANDLE* FileHandle, char* buf, unsigned long count,unsigned long* ReadCount);<br><br>unsigned short File_Write(FILE_HANDLE* FileHandle, char* buf, unsigned long count,unsigned long* WriteCount);<br><br>unsigned short File_Seek(FILE_HANDLE* FileHandle, long offset, short origin,unsigned long* SeekLen);<br><br>unsigned short File_Delete(char* name);<br><br>unsigned short File_ISExist(char* path);<br><br>unsigned short File_Create_Dir(char* dirName);<br><br>unsigned short File_Delete_Dir(char* dirName);</p>
<p>Android.mk</p>
<p><br>LOCAL_PATH := $(call my-dir)<br><br>include $(CLEAR_VARS)<br><br>LOCAL_MODULE    := AndroidJni<br>LOCAL_SRC_FILES := AndroidJni.c File.c SyncmlEngine.c<br><br>LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -llog<br><br>include $(BUILD_SHARED_LIBRARY)</p>

<p>AndroidJni.c</p>
<p>#include &lt;string.h&gt;<br>#include &lt;jni.h&gt;<br>#include &lt;android/log.h&gt;<br>#include "SyncmlEngine.h"<br><br>//测试方法sayHello<br>jstring Java_com_scan_file_MainActivity_sayHello(JNIEnv* env, jobject thiz) {<br>    //打印信息出来<br>    __android_log_print(ANDROID_LOG_INFO, &quot;JNIMsg&quot;, &quot;SayHello&quot;);<br>    return (*env)-&gt;NewStringUTF(env, &quot;Hello from JNI ! sayHello&quot;);<br>}<br><br>//执行C底层方法<br>jstring Java_com_scan_file_MainActivity_doCMethod(JNIEnv* env, jobject thiz) {<br>    //打印信息出来<br>    __android_log_print(ANDROID_LOG_INFO, &quot;JNIMsg&quot;, &quot;doCMethod&quot;);<br><br>    SyncmlStart();<br><br>    return (*env)-&gt;NewStringUTF(env, &quot;Do C Method OK!&quot;);<br>}<br><br></p>

<p>file.c</p>
<p>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;dirent.h&gt;<br>#include &lt;android/log.h&gt;<br>#include "File.h"<br><br>/**<br> * File_Open--打开文件<br> * flag--读\写\读写\追加<br> * mode--如果没有，是否新建<br> */<br>unsigned short File_Open(FILE_HANDLE** FileHandle, char* name,<br>        unsigned short flag, unsigned short mode) {<br><br>    if (FileHandle == NULL) {<br>        return 100;<br>    }<br>    if (name == NULL) {<br>        return 100;<br>    }<br>    char type[128] = &quot;&quot;;<br><br>    if (flag == FO_OREAD) {<br>        if (mode != FO_CREATE) {<br>            strcpy(type, &quot;r&quot;); //只读，不建文件<br>        } else {<br>            strcpy(type, &quot;r+&quot;);<br>        }<br>    } else if (flag == FO_OWRITE) {<br>        if (mode != FO_CREATE) {<br>            strcpy(type, &quot;w&quot;); //只写，不建文件<br>        } else {<br>            strcpy(type, &quot;w+&quot;);<br>        }<br>    } else if (flag == FO_RW) {<br>        if (mode != FO_CREATE) {<br>            strcpy(type, &quot;a&quot;);<br>        } else {<br>            strcpy(type, &quot;a+&quot;);<br>        }<br>    } else if (flag == FO_APPEND) {<br>        if (mode != FO_CREATE) {<br>            strcpy(type, &quot;a&quot;);<br>        } else {<br>            strcpy(type, &quot;a+&quot;);<br>        }<br>    }<br><br>    *FileHandle = fopen(name, type);<br>    return 0;<br>}<br><br>/**<br> * File_Close--关闭文件<br> * 返回值<br> * 0--关闭成功;否则失败<br> */<br>unsigned short File_Close(FILE_HANDLE* FileHandle) {<br>    if (FileHandle == NULL) {<br>        return 100;<br>    }<br>    return fclose(FileHandle);<br>}<br><br>/**<br> * File_GetSize--得到文件长度<br> * FileSize--返回文件长度<br> */<br>unsigned short File_GetSize(FILE_HANDLE* FileHandle, unsigned long* FileSize) {<br>    if (FileHandle == NULL) {<br>        return 100;<br>    }<br>    fseek(FileHandle, 0L, SEEK_END);<br>    *FileSize = ftell(FileHandle);<br>    return 0;<br>}<br><br>/**<br> * File_Read--读取文件到buf<br> * count--读取的长度<br> * ReadCount--返回已读取的长度<br> */<br>unsigned short File_Read(FILE_HANDLE* FileHandle, char* buf,<br>        unsigned long count, unsigned long* ReadCount) {<br>    if (FileHandle == NULL) {<br>        return 100;<br>    }<br>    *ReadCount = fread(buf, 1, count, FileHandle);<br>    __android_log_print(ANDROID_LOG_INFO, &quot;JNIMsg&quot;,<br>            &quot;File_Read           ReadCount=%d&quot;, *ReadCount);<br>    return 0;<br>}<br><br>/**<br> * File_Write--从buf中写入文件<br> * count--写入的长度<br> * WriteCount--返回已写入的长度<br> */<br>unsigned short File_Write(FILE_HANDLE* FileHandle, char* buf,<br>        unsigned long count, unsigned long* WriteCount) {<br>    if (FileHandle == NULL) {<br>        return 100;<br>    }<br>    unsigned short write_result = fwrite(buf, count, 1, FileHandle); // 返回值是成功写入的项目数<br>    if(write_result == 1) {<br>        *WriteCount = write_result * count;<br>    }<br>    return write_result;<br>}<br><br>/**<br> * File_Seek--给文件偏移量<br> * offset--偏移量<br> * origin--偏移方向<br> * SeekLen--返回已偏移的长度<br> * 返回值0--成功,其他失败<br> */<br>unsigned short File_Seek(FILE_HANDLE* FileHandle, long offset, short origin,<br>        unsigned long* SeekLen) {<br>    unsigned short seek_result = fseek(FileHandle, offset, origin);<br>    if(seek_result == 0) {<br>        *SeekLen = offset;<br>    }<br>    return seek_result;<br>}<br><br>/**<br> * File_Delete--删除文件<br> * 0--删除成功  -1--删除失败<br> */<br>unsigned short File_Delete(char* name) {<br>    if (name == NULL) {<br>        return 100;<br>    }<br>    return remove(name);<br>}<br><br>/**<br> * File_ISExist--判断文件是否存在<br> * 0存在  -1不存在<br> */<br>unsigned short File_ISExist(char* path) {<br>    if (path == NULL) {<br>        return 100;<br>    }<br>    return access(path, 0);<br>}<br><br>/**<br> * File_Create_Dir--创建文件目录<br> * 返回0--成功<br> */<br>unsigned short File_Create_Dir(char* dirName) {<br>    if (dirName == NULL) {<br>        return 100;<br>    }<br>    return mkdir(dirName, S_IRWXU);<br>}<br><br>/**<br> * File_Delete_Dir--删除文件目录<br> */<br>unsigned short File_Delete_Dir(char* dirName) {<br>    if (dirName == NULL) {<br>        return 100;<br>    }<br>    DIR* dp = NULL;<br>    DIR* dpin = NULL;<br>    char *pathname = (char*) malloc(256);<br>    memset(pathname, 0, 256);<br>    struct dirent* dirp;<br>    dp = opendir(dirName);<br>    if (dp == NULL) {<br>        __android_log_print(ANDROID_LOG_INFO, &quot;JNIMsg&quot;,<br>                &quot;File_Delete_Dir      your input directory is not exist!&quot;);<br>        return 100;<br>    }<br>    while ((dirp = readdir(dp)) != NULL) {<br>        if (strcmp(dirp-&gt;d_name, &quot;..&quot;) == 0 || strcmp(dirp-&gt;d_name, &quot;.&quot;) == 0)<br>            continue;<br>        strcpy(pathname, dirName);<br>        strcat(pathname, &quot;/&quot;);<br>        strcat(pathname, dirp-&gt;d_name);<br>        dpin = opendir(pathname);<br>        if (dpin != NULL) {<br>            closedir(dpin);<br>            dpin = NULL;<br>            File_Delete_Dir(pathname);<br>        } else {<br>            remove(pathname);<br>        }<br>    }<br>    rmdir(dirName);<br>    closedir(dp);<br>    free(pathname);<br>    pathname = NULL;<br>    dirp = NULL;<br><br>    return 0;<br>}</p>

<p>有看不懂的地方可以留言，一起探讨。</p><img src="http://www.cnblogs.com/luxiaofeng54/aggbug/1967190.html?type=1" width="1" height="1" alt=""><p>作者: <a href="http://www.cnblogs.com/luxiaofeng54/">duicky</a> 发表于 2011-02-28 17:18 <a href="http://www.cnblogs.com/luxiaofeng54/archive/2011/02/28/1967190.html">原文链接</a></p><p>评论: 0　<a href="http://www.cnblogs.com/luxiaofeng54/archive/2011/02/28/1967190.html#pagedcomment">查看评论</a>　<a href="http://www.cnblogs.com/luxiaofeng54/archive/2011/02/28/1967190.html#commentform">发表评论</a></p><hr><p>最新新闻：<br>· <a href="http://news.cnblogs.com/n/92415/">社交网站重度用户 求婚“开价”百万粉丝</a><span style="color:gray">(2011-02-28 17:02)</span><br>· <a href="http://news.cnblogs.com/n/92414/">MySpace之死：新闻集团束缚 音乐救赎幻灭</a><span style="color:gray">(2011-02-28 16:54)</span><br>· <a href="http://news.cnblogs.com/n/92413/">Windows“随机浏览器选择”的赢家和输家</a><span style="color:gray">(2011-02-28 16:31)</span><br>· <a href="http://news.cnblogs.com/n/92412/">死在Google新算法屠刀下的知名站点们</a><span style="color:gray">(2011-02-28 16:28)</span><br>· <a href="http://news.cnblogs.com/n/92411/">盛大无线转轨移动集成应用 陈天桥打造娱乐版图</a><span style="color:gray">(2011-02-28 16:20)</span><br></p><p>编辑推荐：<a href="http://news.cnblogs.com/n/92343/">（麻省理工免费课程）计算机科学和编程</a><br></p><p>网站导航：<a href="http://www.cnblogs.com">博客园首页</a>  <a href="http://home.cnblogs.com/">我的园子</a>  <a href="http://news.cnblogs.com">新闻</a>  <a href="http://home.cnblogs.com/ing/">闪存</a>  <a href="http://home.cnblogs.com/group/">小组</a>  <a href="http://space.cnblogs.com/q/">博问</a>  <a href="http://kb.cnblogs.com">知识库</a></p></p>