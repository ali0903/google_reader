---
layout: post
title:  "buffer.concat引出的bug"
date:   2013-03-30 15:42:10
author: snoopyxdy
categories: program
---

## buffer.concat引出的bug
### by snoopyxdy
### at 2013-03-30 15:42:10
### original <http://snoopyxdy.blog.163.com/blog/static/601174402013230102139585>

<div>最近有位rrestjs框架的使用者YanQ报告给我这样一个错误，跟我说在用户post很多内容的文章时会crash进程然后报如下错误：（<span style="line-height:22px">热心的老雷帮我解决了问题</span>）<div><pre><p>buffer.js:523<br>    throw new RangeError('targetStart out of bounds');</p></pre>具体报错的位置在：</div><div><pre><p>var buf =  Buffer.concat(rec_ary, rec_ary.length);</p></pre>其中rec_ary就是存放buffer的数组。</div><div>当然这个bug是具有一定隐蔽性的，因为这个bug被报告为本地测试环境没有问题，而线上会有。所以一开始一直以为是node版本兼容性，系统兼容性等等的问题。</div><div><br></div><div>我们先看下官方api里buffer.concat方法的说明吧：</div><div><p></p><div><pre><p></p><div>Class Method: Buffer.concat(list, [totalLength])#</div><div>list Array List of Buffer objects to concat</div><div>totalLength Number Total length of the buffers when concatenated</div><div>...</div><div>If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.</div><p></p></pre></div><div>我个人觉得很具有迷惑性，total length of the buffers 这句话怎么理解？</div><div>我理解为list的长度，需要连接的buffers的数量，但是真实的情况却是这样的，下面代码是node v0.10.2 /lib/buffer.js中的片段：</div><div><pre><p></p><div>Buffer.concat = function(list, length) {</div><div>... //省略</div><div><br></div><div><div>if (typeof length !== 'number') {</div><div>    length = 0;</div><div>    for (var i = 0; i &lt; list.length; i++) {</div><div>      var buf = list[i];</div><div>      length += buf.length;</div><div>    }</div><div>  }</div></div><div>...//省略</div><div>}</div><p></p></pre></div><div>原来这句话的正确理解是，需要连接的所有buffers的长度，也就是buffers的总长度，理解出现偏差造成了这个bug。正确的buffer.concat代码如下：</div><div><pre><p></p><div>var bufAry = []</div><div>var bufLen = 0;</div><div>for(var i=0;i&lt;5;i++){</div><div><span>	</span>bufAry[i] = new Buffer("str is "+ i + '\n');</div><div><span>	</span>bufLen += bufAry[i].length</div><div>}</div><div>console.log(bufLen)</div><div>var newBuf = Buffer.concat(bufAry,bufLen)</div><div>console.log(newBuf.toString())</div><p></p></pre></div><div>将输出：</div><div><pre><p>45<br>str is 0<br>str is 1<br>str is 2<br>str is 3<br>str is 4</p></pre>所以希望今后大家用到buffer.concat方法时要注意以下，第二个参数务必传递buffers的总长度，当然你也可以偷懒省略第二个参数，这样也不会有问题。</div><div><br></div><div>这次顺便也看了看buffer.js的源码，发现挺有意思， SlowBuffer这个类是直接调用c++的接口类，所以我们尽量不要去调用这个类，除非我们想自己维护一个独立buffer池。</div><div>我们看如下代码：</div><div><pre><p></p><div>Buffer.poolSize = 8 * 1024;</div><div>var pool;</div><div>function allocPool() {</div><div>  pool = new SlowBuffer(Buffer.poolSize);</div><div>  pool.used = 0;</div><div>}</div><p></p></pre></div><div>分配buffer池的函数会将模块变量pool赋值为slowbuffer的实例，同时默认大小为8KB，那这个8KB对我们有什么意义呢？其实8KB只是一个存储的空间，如果我们有很多小的buffer，将会共用这8KB的存储空间，我们看代码如下：</div><div><br></div><div><pre><p></p><div>function Buffer(subject, encoding, offset) { //buffer类</div><div><span>	</span>... //省略以上是一些参数的初始化，switch判断等等</div><div><br></div><div>     if (this.length &gt; Buffer.poolSize) {  //this.length就是之前初始化的本buffer实例需要分配的内存bytes空间，跟8KB进行比较</div><div>      // Big buffer, just alloc one.</div><div>      this.parent = new SlowBuffer(this.length); //如果大于8KB则使用c++的api重新为它分配存储空间，并且将返回的实例赋值给this.parent,这样我们就知道了此buffer实例保存在了哪块内存中</div><div>      this.offset = 0; //因为这块内存是此buffer实例第一个独享的，所以记录其偏移为0</div><div><br></div><div>    } else if (this.length &gt; 0) { //如果此buffer实例大于0但是小于8KB ,node认为是小的buffer</div><div>      // Small buffer.</div><div>      if (!pool || pool.length - pool.used &lt; this.length) allocPool();  //如果当前8KB内存池不够存储了，则重新分配一个slowbuffer让此buffer实例存储</div><div>      this.parent = pool;  //将当前分配的内存buffer池赋值给 this.parent 方便之后的读取和剪切等</div><div>      this.offset = pool.used; //将偏移赋值给此buffer实例</div><div>      pool.used += this.length; //并且更新此buffer池的使用byte</div><div>      if (pool.used &amp; 7) pool.used = (pool.used + 8) &amp; ~7;</div><div>//将pool.used按位与7，如果<span style="line-height:22px">pool.used</span><span style="line-height:22px">是8或8的倍数，则表达式</span><span style="line-height:22px">pool.used &amp; 7是false，否则为true</span></div><div><span style="line-height:22px">//</span><span style="line-height:22px"> </span><span style="line-height:22px">(pool.used + 8) &amp; ~7; 这里将返回大于pool.used最近的8的倍数</span></div><div><span style="line-height:22px">//比如我们pool.used的大小为9byte，则执行这行代码之后，pool.used会调整为16，6byte的内存浪费了，这也是很多文章建议我们申请小于8KB的内存的时候最好是8的倍数，避免造成浪费</span></div><div><br></div><div>    } else { //如果是0长度的buffer，所以所有长度0的buffer都是 var zeroBuffer = new SlowBuffer(0);</div><div>      // Zero-length buffer</div><div>      this.parent = zeroBuffer;</div><div>      this.offset = 0;</div><div>    }</div><div>   ... //处理一些数据，包括调用wrtie将buffer写入</div><div> SlowBuffer.makeFastBuffer(this.parent, this, this.offset, this.length); </div><div>//最后将这些参数通过slowbuffer的<span style="line-height:22px">makeFastBuffer将内存地址和js的buffer实例做好关联引用</span></div><div>}</div><p></p></pre></div><div><br></div><div>打开node_buffer.h，我们看到声明了Buffer类的static静态成员函数</div><div><pre><p>static v8::Handle&lt;v8::Value&gt; MakeFastBuffer(const v8::Arguments &amp;args);</p></pre></div><div>打开node_buffer.cc，找到<span style="line-height:22px;font-family:monospace;white-space:pre">MakeFastBuffer的实现：</span></div><div><pre><br><p>Handle&lt;Value&gt; Buffer::MakeFastBuffer(const Arguments &amp;args) { <br>  HandleScope scope;<br><br>  if (!Buffer::HasInstance(args[0])) {<br>    return ThrowTypeError("First argument must be a Buffer"); //判断第一个函数是否是buffer类的实例<br>  }<br><br>  Buffer *buffer = ObjectWrap::Unwrap&lt;Buffer&gt;(args[0]-&gt;ToObject());  //创建一个Buffer指针指向this.parent<br>  Local&lt;Object&gt; fast_buffer = args[1]-&gt;ToObject();; //定义V8的local&lt;object&gt;类型的fast_buffer指向this<br>  uint32_t offset = args[2]-&gt;Uint32Value(); //将偏移量和this.length保存成C++的uint32<br>  uint32_t length = args[3]-&gt;Uint32Value();<br><br>  if (offset &gt; buffer-&gt;length_) {  //如果偏移量比this.parent总长度还要长，则抛出异常<br>    return ThrowRangeError("offset out of range");<br>  }<br><br>  if (offset + length &gt; buffer-&gt;length_) { //如果偏移量加上本buffer的长度大于this.parent的总长度，则抛出异常<br>    return ThrowRangeError("length out of range");<br>  }<br><br>  // Check for wraparound. Safe because offset and length are unsigned.<br>  if (offset + length &lt; offset) { //如果偏移量或者length加起来小于偏移量，则抛出异常，一般不会出现<br>    return ThrowRangeError("offset or length out of range");<br>  }<br><br>  fast_buffer-&gt;SetIndexedPropertiesToExternalArrayData(buffer-&gt;data_ + offset,<br>                                                       kExternalUnsignedByteArray,<br>                                                       length);</p><p>   //最后调用v8接口的<span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">SetIndexedPropertiesToExternalArrayData方法将数据与js的对象建立起引用关系</span></p><p>  <br>  return Undefined();<br>}</p></pre></div><div>node是通过new char[length]来申请内存空间保存buffer的，调用<span style="line-height:22px">v8的</span><span style="line-height:22px;font-family:monospace;white-space:pre">SetIndexedPropertiesToExternalArrayData来建立引用关系</span><span style="line-height:22px">，因为一块8KB的内存可能公用，所以要根据</span><span style="line-height:22px;font-family:monospace;white-space:pre">buffer-&gt;data_ 和</span><span style="line-height:22px">偏移量取得指定的内存地址。C++中buffer的data_属性就是指向这块slowbuffer的指针。</span></div><div>值得注意的是V8的手册上有这样的说明：</div><div>Note: The embedding program still owns the data and needs to ensure that the backing store is preserved while V8 has a reference.</div><div><br></div><div>总结一下：</div><div>1、大家盛传的8KB内存空间池是小buffer的载体，所以如果很悲催的每次保存都是4097byte（略大于4096byte），那么内存可能就会造成很大的浪费，每个4097byte的块都将占用8KB。</div><div>2、slowbuffer并不是如字面意思那样，不是慢速的buffer，只是大于8KB的或者当buffer池不够用的情况下会用slowbuffer来申请空间，大于8KB或者直接用new slowbuffer出来的这个空间将是独享的，小于8KB的buffer将会共享内存空间。</div><div>3、一定要确保buffer的正确释放，不然可能存在内存泄露。</div><div><br></div><div>最后我们做个简单的实验，模拟一个比较严重的内存泄露情况：</div><div><pre><div>var os = require('os');<br>var leak_buf_ary = [];<br>var show_memory_usage = function(){ //打印系统空闲内存<br>	console.log('free mem : ' + Math.ceil(os.freemem()/(1024*1024)) + 'mb');<br>}<br><br>var do_buf_leak = function(){<br>	var leak_char = 'l'; //泄露的几byte字符<br>	var loop = 100000;//10万次<br>	var buf1_ary = []<br>	while(loop--){<br>		buf1_ary.push(new Buffer(4096)); //申请buf1，占用4096byte空间，会得到自动释放<br><br>		//申请buf2，占用几byte空间，将其引用保存在外部数据，不会自动释放<br>		//*******<br>		leak_buf_ary.push(new Buffer(loop+leak_char));<br>		//*******<br>	}<br>	console.log("before gc")<br>	show_memory_usage();<br>	buf1_ary = null;<br>	return;<br>}<br><br><br>console.log("process start")<br>show_memory_usage()<br><br>do_buf_leak();<br><br>var j =10000;<br>setInterval(function(){<br>	console.log("after gc")<br>	show_memory_usage()<br>},1000*60)<br></div><div><br></div><p></p></pre></div><div><br></div><div>第一次我们将内存泄漏点那行代码注释掉，运行4分钟后，得到如下打印信息，V8已经自动把我分配的内存释放掉了，free men又回到了开始的数值，很遗憾我们无法手动去对buffer进行gc</div><div><pre><p></p><div>process start</div><div>free mem : 5362mb</div><div>before gc</div><div>free mem : 5141mb</div><div>after gc</div><div>free mem : 5163mb</div><div>after gc</div><div>free mem : 5151mb</div><div>after gc</div><div>free mem : 5148mb</div><div>after gc</div><div>free mem : 5556mb</div><p></p></pre></div><div>第二次我们将泄漏点那行代码放开，让全局变量 <span style="line-height:22px;font-family:monospace;white-space:pre">leak_buf_ary 始终引用着buffer，同样执行10分钟我们看结果：</span></div><div><pre><p></p><div><font face="monospace">process start
free mem : 5692mb
before gc
free mem : 4882mb
after gc
free mem : 4848mb
after gc
free mem : 4842mb
after gc
free mem : 4843mb
after gc
free mem : 4816mb
after gc
free mem : 4822mb
after gc
free mem : 4816mb
after gc
free mem : 4809mb
after gc
free mem : 4810mb
after gc
free mem : 4831mb
after gc
free mem : 4830mb</font></div><div></div><p></p></pre></div><div><span style="line-height:22px">虽然我们释放了4096byte的buffer，但是由于那几byte的字节没有释放掉，将会造成整个8KB的内存都无法释放，如果继续执行循环最终我们的系统内存将耗尽，程序将crash。同样由于我们是依次循环分配 4096+几 byte内存的，所以每块8KB的内存空间都将浪费409Xbyte，在执行循环之后，我们明显发现第二次的内存占用比第一次要大很多。这里我们将近多出了300MB左右的内存消耗。</span></div><div><span style="line-height:22px"><br></span></div><div><div style="line-height:22px"><br></div></div><div><br></div><div><br></div><div>上个贴个图，发现和我一样理解错误的人不在少数，希望博主看见尽快修改，不要误导大众，呵呵</div><div><a rel="nofollow" href="http://blog.csdn.net/jklfjsdj79hiofo/article/details/7873065">http://blog.csdn.net/jklfjsdj79hiofo/article/details/7873065</a></div><div><div><img title="buffer.concat引出的bug - snoopyxdy - snoopyxdy的博客" alt="buffer.concat引出的bug - snoopyxdy - snoopyxdy的博客" style="margin:0 10px 0 0" src="http://img2.ph.126.net/HS9oPR7jrttqLuN9IfuhJQ==/6597515068866283415.png"></div></div></div></div>