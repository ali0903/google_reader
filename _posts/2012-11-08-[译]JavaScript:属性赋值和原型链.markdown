---
layout: post
title:  "[译]JavaScript:属性赋值和原型链"
date:   2012-11-08 10:14:00
author: 紫云飞
categories: program
---

## [译]JavaScript:属性赋值和原型链
### by 紫云飞
### at 2012-11-08 10:14:00
### original <http://www.cnblogs.com/ziyunfei/archive/2012/11/08/2759680.html>

<p>原文:<a href="http://www.2ality.com/2012/11/property-assignment-prototype-chain.html">http://www.2ality.com/2012/11/property-assignment-prototype-chain.html</a></p><hr><p>本文要研究一下:一个对象的原型链是如何影响该对象自身的属性赋值操作的.本文更详细的阐述了一下上篇文章“<a href="http://www.cnblogs.com/ziyunfei/archive/2012/10/31/2738728.html">[译]JavaScript中的属性:定义和赋值的区别</a>”中提到的一个知识点.</p><h3>原型链<p>每个对象都有一个包含了一个或者多个对象的原型链,该对象正是这个原型链的起始对象.原型链上的所有对象的所有属性都可以被该对象访问到.例如:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; <span style="color:#0000ff">var</span> proto = { foo: 1<span style="color:#000000"> };<br></span>&gt; <span style="color:#0000ff">var</span> obj = { __proto__: proto, bar: 2<span style="color:#000000"> };<br></span>&gt;<span style="color:#000000"> obj.foo<br></span>1<br>&gt;<span style="color:#000000"> obj.bar<br></span>2</div><p>我们用到了特殊属性 <tt>__proto__</tt> <sup><a>[1]</a></sup> 来创建原型链(该属性还没有被所有浏览器广泛支持).对象obj的原型链包含了三个对象:起始处是<tt>obj</tt>,紧跟着<tt>proto,最后是O</tt><tt>bject.prototype</tt>. <tt>Object.prototype是<tt>Object构造函数的原型对象,绝大部分原型链中都包含了它</tt></tt>(大部分,但不是全部<sup><a>[2]</a></sup>):</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt;<span style="color:#000000"> Object.prototype.isPrototypeOf({})<br></span><span style="color:#0000ff">true</span><br>&gt;<span style="color:#000000"> Object.prototype.isPrototypeOf([])<br></span><span style="color:#0000ff">true</span><br>&gt; Object.prototype.isPrototypeOf(<span style="color:#0000ff">new</span><span style="color:#000000"> Date())<br></span><span style="color:#0000ff">true</span></div><p>而且它是原型链的截止对象:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt;<span style="color:#000000"> Object.getPrototypeOf(Object.prototype)<br></span><span style="color:#0000ff">null</span></div><p><tt>普通对象的很多标准方法都是从Object.prototype上继承下来的,比如</tt><tt>toString()</tt>和<tt>hasOwnProperty()</tt>.</p><p><strong>为属性赋值</strong></p><p>如果你给一个属性赋值,你通常只能修改原型链上的起始对象(也就是对象自身):如果自身属性已经存在了,则改变这个属性的值,否则,创建这个新的自身属性:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; obj.foo = 3<span style="color:#000000">;<br></span>&gt;<span style="color:#000000"> obj.foo<br></span>3<br>&gt; obj.hasOwnProperty(&quot;foo&quot;<span style="color:#000000">)<br></span><span style="color:#0000ff">true</span><br>&gt;<span style="color:#000000"> proto.foo<br></span>1</div><p>这样设计的目的是:一个原型可以为其所有的实例引入了一个公用的初始值(被继承的属性的值).如果给其中一个实例的同名属性执行赋值操作可以改变原型上的那个公用的属性值的话,那么所有实例的初始值都会被改变.为了防止这种情况发生,同时还允许你修改某单个实例的初始值,属性的赋值操作被设计为:仅允许你改变一个已存在的自身属性的值.如果还没有这个自身属性,则会自动创建,再赋值.</p><p><strong>访问器和原型链</strong></p><p>一个存在于原型链上的访问器属性<sup><a>[3]</a></sup>可以阻止"在该原型链的起始对象上创建同名的自身属性".假如对象obj继承了一个拥有getter和setter的对象:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> obj =<span style="color:#000000"> {<br>    __proto__: {<br>        get foo() {<br>            </span><span style="color:#0000ff">return</span> 1<span style="color:#000000">;<br>        },<br>        set foo(x) {<br>            console.log(</span>"Setter called: "+<span style="color:#000000">x);<br>        }<br>    }<br>};</span></div><p><tt>给对象obj的属性foo赋值的话,会调用到其原型上的</tt>setter访问器,而不会给obj创建一个自身属性foo,同理,读取obj的foo属性的话,也会调用到其原型上的getter访问器:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; obj.foo = 2<span style="color:#000000">;<br>Setter called: </span>2<br>&gt;<span style="color:#000000"> obj.foo<br></span>1</div><p>如果你想禁止该属性的赋值操作的话(也就是只读),可以不提供setter:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> obj =<span style="color:#000000"> {<br>    __proto__: {<br>        get foo() {<br>            </span><span style="color:#0000ff">return</span> 1<span style="color:#000000">;<br>        }<br>    }<br>};</span></div><p>这样的赋值操作,在非严格模式下会静默失败,在严格模式下,会抛出异常<sup><a>[4]</a></sup>:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; (<span style="color:#0000ff">function</span> () { "use strict"; obj.foo = 2<span style="color:#000000">; }());<br>TypeError: Cannot set property foo of obj which has only a getter</span></div><p><strong>原型链上的只读属性</strong></p><p>如果原型链上的起始对象继承了一个只读属性,则你无法通过赋值操作改变这个属性的值.例如,下面的代码:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> proto =<span style="color:#000000"> Object.defineProperty({},<br>    </span>"foo"<span style="color:#000000">,<br>    {<br>        value: </span>1<span style="color:#000000">,<br>        writable: </span><span style="color:#0000ff">false</span><span style="color:#000000"><br>    });<br></span><span style="color:#0000ff">var</span> obj = { __proto__: proto };</div><p>你无法给<tt>obj.foo赋值</tt>:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; (<span style="color:#0000ff">function</span> () { "use strict"; obj.foo = 2<span style="color:#000000">; }());<br>TypeError: obj.foo is read</span>-only</div><p>这正好和只有getter的访问器属性的表现相一致.这一次,原型上的属性同样可以作为一个共享的初始值,不同的是,我们要防止单个实例更改自己的初始值.如果你想要给obj创建一个自身属性foo,则你可以使用<tt>Object.defineProperty()和</tt><tt>Object.defineProperties()来完成</tt><sup><a>[5]</a></sup>.</p><p><strong>参考</strong></p><ol><li><a href="http://www.cnblogs.com/ziyunfei/archive/2012/10/05/2710955.html">[译]JavaScript: __proto__</a></li><li><a href="http://www.cnblogs.com/ziyunfei/archive/2012/09/16/2686984.html">[译]JavaScript中,什么对象不是Object的实例?</a></li><li><a href="http://www.cnblogs.com/ziyunfei/archive/2012/10/30/2745786.html">[译]JavaScript中的属性</a></li><li><a href="http://pkw-aufladen.de/browse.php?u=tJ6nbZBB9Y8OSCYFWCCl%2BGzWQHteGiW0QnMop1LEuVVx9Edi5VIQvAfzhNs3jvERLJgVDKPsoTsLGPH1s0Q%3D&amp;b=29">JavaScript’s strict mode: a summary</a></li><li><a href="http://www.cnblogs.com/ziyunfei/archive/2012/10/31/2738728.html">[译]JavaScript中的属性:定义和赋值的区别</a></li></ol><img src="http://www.cnblogs.com/ziyunfei/aggbug/2759680.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/ziyunfei/archive/2012/11/08/2759680.html">本文链接</a></p></h3>