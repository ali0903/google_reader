---
layout: post
title:  "JavaScript:遍历原型链,调用栈,作用域链"
date:   2012-11-12 21:49:00
author: 紫云飞
categories: program
---

## JavaScript:遍历原型链,调用栈,作用域链
### by 紫云飞
### at 2012-11-12 21:49:00
### original <http://www.cnblogs.com/ziyunfei/archive/2012/11/12/2765794.html>

<p>在JavaScript中,有三种常见的链式结构:原型链(Prototype Chain),调用栈(<span>Call Stack</span>),作用域链(Scope Chain).本文并不准备讲这些概念的基础知识,而是要给出如何遍历这三种链结构的方法,从而加深理解.</p><p><strong>遍历原型链</strong></p><p>在JavaScript中,任何对象都有自己的原型链.原型链是由一系列对象加上最后的null组成的.如果还没掌握相关基础知识,可以看看我在MDN上翻译的<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Guide/Inheritance_and_the_prototype_chain">继承与原型链</a>一文.遍历函数如下:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> getPrototypeChain(obj) {<br>    </span><span style="color:#0000ff">var</span> protoChain =<span style="color:#000000"> [];<br>    </span><span style="color:#0000ff">while</span> (obj =<span style="color:#000000"> Object.getPrototypeOf(obj)) {<br>        protoChain.push(obj);<br>    }<br>    protoChain.push(</span><span style="color:#0000ff">null</span><span style="color:#000000">);<br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> protoChain;<br>}</span></div><p>尝试执行一下</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt;getPrototypeChain(<span style="color:#0000ff">new</span> String(""<span style="color:#000000">))<br>[String, Object, </span><span style="color:#0000ff">null</span>]                     <span style="color:#008000">//</span><span style="color:#008000">依次是String.prototype,Object.prototype,null</span><br>  <br>&gt;getPrototypeChain(<span style="color:#0000ff">function</span><span style="color:#000000">(){})<br>[</span><span style="color:#0000ff">function</span> Empty() {}, Object, <span style="color:#0000ff">null</span>]        <span style="color:#008000">//</span><span style="color:#008000">依次是Function.prototype,Object.prototype,null</span></div><p>这个函数是在我以前写的一篇文章<a href="http://www.cnblogs.com/ziyunfei/archive/2012/10/15/2723963.html">JavaScript:我对原型链的理解</a>中给出的.</p><p><strong>遍历调用栈</strong></p><p>在JavaScript中,调用栈就是一系列的函数,表明当前函数是由哪些上层函数调用的.遍历函数如下:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> getCallStack() {<br>    </span><span style="color:#0000ff">var</span> stack =<span style="color:#000000"> [];<br>    </span><span style="color:#0000ff">var</span> fun =<span style="color:#000000"> getCallStack;<br>    </span><span style="color:#0000ff">while</span> (fun =<span style="color:#000000"> fun.caller) {<br>        stack.push(fun)<br>    }<br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> stack<br>}<br></span></div><p>该函数用到了非标准的<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Function/caller">caller</a>属性,不过主流浏览器都支持它.尝试执行一下:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> a() {<br>    b()<br>}<br><br></span><span style="color:#0000ff">function</span><span style="color:#000000"> b() {<br>    c()<br>}<br><br></span><span style="color:#0000ff">function</span><span style="color:#000000"> c() {<br>    alert(getCallStack().map(</span><span style="color:#0000ff">function</span><span style="color:#000000"> (fun) {<br>        </span><span style="color:#0000ff">return</span> fun.name  <span style="color:#008000">//</span><span style="color:#008000">使用了非标准的<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Function/name">name</a>属性</span><br><span style="color:#000000">    }))  <br>}<br><br>a()  </span><span style="color:#008000">//</span><span style="color:#008000">弹出c,b,a<br></span><span style="color:#000000">b()  </span><span style="color:#008000">//</span><span style="color:#008000">弹出c,b</span></div><p>在调试工具中,我们可以直接使用console.trace()来打印出调用栈.在递归调用中,如果调用栈的长度过长,引擎就会抛出异常"too much recursion".到底多长是上限,不同的引擎不同的操作系统环境这个值是不同的.可以使用下面这个函数表达式获取到这个上限值:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; (<span style="color:#0000ff">function</span>(i){<span style="color:#0000ff">try</span>{(<span style="color:#0000ff">function</span> m(){++i&amp;&amp;m()}())}<span style="color:#0000ff">catch</span>(e){<span style="color:#0000ff">return</span> i}})(0<span style="color:#000000">)<br></span>50761</div><p><strong>遍历作用域链</strong></p><p>作用域链是由一系列执行上下文(Execution context)中的活动对象(Activation object)加最后的全局对象组成的.活动对象是一个抽象实体(Abstract Entity),它是由引擎内部来管理的,并不能通过JavaScript来访问.看不到,摸不着,所以这些知识就很难理解.</p><p>不过在Mozilla的引擎中,有一个魔法属性<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Object/Parent">__parent__</a>可以获取到函数执行时的活动对象.只是在SpiderMonkey中,该属性已经被删除了(Firefox 4开始).不过在Mozilla的另外一个JavaScript引擎<a href="https://developer.mozilla.org/zh-CN/docs/Rhino/Download_Rhino">Rhino</a>(Java编写)上,还可以使用这个特殊属性.遍历代码如下:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> getScopeChain(fun) {<br>    </span><span style="color:#0000ff">var</span> scopeChain =<span style="color:#000000"> [];<br>    </span><span style="color:#0000ff">while</span> (fun =<span style="color:#000000"> fun.__parent__) {<br>        scopeChain.push(fun);<br>    }<br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> scopeChain;<br>}</span></div><p>尝试执行一下:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> a = 0<span style="color:#000000">;<br>(</span><span style="color:#0000ff">function</span><span style="color:#000000"> fun1() {<br>    </span><span style="color:#0000ff">var</span> a = 1<span style="color:#000000">;<br>    (</span><span style="color:#0000ff">function</span><span style="color:#000000"> fun2() {<br>        </span><span style="color:#0000ff">var</span> a = 2<span style="color:#000000">;<br>        (</span><span style="color:#0000ff">function</span><span style="color:#000000"> fun3() {<br>            </span><span style="color:#0000ff">var</span> a = 3<span style="color:#000000">;<br>            getScopeChain(</span><span style="color:#0000ff">function</span> () {}).map(<span style="color:#0000ff">function</span><span style="color:#000000"> (obj) {<br>                print(</span>"-----------------------------"<span style="color:#000000">)<br>                </span><span style="color:#0000ff">for</span>(<span style="color:#0000ff">var</span> i <span style="color:#0000ff">in</span><span style="color:#000000"> obj){<br>                    print(i </span>+ ":" + (obj[i].name?<span style="color:#000000">obj[i].name:obj[i]))<br>                }<br>            })<br>        })()<br>    })()<br>})()<br><br></span>-----------------------------           <span style="color:#008000">//</span><span style="color:#008000">函数fun3</span><br><span style="color:#000000">arguments:[object Arguments]        <br>a:</span>3<span style="color:#000000"><br>fun3:fun3<br></span>-----------------------------           <span style="color:#008000">//</span><span style="color:#008000">函数fun2</span><br><span style="color:#000000">arguments:[object Arguments]<br>a:</span>2<span style="color:#000000"><br>fun2:fun2<br></span>-----------------------------           <span style="color:#008000">//</span><span style="color:#008000">函数fun1</span><br><span style="color:#000000">arguments:[object Arguments]<br>a:</span>1<span style="color:#000000"><br>fun1:fun1<br></span>-----------------------------           <span style="color:#008000">//</span><span style="color:#008000">全局上下文</span><br>a:0<span style="color:#000000"><br>getScopeChain:getScopeChain</span></div><p>另外,如果是在Firefox的特权代码中(chrome上下文),还可以使用<a href="http://developer.mozilla.org/zh-CN/docs/SpiderMonkey/JS_Debugger_API_Guide"><span>Debugger API</span></a><span>来获取到各种引擎内部隐藏着的数据,Firebug中的以及Firefox自带的调试器,都是用这些API来实现的.<br></span></p><p><img src="http://pic002.cnblogs.com/images/2012/116671/2012111221445545.png" alt=""></p><img src="http://www.cnblogs.com/ziyunfei/aggbug/2765794.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/ziyunfei/archive/2012/11/12/2765794.html">本文链接</a></p>