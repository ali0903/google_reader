---
layout: post
title:  "“计算机之子”的MVVM框架源码学习笔记"
date:   2012-09-15 19:34:00
author: 司徒正美
categories: program
---

## “计算机之子”的MVVM框架源码学习笔记
### by 司徒正美
### at 2012-09-15 19:34:00
### original <http://www.cnblogs.com/rubylouvre/archive/2012/09/15/2686634.html>

<p>随着avalon v2项目的启动，我又开始学习业内的各个MVVM框架。在一次偶然机会，幸运接触到计算机之子<a href="http://winter-cn.cnblogs.com/">winter-cn</a>的MVVM源码，需要认真学习一下。</p><p>不过，这放出来是比较早期的源码，现在可能改进很多，膜拜地址：<a href="http://shaofei.name/mvvm/">http://shaofei.name/mvvm/</a></p><p>计算机之子的MVVM现在只支持非常高级的浏览器，还在使用IE678这样破浏览器，就免进吧，人家的高瞻远瞩岂非尔等屌丝所能想象的！</p><p>他的框架由三个文件组成，分别是EventSource.js，ViewModel.js，HTMLTemplate.js。</p><p>EventSource其实就可以看作为W3C的EventTarget类，是提供观察者模式的机制，没什么好说的。</p><br>function EventSource() {<br>    var eventHandlers = {};<br>    this.addEventListener = function (type, handler) {//绑定事件<br>        if (!eventHandlers[type]) {<br>            eventHandlers[type] = [];<br>        }<br>        eventHandlers[type].push(handler);<br>    };<br>    this.removeEventListener = function (type, handler) {//卸载事件<br>        if (!eventHandlers[type]) {<br>            return;<br>        }<br>        eventHandlers[type] = eventHandlers[type].filter(function (f) {<br>            return f != handler;<br>        })<br>    };<br>    this.dispatchEvent = function (e) {//派发事件<br>        if (eventHandlers.hasOwnProperty(e.type)) {<br>            eventHandlers[e.type].forEach(function (f) {<br>                f.call(this, e);<br>            })<br>        }<br>        if (this["on" + e.type]) {//??这个有用吗，没看到调用处<br>            this["on" + e.type](e);<br>        }<br>    }<br>}<br><p>ViewModel.js里面提供了两个EventSource的子类，分别叫做ViewModel与ArrayViewModel,功效类于backbone的Model与Collection，或knouckout的ko.observable与ko.observableArray。不过backbone这样的垃圾怎么能与MVVM这样的高级货相提并论呢，死到一边凉快吧！</p><br><br>function ViewModel(data,parent) {<br>    if(data instanceof Array)//由于只针对当前页面，instanceof就足够了，不过既然不支持IE，可以用上Array.isArray<br>        return new ArrayViewModel(data,parent);<br>    var children = {};<br>    var me = this;<br>    for(var p in data) {<br>        if(data.hasOwnProperty(p)) {<br>            void function(p){//一个闭包<br>                //通过属性描述符将用户的对象的属性变成ViewModel实例的具有访问器特性的属性<br>                Object.defineProperty(this,p,{<br>                    get:function(){//当用户使用“aaa.bbb”来访问此属性时调用此函数<br>                        if(typeof data[p] == "object")<br>                            return children[p];<br>                        else return data[p];<br>                    },<br>                    set:function(v){//当用户使用“aaa.bbb = v”进行赋值时调用此函数<br>                        data[p] = v ;<br>                        if(typeof data[p] == "object") {//这里没有必要吧，★★★★处已经写过了<br>                            children[p] = new ViewModel(data[p]);<br>                            children[p].addEventListener("propertyChange",function(e){<br>                                me.dispatchEvent({<br>                                    type:"propertyChange",<br>                                    propertyName:p,<br>                                    path:p+"."+e.path<br>                                });<br>                            })<br>                        }<br>                        //同时向它的订阅者派发此事件，事件对象只是一个普通对象，分别描述事件类型，属性名，与属性路径（即此属性是属于某个属底下）<br>                        this.dispatchEvent({<br>                            type:"propertyChange",<br>                            propertyName:p,<br>                            path:p<br>                        });<br>                    }<br>                });<br>                if(typeof data[p] == "object") {//★★★★如果属性又是一个对象，则递归一下。不过应该判定值为null的情况！<br>                    children[p] = new ViewModel(data[p]);<br>                    //为它的属性绑定propertyChange事件<br>                    children[p].addEventListener("propertyChange",function(e){<br>                        me.dispatchEvent({<br>                            type:"propertyChange",<br>                            propertyName:p,<br>                            path:p+"."+e.path<br>                        });<br>                    })<br>                }<br>            }.call(this,p);<br>        }<br>    }<br>    EventSource.call(this);<br>}<br><p>ArrayViewModel已ViewModel大量小异，就是换一种循环方式：</p><br>function ArrayViewModel(data,parent) {<br>    var me = new Array(data.length);<br>    var children = {};<br>    for(var i = 0; i &lt; data.length; i++) {<br>        void function(p){<br>            Object.defineProperty(this,p,{<br>                get:function(){<br>                    if(typeof data[p] == "object")<br>                        return children[p];<br>                    else return data[p];<br>                },<br>                set:function(v){<br>                    data[p] = v ;<br>                    if(typeof data[p] == "object") {//我还是觉得这里没有必要<br>                        children[p] = new ViewModel(data[p]);<br>                        children[p].addEventListener("propertyChange",function(e){<br>                            me.dispatchEvent({<br>                                type:"propertyChange",<br>                                propertyName:p,<br>                                path:p+"."+e.path<br>                            });<br>                        })<br>                    }<br>                    this.dispatchEvent({<br>                        type:"propertyChange",<br>                        propertyName:p,<br>                        path:p<br>                    });<br>                }<br>            });<br>            if(typeof data[p] == "object") {<br>                children[p] = new ViewModel(data[p]);<br>                children[p].addEventListener("propertyChange",function(e){<br>                    me.dispatchEvent({<br>                        type:"propertyChange",<br>                        propertyName:p,<br>                        path:p+"."+e.path<br>                    });<br>                })<br>            }<br>        }.call(me,i);<br>    }<br>    EventSource.call(me);<br>    return me;<br>}<br><p>我的建议是把它们压缩成这样：</p><br><br>function defineProperty(me, children, data, p){<br>    Object.defineProperty(me, p,{<br>        get:function(){<br>            if(typeof data[p] == "object")<br>                return children[p];<br>            else return data[p];<br>        },<br>        set:function(v){<br>            data[p] = v ;<br>            me.dispatchEvent({<br>                type:"propertyChange",<br>                propertyName:p,<br>                path:p<br>            });<br>        }<br>    });<br>    if(typeof data[p] == "object") {//犹豫要不要识别null<br>        children[p] = new ViewModel(data[p]);<br>        children[p].addEventListener("propertyChange",function(e){<br>            me.dispatchEvent({<br>                type:"propertyChange",<br>                propertyName:p,<br>                path:p+"."+e.path<br>            });<br>        })<br>    }<br>}<br><br>//这个new不new都没所谓!<br>function ArrayViewModel(data,parent) {<br>    var me = new Array(data.length);<br>    for(var i = 0; i &lt; data.length; i++) {<br>        defineProperty(me, {}, data, i);<br>    }<br>    EventSource.call(me);<br>    return me;<br>}<br><br>function ViewModel(data,parent) {<br>    if( Array.isArray(data))<br>        return new ArrayViewModel(data,parent);<br>    for(var p in data) {<br>        if(data.hasOwnProperty(p)) {<br>            defineProperty(this, {}, data, p);<br>        }<br>    }<br>    EventSource.call(this);<br>}<br><p>HTMLTemplate.js，偶表示完全度很低。从源码观察，发现大神都喜欢把所有代码塞到一个构造器中，亚历山大！</p><p>里面有个HTMLTemplate类，传入一个HTML字符串，通过parse，返回一个文档碎片对象，并在体内保留一个parameters对象，等待用户调用它的apply方法，将VM实例传进来，为它绑定propertyChange事件！不过propertyChange只是一个自定义事件，用户在控件上操作还得依赖原生事件，有关如何绑定原生事件，绑定何种原生的事件的指令都写在模板上，它会在parse时分析出来，逐个绑定好！</p><br>&lt;script type=&quot;text/xhtml-template&quot; id=&quot;t&quot;&gt;<br><br>    &lt;div style=&quot;background:rgb(${r},${g},${b});width:100px;height:100px;&quot;&gt;&lt;/div&gt;<br>    &lt;input value=&quot;${r|input}&quot; type=&quot;text&quot;/&gt;<br>    &lt;input value=&quot;${g|input}&quot; /&gt;<br>    &lt;input value=&quot;${b|input}&quot; /&gt;<br><br>&lt;/script&gt;<br><p><strong>${r|input}</strong>这里就是它的指令，通过input事件监听input元素的value值，它对应的是VM的r属性。</p><br><br>function HTMLTemplate(str){<br>    var input = null;<br>    var EOF = {};<br>    var element = null;<br>    var attr = "";<br>    var attributeNode = null;<br>    var state = data;<br>    var text = null;<br>    var tag = "";<br>    var errors = [];<br>    var isEndTag = false;<br>    var stack = [];<br>    var i;<br>    //最有用的三个东东<br>    var attrSetter = null;<br>    var parameterName = null;<br>    var parameters = null;<br><br>    function AttributeSetter(attributeNode) {<br>        this.parts = [];<br>        //用于拼凑成属性值<br>        this.appendPart = function(part){<br>            this.parts.push(part);<br>        }<br>        this.apply = function(){//赋值<br>            attributeNode.value = this.parts.join("");<br>        }<br>    }<br><br>    function consumeCharacterReference(additionalAllowedCharacter){ /*略*/  }<br>    function unconsume(n) { /*略*/  }<br>    function consume(n) { /*略*/   }<br>    function next(n) { /*略*/   }<br>    function error(){<br>    }<br>    function _assert(flag) { /*略*/   }<br>    var data = function(c){/*略*/   };<br><br>    var tagOpen = function(c){ /*略*/ };<br>    var endTagOpen = function(c){ /*略*/  };<br>    var tagName = function(c){ /*略*/    };<br><br>    var beforeAttributeName = function(c){ /*略*/   };<br>    var attributeName = function(c){/*略*/<br>    };<br>    var afterAttributeName = function(c){ /*略*/   };<br>    var beforeAttributeValue = function(c){ /*略*/  };<br>    var attributeValueDQ = function(c){<br>        if(c=="\"") {<br>            if(attrSetter) {//收集属性值碎片<br>                attrSetter.appendPart(attributeNode.value);<br>            }<br>            /*略*/<br>        }<br>        /*略*/<br>    };<br>    var attributeValueSQ = function(c){<br>        if(c=="\'") {<br>            if(attrSetter) {//收集属性值碎片<br>                attrSetter.appendPart(attributeNode.value);<br>            }<br>            /*略*/<br>        }<br>        /*略*/<br>    };<br>    var attributeValueUQ = function(c){<br>        if(c=="\n"||c=="\f"||c=="\t"||c==" ") {<br>            if(attrSetter) {//收集属性值碎片<br>                attrSetter.appendPart(attributeNode.value);<br>            }<br>            /*略*/<br>        }<br>        /*略*/<br>    };<br>    var afterAttributeValueQ = function(c){ /*略*/ };<br>    var selfclosingStartTag = function(c){ /*略*/  };<br>    var afterDollarInText = function(c) { /*略*/  };<br>    var parameterInText = function(c) {/*处理innerText中的指令*/<br>        if(c=="}") {<br>            text = document.createTextNode("");<br>            var name = parameterName.join("")<br>            if(parameters[name])<br>                parameters[name].push(text);//放进parameters中,这只是一个普通的文本节点<br>            else parameters[name] = [text];<br>            element.appendChild(text);<br>            parameterName = [];<br>            text = null;<br>            return data;<br>        }<br>        else {<br>            if(parameterName===null)<br>                parameterName = [];<br>            parameterName.push(c);//拼凑属性名<br>            return parameterInText;<br>        }<br>    }<br>    var afterDollarInAttributeValueDQ = function(c) { /*略*/   }<br>    var afterDollarInAttributeValueSQ = function(c) {/*略*/    }<br>    var afterDollarInAttributeValueUQ = function(c) {/*略*/   }<br>    var parameterInAttributeValueDQ = function(c) {<br>        if(c=="}") {<br>            if(!attrSetter) {<br>                attrSetter = new AttributeSetter(attributeNode);<br>            }<br>            attrSetter.appendPart(attributeNode.value);<br>            attributeNode.value = "";<br>            //这是一个特别的对象,拥有textContent,对textContent操作会引起连锁反应<br>            var text = {<br>                setter:attrSetter,<br>                value:"",<br>                set textContent(v){<br>                    this.value = v;<br>                    this.setter.apply();<br>                },<br>                toString:function(){ return this.value;}<br>            };<br>            var parameterAttr = parameterName.join("").split("|")<br>            var name = parameterAttr[0]<br>            if(parameters[name])//放进parameters中,<br>                parameters[name].push(text);<br>            else parameters[name] = [text];<br>            parameterName = [];<br>            attrSetter.appendPart(text);<br>            text = null;<br><br>            if(parameterAttr[1]) {<br>                void function(element,attributeName){<br>                    //这里是一切的起点,当前属性绑定的宿主,input元素,它个属性绑定都指明要监听的属性与用什么监听<br>                    // &lt;input value=&quot;${r|input}&quot; type=&quot;text&quot;/&gt;<br>                    element.addEventListener(parameterAttr[1],function(){<br>                        console.log("element.value= "+element.value)<br>                        setBack(name,element[attributeName])<br>                    },false);<br>                }(element,attributeNode.name);<br>            }<br><br>            return attributeValueDQ;<br>        }<br>        else {<br>            if(parameterName===null)<br>                parameterName = [];<br>            parameterName.push(c);//拼凑属性名<br>            return parameterInAttributeValueDQ;<br>        }<br>    }<br>    var parameterInAttributeValueSQ = function(c) {/*作用与parameterInAttributeValueDQ差不多*/ }<br>    var parameterInAttributeValueUQ = function(c) {/*作用与parameterInAttributeValueDQ差不多*/ }<br><br>    function parse(){<br>        //开始分析,不过它是由apply调用的<br>        input = str.split("");<br>        input.push(EOF);<br>        var root = document.createDocumentFragment();<br><br>        state = data;<br>        element = root;<br>        stack = [];<br><br>        i = 0;<br>        while(i&lt;input.length) {<br>            state = state(input[i++]);<br>        }<br>        return root;<br>    }<br><br>    var fragment = null;<br>    var setBack = function(){};<br><br>    this.apply = function(obj) {<br>        input = null;<br>        element = null;<br>        attr = "";<br>        attributeNode = null;<br>        state = data;<br>        text = null;<br>        tag = "";<br>        errors = [];<br>        isEndTag = false;<br>        stack = [];<br>        i;<br>        parameters = Object.create(null);<br>        fragment = parse(str);//一个文档碎片<br>        this.bind(obj);<br>        setBack = function(name,value) {<br>            //这里是回调<br>            obj[name] = value;<br>        }<br>        if(obj.addEventListener) {<br>            //obj为一个VM<br>            obj.addEventListener("propertyChange",function(e){<br>                //然后去遍历parameters对象,它每个值是一个text对象<br>                //当我们执行 textNode.textContent = "xxx"时,textContent为一个setter,它会触及其setter成员的apply方法<br>                //setter成员其实是一个AttributeSetter类的实例,apply方法会将它引用的一个特性节点(nodeType=2)的值改变<br>                parameters[e.propertyName].forEach(function(textNode){<br>                    textNode.textContent = obj[e.propertyName];<br>                });<br>            },false);<br>        }<br><br>        return fragment;<br>    };<br>    Object.defineProperty(this,"fragment",{<br>        getter:function(){<br>            return fragment;<br>        }<br>    });<br>    this.bind = function(obj) {<br>        if(fragment==null)<br>            return;<br>        //非常重要的一步,把parse过程中收集好的parameters,通过textContent将VM的值赋上去<br>        Object.keys(parameters).forEach(function(prop,i){<br>            parameters[prop].forEach(function(textNode){<br>                textNode.textContent = obj[prop];<br>            });<br>        });<br>    };<br>}<br><p>单从现在放出的源码，它的功能还是比较薄弱，期待更完整的版本吧！</p><img src="http://www.cnblogs.com/rubylouvre/aggbug/2686634.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/rubylouvre/archive/2012/09/15/2686634.html">本文链接</a></p>