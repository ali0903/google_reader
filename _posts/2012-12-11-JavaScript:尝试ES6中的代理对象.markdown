---
layout: post
title:  "JavaScript:尝试ES6中的代理对象"
date:   2012-12-11 16:29:00
author: 紫云飞
categories: program
---

## JavaScript:尝试ES6中的代理对象
### by 紫云飞
### at 2012-12-11 16:29:00
### original <http://www.cnblogs.com/ziyunfei/archive/2012/12/11/2813049.html>

<p>ES6中的代理(Proxy)对象给了我们自定义对象行为的能力,这个"代理"和网络方面的名词"代理服务器"没有任何关系.你可以先从<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Proxy">MDN</a>上了解一些基础知识,再回来看本文中给的例子.</p><p><strong>索引严格的数组</strong></p><p>在JavaScript中,数组其实就是个对象.因此,在进行一些看似是非法的数组操作时,JavaScript也能正常运行.</p><p>比如,读取一个超大的索引:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> arr =<span style="color:#000000"> [];<br>arr[</span>999999999999999999999999999999999999999999999];   <span style="color:#008000">//</span><span style="color:#008000">"undefined"</span></div><p>再比如,新建一个字符串属性(非法索引):</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> arr =<span style="color:#000000"> [];<br>arr[</span>"foo"] = 1<span style="color:#000000">;  <br>arr[</span>"foo"]          <span style="color:#008000">//</span><span style="color:#008000">1</span></div><p>这些操作都不是一个真正的数组应该有的合法操作.下面我们就利用代理来实现一个自定义的对索引类型和范围严格校验的数组类型MyArray :</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> MyArray = <span style="color:#0000ff">function</span><span style="color:#000000"> () {<br>    </span><span style="color:#0000ff">return</span> <span style="color:#0000ff">new</span> Proxy(Array.apply(<span style="color:#0000ff">null</span><span style="color:#000000">, arguments), {<br>        get: </span><span style="color:#0000ff">function</span><span style="color:#000000"> (target, name) {<br>            </span><span style="color:#0000ff">if</span> (name <span style="color:#0000ff">in</span> target || (+name &gt;= 0 &amp;&amp; +name &lt; 4294967295<span style="color:#000000">)) {<br>                </span><span style="color:#0000ff">return</span><span style="color:#000000"> target[name];<br>            } </span><span style="color:#0000ff">else</span><span style="color:#000000"> {<br>                </span><span style="color:#0000ff">throw</span> "非法索引"<span style="color:#000000">;<br>            }<br>        },<br>        set: </span><span style="color:#0000ff">function</span><span style="color:#000000"> (target, name, val) {<br>            </span><span style="color:#0000ff">if</span> (name <span style="color:#0000ff">in</span> target || (+name &gt;= 0 &amp;&amp; +name &lt; 4294967295<span style="color:#000000">)) {<br>                target[name] </span>=<span style="color:#000000"> val;<br>            } </span><span style="color:#0000ff">else</span><span style="color:#000000"> {<br>                </span><span style="color:#0000ff">throw</span> "非法索引";<span style="color:#000000"><br>            }<br>        }<br>    })<br>}</span></div><p>尝试执行一下:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> arr = MyArray(1,2,3);   <span style="color:#008000">//</span><span style="color:#008000">新建一个自定义数组</span><br>arr;                        <span style="color:#008000">//</span><span style="color:#008000">[1, 2, 3]</span><br>arr.push(4);                <span style="color:#008000">//</span><span style="color:#008000">数组方法也能正常使用</span><br>arr;                        <span style="color:#008000">//</span><span style="color:#008000">[1, 2, 3, 4]</span><br>arr[999999999999]           <span style="color:#008000">//</span><span style="color:#008000">抛出异常,"非法索引"</span><br>arr["foo"] = 1              <span style="color:#008000">//</span><span style="color:#008000">抛出异常,"非法索引"</span></div><p><strong>"继承"多个原型的对象</strong></p><p>在JavaScript中,每个对象都只能有一个直接的上层原型,不能有分支,从而无法实现多重继承.比如:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> foo =<span style="color:#000000"> {<br>    foo: </span><span style="color:#0000ff">function</span><span style="color:#000000"> () {<br>        console.log(</span>"foo"<span style="color:#000000">)<br>    }<br>};<br></span><span style="color:#0000ff">var</span> bar =<span style="color:#000000"> {<br>    bar: </span><span style="color:#0000ff">function</span><span style="color:#000000"> () {<br>        console.log(</span>"bar"<span style="color:#000000">)<br>    }<br>};<br></span><span style="color:#0000ff">var</span> sonOfFoo =<span style="color:#000000"> Object.create(foo);<br>sonOfFoo.foo();     </span><span style="color:#008000">//</span><span style="color:#008000">"foo"</span><br><span style="color:#0000ff">var</span> sonOfBar =<span style="color:#000000"> Object.create(bar);<br>sonOfBar.bar();     </span><span style="color:#008000">//</span><span style="color:#008000">"bar"</span><br>sonOfFooBar = ?     <span style="color:#008000">//怎么才能既有foo方法又有bar方法?</span></div><p>下面我们就利用代理API生成一个同时"继承"两个原型foo和bar的代理对象:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">sonOfFooBar = <span style="color:#0000ff">new</span><span style="color:#000000"> Proxy({}, {<br>    get: </span><span style="color:#0000ff">function</span><span style="color:#000000"> (target, name) {<br>        </span><span style="color:#0000ff">return</span> target[name] || foo[name] ||<span style="color:#000000"> bar[name];<br>    }<br>})<br>sonOfFooBar.foo();   </span><span style="color:#008000">//</span><span style="color:#008000">"foo",有foo方法,继承自对象foo</span><br>sonOfFooBar.bar();   <span style="color:#008000">//</span><span style="color:#008000">"bar",也有bar方法,继承自对象bar</span></div><p><strong>任何属性都包含的对象</strong></p><p>想要检查一个对象是否包含有某个属性(属性值为undefined也算),我们通常使用in运算符.比如:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">0 <span style="color:#0000ff">in</span> [1]    <span style="color:#008000">//</span><span style="color:#008000">true</span><br>"a" <span style="color:#0000ff">in</span> {a:"a"}  <span style="color:#008000">//</span><span style="color:#008000">true</span></div><p>但是我想构建个对象,当in的左操作数为任意值时,它都返回true,这可能吗:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">"我是一个随机字符串" <span style="color:#0000ff">in</span> obj    <span style="color:#008000">//</span><span style="color:#008000">返回true</span></div><p>是的,使用代理对象可以办得到:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> obj = <span style="color:#0000ff">new</span><span style="color:#000000"> Proxy({}, {<br>    has: </span><span style="color:#0000ff">function</span><span style="color:#000000"> () {<br>        </span><span style="color:#0000ff">return</span> <span style="color:#0000ff">true</span><span style="color:#000000">;<br>    }<br>});<br></span>1 <span style="color:#0000ff">in</span> obj;                       <span style="color:#008000">//</span><span style="color:#008000">true</span><br>"hello" <span style="color:#0000ff">in</span> obj;                 <span style="color:#008000">//</span><span style="color:#008000">true</span><br>"妈妈说我的名字再长也存在" <span style="color:#0000ff">in</span> obj;   <span style="color:#008000">//</span><span style="color:#008000">true</span></div><p>当然,这只是表象,其实这个代理对象一个自身属性也没有.</p><p><strong>其他</strong></p><p>本文只举了set,get,has这三种trap的例子,其实还有其他十几种trap.你可以利用它们实现一些以前不可能实现的效果.本文中的例子都可以在最新版的Firefox中运行.如果你还想进一步了解Proxy的相关知识,<a href="http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies">ES wiki</a>上有你想要的.</p><img src="http://www.cnblogs.com/ziyunfei/aggbug/2813049.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/ziyunfei/archive/2012/12/11/2813049.html">本文链接</a></p>