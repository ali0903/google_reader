---
layout: post
title:  "我的MVVM框架  v1发布"
date:   2012-09-15 10:14:00
author: 司徒正美
categories: program
---

## 我的MVVM框架  v1发布
### by 司徒正美
### at 2012-09-15 10:14:00
### original <http://www.cnblogs.com/rubylouvre/archive/2012/09/15/2685951.html>

<p>如果经常浏览我博客的人就发现，我三个月前就搞鼓过一下什么MVVM与MVC的比较，knockout.js与ember.js。然后就没动静了，因为之后一个月，我的MVVM就孵化出来，开发代码很逆天也很龌鹾，就叫avalon(WPF开发代号)。我觉得，都是好东西，相互借鉴是没所谓，只要造福IT民工！</p><p>说说MVVM的重要性，它虽然是从MVC中衍生出来的，但其双向绑定机制是特有的，完全是面向界面开发而生，这是传统的MVC比不了。最近我拉了一伙人在搞我的mass UI就遇到这问题了。</p><br>//由mass UI开发团队的Hodor 提供<br>define('panel',[<br>'$node',<br>'$event',<br>'$css',<br>'$flow',<br>'./ejs'<br>], function(){<br>$.ui = $.ui||{}<br> var defaults = {<br> showHead: true,<br> showFoot: true,<br> closeAble : true,<br> parent: 'body',<br> content : {<br> title : 'title',<br> body  : 'body',<br> foot  : ''<br> },<br> css : {<br> width: 400,<br> height: 200<br> }<br> };<br>$.ui.Panel = $.factory({<br>        inherit: $.Flow,<br>        init: function(opts) {<br>        this.setOptions ("data", defaults, opts )<br>        var self = this;<br>        self.template = $.ejs.compile(<br>            &#39;&lt;div class=&quot;panel_wrap&quot;&gt;\<br>                &lt;% if( data.showHead ){ %&gt;\<br>                &lt;div class=&quot;panel_header&quot;&gt;\<br>                    &lt;div class=&quot;panel_title&quot;&gt;\<br>                    &lt;%= data.content.title %&gt;\<br>                    &lt;/div&gt;\<br>                    &lt;% if( data.closeAble ){ %&gt;\<br>                    &lt;span class=&quot;panel_closer&quot;&gt;&lt;/span&gt;\<br>                    &lt;% } %&gt;\<br>                &lt;/div&gt;\<br>                &lt;% } %&gt;\<br>                &lt;div class=&quot;panel_body&quot;&gt;\<br>                &lt;%= data.content.body %&gt;\<br>                &lt;/div&gt;\<br>                &lt;% if( data.showFoot ){ %&gt;\<br>                &lt;div class=&quot;panel_foot&quot;&gt;\<br>                &lt;%= data.content.foot %&gt;\<br>                &lt;/div&gt;\<br>                &lt;% } %&gt;\<br>            &lt;/div&gt;&#39;);<br>           self.show();<br>        },<br>        show : function() {<br>            this.fire ( 'beforeshow' )<br>            this.ui &amp;&amp; this.ui.remove();<br>        this.ui = $(this.template( this.data ))<br>            .appendTo( this.parent )<br>            .css     ( this.css    )<br>            .show    ();<br>            this.fire ( 'show' )<br>        },<br>        hide : function() {<br>        this.ui &amp;&amp; this.ui.hide().remove();<br>        this.ui = undefined;<br>            this.fire ( 'hide' );<br>        },<br>        set : function( keyChain, val ) {//每改一个属性就重刷整个视图，因此不能容纳子控件,除非我们多做一些额外工作<br>    var keys = keyChain.split('.');<br>    var key;<br>    var ret = this;<br>    while( keys.length &gt; 1){<br>    key = keys.shift();<br>    ret[key] = ret[key] != undefined ? <br>       ret[key] :<br>       {};<br>    ret = ret[key];<br>    }<br>    ret[keys.shift()] = val;<br>    this.show();<br>    return this;<br>}<br>    });<br>})<br><p>遇到的问题与其他UI团队一样，其实你看一下jquery UI就知了。一个控件，它肯定有视图层，这里我们是用<a href="http://www.cnblogs.com/rubylouvre/archive/2012/08/06/2624970.html">ejs v10</a>来生成。生成HTML插入到DOM算是完成了一半，但当我们要修改这个控件的一些属性，一些与视图相关的属性就遇到麻烦了。比如说title属性，如果是jquery ui，它肯定先到这个控件的ID，然后再找包含这个title的元素节点，再替换掉它的文本。用jquery是这样写出：</p><br> setTilte: function(newTitle){<br>     $(this.UIid).find("jquery-panel-title").text(newTitle);//更新视图<br>     this.title = newTitle;//同时同步对应的属性<br> }<br> getTitle: function(){<br>     return this.title;<br> }<br><p>如果一个控件涉及的视图属性越多，控件这样的访问器就越多！长此以往不是办法！像日历组件，你可以看到它是多么臃肿。</p><p>这时该到MVVM出马了。它把这些与视图显示相关的属性全部收集到一起，包括基于这些属性的属性，比如说fullName是基于lastName与firstName，它是通过函数生成的，这个在模型（M）里是不存在的，但它存于视图模型（VM）中。由于双向绑定的存在，我们修改了VM的一个值，它立即自动刷新视图中对应的位置的值，这过程完全不需要动用到选择器！</p><p>基于选择器的方式是最不可靠的，因为视图的变更最频繁，某一天PM说要多加一功能或不要一功能，于是就多几个父节点或少几个子节点，把HTML的层级关系搞得乱七八糟，我们的选择器寻找就得重写一次！</p><p>因此对于这些DOM操作，我们最好也封装一层，这是比jquery的DOM操作函数更高层的封装，目的是让控件开发者远离视图层，他们只需要关注于模型层。如果我们把DOM操作看成增删改查，那么原始的DOM API相当于直接用二进制手段暴力去改数据库，而像jQuery等主流库提供了强大的选择器引擎与DOM操作函数，相当于发明SQL，而像knockout.js这样的MVVM框架拥有尖端的依赖链机制、双向绑定，让智能的集化操作，事务与锁成为可能，是DOM级别的“ORM系统”！</p><p>顺便一提，在VM中，所有属性都是函数，每个函数都是读写结合，像jquery的html, attr, text那样便捷！这有出于兼容IE678的考量，因为它们不支持Object.defineProperty这样的属性描述符（或支持不良好，如IE8）。</p><p>我的MVVM   v1完全是向knockout.js致敬的，用法与它的一模一样，不过代码量少了许多。具体教程与实可以看以下链接：</p><ul>   <li><a href="https://github.com/RubyLouvre/mass-Framework/issues/17">MVVM模式的实践——avalon模块</a></li>   <li><a href="https://github.com/RubyLouvre/mass-Framework/issues/18">avalon模块：依赖链</a></li>   <li><a href="https://github.com/RubyLouvre/mass-Framework/issues/19">avalon模块的内建适配器</a></li></ul><p>最近看了许多MVVM的实现，功力大增，估计v2秒换胎脱骨，更精简更高效，敬请期待！</p><br><br>define("avalon",["data","attr","event","fx"], function(){<br>    /* JS UI Component 最终还是通过 HTML 来描述界面，当 js object 的数据发生变化或者执行某个动作时，<br>    需要通知到对应的html，使其发生相应变化。于是js object 需要得到他在页面上对应的html的句柄，<br>    通常做法，是在创建html的时候将createElement返回的句柄保存在js object 内部的某个变量中，<br>    或者赋值给html eLement一个唯一的ID，js object 根据这个ID来找到对应的HTML Element。同样，<br>    当htm elementl的事件（例如onclick）要通知到相对应的 js object 或者回调js object的某个<br>    方法或属性时，也需要得到该js object的一个引用。我的意思是建立一种统一的规则，js object<br>    和他相对应的 html 能通过这种规则互相访问到对方。 建立这个关联以后，实现js object和<br>    对应 html 的数据邦定和数据同步等问题就简单多了<br>     */<br><br>    var disposeObject = {}<br>    var cur, ID = 1;<br>    var registry = {}<br>    var dependent = {}<br><br>    var fieldFns = {<br>        ensure : function(d){<br>            if(this.list.indexOf(d) == -1){<br>                this.list.push(d);<br>            }<br>        },<br>        lock : function(){<br>            this.locked = true;<br>        },<br>        unlock : function(){<br>            delete this.locked;<br>        },<br>        notify : function(){//通知依赖于field的上层$.computed更新<br>            var list = this.list || [] ;<br>            if( list.length ){<br>                var safelist = list.concat(), dispose = false<br>                for(var i = 0, el; el = safelist[i++];){<br>                    delete el.cache;//清除缓存<br>                    if(el.locked === true)<br>                        break<br>                    if(el.dispose === true || el() == disposeObject ){//通知顶层的computed更新自身<br>                        el.dispose = dispose = true<br>                    }<br>                }<br>                if( dispose == true ){//移除无意义的绑定<br>                    for (  i = list.length; el = list[ --i ]; ) {<br>                        if( el.dispose == true ){<br>                            el.splice( i, 1 );<br>                        }<br>                    }<br>                }<br>            }<br>        }<br>    }<br>    $.avalon = {<br>        //为一个Binding Target(节点)绑定Binding Source(viewModel)<br>        setBindings: function( source, node ){<br>            node = node || document.body; //确保是绑定在元素节点上，没有指定默认是绑在body上<br>            //开始在其自身与孩子中绑定<br>            return setBindingsToElementAndChildren( node, source, true );<br>        },<br>        //取得节点的数据隐藏<br>        hasBindings: function( node ){<br>            var str = node.getAttribute( "data-bind" );<br>            return typeof str === &quot;string&quot; &amp;&amp; str.indexOf(&quot;:&quot;) &gt; 1<br>        },<br>        //将字符串变成一个函数<br>        evalBindings: function(expression, level){<br>            var body = "return (" + expression + ")";<br>            for (var i = 0; i &lt; level; i++) {<br>                body = "with(sc[" + i + "]) { " + body + " } ";<br>            }<br>            return  Function( "sc", body );<br>        },<br>        //转换数据隐藏为一个函数<br>        parseBindings : function( node, context ){<br>            var jsonstr = $.normalizeJSON( node.getAttribute("data-bind"), true, context );<br>            var fn = $.avalon.evalBindings( jsonstr, 2 );//限制为两层，减少作用链的长度<br>            return fn;<br>        },<br>        //开始收集依赖<br>        detectBegin: function( field ){<br>            var uuid = $.avalon.register( field )<br>            if( cur ){<br>                cur[uuid] = field<br>            }<br>            //用于收集依赖<br>            var prev = cur;<br>            cur = dependent[uuid];<br>            cur.prev = prev<br>        },<br>        //添加依赖到链中<br>        detectAdd: function( field ){<br>            if(cur){<br>                var uuid = $.avalon.register( field )<br>                cur[ uuid ] = field;<br>            }<br>        },<br>        //结束依赖收集<br>        detectEnd: function( field ){<br>            var deps = dependent[ field.observableID ] || {};<br>            cur = deps.prev;<br>            for(var key in deps){<br>                if(deps.hasOwnProperty(key) &amp;&amp; (key != &quot;prev&quot;)){<br>                    var low = registry[ key ];<br>                    low.ensure(field)<br>                }<br>            }<br>        },<br>        //注册依赖<br>        register: function( field ){<br>            var uuid = field.observableID<br>            if(!uuid || !registry[uuid] ){<br>                field.observableID  = uuid = "observable" +(++ID);<br>                registry[uuid] = field;//供发布者使用<br>                dependent[uuid] = {};//收集依赖<br>                field.list = []<br>                $.mix(field, fieldFns);<br>            }<br>            return uuid;<br>        }<br>    }<br><br>    $.observable = function( val ){<br>        var cur = val;<br>        function field( neo ){<br>            $.avalon.detectAdd(field)<br>            if( arguments.length ){//setter<br>                if(cur !== neo ||  Array.isArray(cur)  ){<br>                    cur = neo;<br>                    field.notify()<br>                }<br>            }else{//getter<br>                return cur;<br>            }<br>        }<br>        field.toString = field.valueOf = function(){<br>            return cur;<br>        }<br>        field();<br>        return field;<br>    }<br>   <br>    $.computed = function( obj, scope ){<br>        var getter, setter, cur//构建一个至少拥有getter,scope属性的对象<br>        if(typeof obj == "function"){//getter必然存在<br>            getter = obj<br>        }else if( typeof obj == &quot;object&quot; &amp;&amp; obj ){<br>            getter = obj.getter<br>            setter = obj.setter;<br>            scope =  obj.scope;<br>        }<br>        function field( neo ){<br>            if( arguments.length ){<br>                if(typeof setter === "function"){<br>                    field.lock()<br>                    //setter会唤起其依赖的$.observable与$.computed重新计算自身，但它们也会触发其上级更新自身<br>                    //由于自身已经先行更新了，没有再计算一次<br>                    neo = setter.apply( scope, arguments );<br>                    field.unlock()<br>                }<br>            }else{<br>                if( "cache" in field ){//getter<br>                    neo = field.cache;//从缓存中读取,防止递归读取<br>                }else{<br>                    neo = getter.call( scope );<br>                    field.cache = neo;//保存到缓存<br>                }<br>            }<br>            if(cur !== neo || Array.isArray(cur) &amp;&amp; (JSON.stringify(cur) != JSON.stringify(neo)) ){<br>                cur = neo<br>                field.notify()<br>            }<br>            return cur;<br>        }<br>        field.toString = field.valueOf = function(){<br>            return cur;<br>        }<br>        $.avalon.detectBegin( field )<br>        field();<br>        $.avalon.detectEnd( field )<br>        return field;<br>    }<br>    $.observableArray = function(array){<br>        if(!arguments.length){<br>            array = []<br>        }else if(!Array.isArray){<br>            throw "$.observableArray arguments must be a array"<br>        }<br>        var field = $.observable(array);<br>        makeObservableArray(field);<br>        return field;<br>    }<br>    function makeObservableArray( field ){<br>        ("pop,push,shift,unshift,slice,splice,sort,reverse,remove,removeAt").replace( $.rword, function( method ){<br>            field[method] = function(){<br>                var array = this(), n = array.length<br>                Array.prototype.unshift.call(arguments, array);<br>                $.Array[method].apply( $.Array, arguments );<br>                if( /sort|reverse|splice/.test(method) ){<br>                    field.notify()<br>                }else if( array.length != n  ){<br>                    field.notify()<br>                }<br>            }<br>        });<br>    }<br>    //template - name<br>    //foreach - data<br>    //value - data<br>    //options - data<br>    //event - handler<br>    //MVVM三大入口函数之一<br>    $.applyBindings = $.setBindings = $.avalon.setBindings;<br>    var parseBindings = $.avalon.parseBindings;<br>    //dataFor与contextFor是为事件的无侵入绑定服务的<br>    $.contextFor = function(node) {<br>        switch (node.nodeType) {<br>            case 1:<br>                var context = $._data(node,"bindings-context");<br>                if (context) return context;<br>                if (node.parentNode) return $.contextFor(node.parentNode);<br>                break;<br>            case 9:<br>                return void 0<br>        }<br>        return void 0;<br>    };<br>    $.dataFor = function(node) {<br>        var context = $.contextFor(node);<br>        return context ? context['$data'] : void 0;<br>    };<br>    //在元素及其后代中将数据隐藏与viewModel关联在一起<br>    function setBindingsToElementAndChildren( node, source, setData ){<br>        if ( node.nodeType === 1  ){<br>            var continueBindings = true;<br>            if( $.avalon.hasBindings( node ) ){<br>                continueBindings = setBindingsToElement(node, source, setData ) <br>            }<br>            if( continueBindings ){<br>                var elems = getChildren( node )<br>                elems.length &amp;&amp; setBindingsToChildren( elems, source, setData )<br>            }<br>        }<br>    }<br>    //viewModel类<br>    $.viewModel = function(current, parent){<br>        $.mix( this,current );<br>        if ( parent) {<br>            $.mix( this, parent );<br>            this['$parentContext'] = parent;<br>            this['$parent'] = parent['$data'];<br>            this['$parents'] = (parent['$parents'] || []).slice(0);<br>            this['$parents'].unshift( this['$parent'] );<br>        } else {<br>            this['$parents'] = [];<br>            this['$root'] = current;<br>        }<br>        this['$data'] = current;<br>    }<br>    $.viewModel.prototype = {<br>        extend : function(source){<br>            return $.mix( this,source )<br>        },<br>        alias: function( neo, old){<br>            if(this[ neo ]){<br>                this[ this[neo] ] = this[old]<br>            }<br>            return this;<br>        }<br>    }<br>    //为当前元素把数据隐藏与视图模块绑定在一块<br>    function setBindingsToElement( node, context, setData ){<br>        //如果bindings不存在，则通过getBindings获取，getBindings会调用parseBindingsString，变成对象<br>        var callback = parseBindings( node, context )//保存到闭包中<br>        context = context instanceof $.viewModel ? context : new $.viewModel( context );<br>        if( setData ){<br>            $._data(node,"bindings-context",context)<br>        }<br>        var getBindings = function(){//用于取得数据隐藏<br>            try{<br>                return callback( [ node, context ] )<br>            }catch(e){<br>                $.log(e)<br>            }<br>        }<br>        var bindings = getBindings();<br>        var continueBindings = true;<br>        for(var key in bindings){<br>            var adapter = $.bindingAdapter[key];<br>            if( adapter ){<br>                if( adapter.stopBindings ){<br>                    continueBindings = false;<br>                }<br>                associateDataAndUI( node, bindings[key], context, key, getBindings)<br>            }<br>        }<br>        return continueBindings;<br>    }<br>    //setBindingsToChildren的第三第四参数是为了实现事件的无侵入绑定<br>    function setBindingsToChildren(elems, context, setData, force){<br>        for(var i = 0, n = elems.length; i &lt; n ; i++){<br>            var node = elems[i]<br>            setBindingsToElementAndChildren( node, context, setData &amp;&amp; !force );<br>            if( setData &amp;&amp; force ){//这是由foreach绑定触发<br>                $._data(node,"bindings-context", context)<br>            }<br>        }<br>    }<br>    //有一些域的依赖在定义vireModel时已经确认了<br>    //而对元素的操作的$.computed则要在bindings中执行它们才知<br>    function associateDataAndUI(node, field, context, key, getBindings){<br>        var adapter = $.bindingAdapter[key], initPhase = 0, cur;<br>        function symptom(){//这是依赖链的末梢,通过process操作节点<br>            if(!node){<br>                return disposeObject;//解除绑定<br>            }<br>            if(typeof field !== "function"){<br>                var bindings = getBindings();//每次都取一次,因为viewModel的数据已经发生改变<br>                field = bindings["@mass_fields"][key];<br>            }<br>            if(initPhase === 0){<br>                cur = field();<br>                adapter.init &amp;&amp; adapter.init(node, cur, field, context, symptom);<br>            }<br>            var neo = field();<br>            if( key == "case"){//这个应该如何处理更好呢?<br>                if(field  === context.$switch){//$default;<br>                    neo = !context.$switch.not;<br>                }else{<br>                    //如果前面有一个通过,那么它将不会进入$default分支;<br>                    neo = context.$switch() == neo;<br>                    if( neo ){<br>                        context.$switch.not = true;<br>                    }<br>                }<br>            }<br>            if(initPhase === 0 ||  cur != neo || Array.isArray(cur)   ){//只要是处理bool假值的比较<br>                cur = neo;<br>                adapter.update &amp;&amp; adapter.update(node, cur, field, context, symptom);<br>            }<br>            initPhase = 1;<br>        }<br>      <br>        $.computed( symptom, context.$data );<br>    }<br>    var inputOne = $.oneObject("text,password,textarea,tel,url,search,number,month,email,datetime,week,datetime-local")<br>    //一个数据绑定，负责界面的展示，另一个是事件绑定，负责更高层次的交互，比如动画，数据请求，<br>    //从现影响viewModel，导致界面的再渲染<br>    $.bindingAdapter = {<br>        text: {<br>            update:  function( node, val ){<br>                val = val == null ? "" : val+""<br>                if(node.childNodes.length === 1 &amp;&amp; node.firstChild.nodeType == 3){<br>                    node.firstChild.data = val;<br>                }else{<br>                    $( node ).text( val );<br>                }<br>            }<br>        },<br>        value:{<br>            init: function(node, val, field){<br>                node.value = val;<br>                if(/input|textarea/i.test(node.nodeName) &amp;&amp; inputOne[node.type]){<br>                    $(node).on("input",function(){<br>                        field(node.value)<br>                    });<br>                }<br>               <br>            }<br>        },<br>        html: {<br>            update:  function( node, val ){<br>                $( node ).html( val )<br>            },<br>            stopBindings: true<br>        },<br>        visible: {<br>            update:  function( node, val ){<br>                node.style.display = val ? "" : "none";<br>            }<br>        },<br>        enable: {<br>            update:  function( node, val ){<br>                if (val &amp;&amp; node.disabled)<br>                    node.removeAttribute("disabled");<br>                else if ((!val) &amp;&amp; (!node.disabled))<br>                    node.disabled = true;<br>            }<br>        },<br><br>        "class": {<br>            update:  function( node, val ){<br>                if (typeof val == "object") {<br>                    for (var className in val) {<br>                        var shouldHaveClass = val[className];<br>                        toggleClass(node, className, shouldHaveClass);<br>                    }<br>                } else {<br>                    val = String(val || '');<br>                    toggleClass(node, val, true);<br>                }<br>            }<br>        } ,<br>        // { text-decoration: someValue }<br>        // { color: currentProfit() &lt; 0 ? &#39;red&#39; : &#39;black&#39; }<br>        style: {<br>            update:  function( node, val ){<br>                var style = node.style, styleName<br>                for (var name in val) {<br>                    styleName = $.cssName(name, style) || name<br>                    style[styleName] = val[ name ] || "";<br>                }<br>            }<br>        },<br>        attr: {<br>            update:  function( node, val ){<br>                for (var name in val) {<br>                    $.attr(node, name, val[ name ] )<br>                }<br>            }<br>        },<br>        click: {<br>            init: function( node, val, field, context ){<br>                $(node).bind("click",function(e){<br>                    field.call( context, e )<br>                });<br>            }<br>        },<br>        "switch":{<br>            init:function( node, val, field, context){<br>                context.$switch = field;<br>                context.$default = field<br>                setBindingsToChildren( node.childNodes, context )<br>            },<br>            update:function(node, val, field, context){<br>                delete context.$switch.not;//每次都清空它<br>            },<br>            stopBindings: true<br>        },<br>        checked: {<br>            init:  function( node, val, field, context ){<br>                if(context.$hoist &amp;&amp; context.$hoist.nodeType == 1 ){<br>                    var expr =  node.tagName +"['data-bind'="+node.getAttribute("data-bind") +"]";<br>                    context.$hoisting &amp;&amp; $(context.$hoist).delegate( expr,&quot;change&quot;, function(){<br>                        field(node.checked);<br>                    });<br>                }else{<br>                    $(node).bind("change",function(){<br>                        field(node.checked);<br>                    });<br>                }<br>            },<br>            update:function(node, val ){<br>                if ( node.type == "checkbox" ) {<br>                    if (Array.isArray( val )) {<br>                        node.checked = val.indexOf(node.value) &gt;= 0;<br>                    } else {<br>                        node.checked = val;<br>                    }<br>                } else if (node.type == "radio") {<br>                    node.checked = ( node.value == val );<br>                }<br>            }<br>        }<br>    }<br>    //if unless with foreach四种bindings都是使用template bindings<br>    "if,unless,with,foreach,case".replace($.rword, function( type ){<br>        $.bindingAdapter[ type ] = {<br>            update : function(node, val, field, context, symptom){<br>                if(type == &quot;case&quot; &amp;&amp; (typeof context.$switch != &quot;function&quot; )){<br>                    throw "Must define switch statement above all";<br>                }<br>                $.bindingAdapter['template']['update'](node, val, function(){<br>                    switch(type){//返回结果可能为 -1 0 1 2<br>                        case "case":<br>                        case "if":<br>                            return !!val - 0;//1<br>                        case "unless":<br>                            return !val - 0;//0<br>                        case "with":<br>                            return 2;//2<br>                        default:<br>                            return -1;<br>                    }<br>                }, context, symptom);<br>            },<br>            stopBindings: true<br>        }<br>    });<br><br><br><br>    var Tmpl = function(t){<br>        this.template = t<br>        this.nodes = $.slice(t.childNodes)<br>    }<br>    Tmpl.prototype.recovery = function(){<br>        this.nodes.forEach(function( el ){<br>            this.template.appendChild(el)<br>        },this);<br>        return this.template<br>    }<br><br>    $.bindingAdapter[ "template" ] = {<br>        update: function(node, data, field, context, symptom){<br>            var ganso = symptom.ganso//取得最初的那个节点的内部作为模块<br>            if( !symptom.ganso ){//缓存,省得每次都创建<br>                //合并文本节点数<br>                node.normalize();<br>                //保存模板<br>                ganso = node.ownerDocument.createDocumentFragment();<br>                while((el = node.firstChild)){<br>                    ganso.appendChild(el)<br>                }<br>                symptom.ganso = ganso;<br>                //复制一份出来放回原位<br>                var first = ganso.cloneNode(true);<br>                symptom.references = [ new Tmpl( first ) ];//先取得nodes的引用再插入DOM树<br>                node.appendChild( first );<br>                symptom.prevData = [{}];//这是伪数据，目的让其update<br>                <br>            }<br>            //  console.log("===============")<br>            var code = field(),  el;<br>            first = symptom.references[0];<br>            // console.log(code)<br>            if( code &gt; 0 ){ //处理with if bindings<br>                template = first.recovery();<br>                var elems = getChildren( template );<br>                node.appendChild( template );  //显示出来<br>                if( elems.length ){<br>                    if( code == 2 ){//处理with bindings<br>                        context = new $.viewModel( data, context )<br>                    }<br>                    return setBindingsToChildren( elems, context, true )<br>                }<br>            }else if( code == 0){//处理unless bindings<br>                first.recovery();<br>            }<br>            if( code &lt; 0  &amp;&amp; data &amp;&amp; isFinite(data.length) ){//处理foreach bindings<br>                var scripts = getEditScripts( symptom.prevData, data, true ), hasDelete<br>                //obj必须有x,y<br>                for(var i = 0, n = scripts.length; i &lt; n ; i++){<br>                    var obj = scripts[i], tmpl = false;<br>                    switch(obj.action){<br>                        case "update":<br>                            tmpl = symptom.references[ obj.x ];//这里要增强<br>                            break;<br>                        case "add":<br>                            tmpl =  new Tmpl( ganso.cloneNode(true) );<br>                            symptom.references.push( tmpl );<br>                            break;<br>                        case "retain":<br>                            //如果发生删除操作，那么位于删除元素之后的元素的索引值会发生改变<br>                            //则重置它们<br>                            if(obj.x !== obj.y){<br>                                tmpl = symptom.references[ obj.x ];<br>                                tmpl.index(obj.y);<br>                                tmpl = null;<br>                            }<br>                            break;<br>                        case "delete":<br>                            tmpl = symptom.references[ obj.y ];<br>                            $(tmpl.nodes).remove();<br>                            hasDelete = tmpl.destroy = true;<br>                            tmpl = null;<br>                            break;<br>                    };<br>                    if(tmpl){<br>                      <br>                        (function( k, tmpl ){<br>                            var template = tmpl.template<br>                            if(!template.childNodes.length){<br>                                tmpl.recovery();//update<br>                            }<br>                            tmpl.index = $.observable(k)<br>                            var subclass = new $.viewModel( data[ k ], context);<br>                            subclass.extend( {<br>                                $index:  tmpl.index<br>                            // $item: data[ k ]<br>                            } )<br>                            //                            .alias("$itemName", "$data")<br>                            //                            .alias("$indexName", "$index");<br>                               <br>                            elems = getChildren( template );<br>                            node.appendChild( template );<br>                            if(elems.length){<br>                                setBindingsToChildren(elems, subclass, true, true );<br>                            }<br>                        })(obj.y || 0, tmpl);<br>                    }<br>                }<br>                symptom.prevData = data.concat();<br>                if(hasDelete){<br>                    symptom.references = symptom.references.filter(function(el){<br>                        return !el.destroy<br>                    })<br>                };<br>               <br>            }<br>            return void 0<br>        },<br>        stopBindings: true<br>    }<br><br>    $.bindingAdapter.disable = {<br>        update: function( node, val ){<br>            $.bindingAdapter.enable.update(node, !val);<br>        }<br>    }<br>    var getChildren = function(node){<br>        var elems = [] ,ri = 0;<br>        for (node = node.firstChild; node; node = node.nextSibling){<br>            if (node.nodeType === 1){<br>                elems[ri++] = node;<br>            }<br>        }<br>        return elems;<br>    }<br>    $.bindingAdapter["css"] = $.bindingAdapter["class"]<br>    var toggleClass = function (node, className, shouldHaveClass) {<br>        var classes = (node.className || "").split(/\s+/);<br>        var hasClass = classes.indexOf( className) &gt;= 0;//原className是否有这东西<br>        if (shouldHaveClass &amp;&amp; !hasClass) {<br>            node.className += (classes[0] ? " " : "") + className;<br>        } else if (hasClass &amp;&amp; !shouldHaveClass) {<br>            var newClassName = "";<br>            for (var i = 0; i &lt; classes.length; i++)<br>                if (classes[i] != className)<br>                    newClassName += classes[i] + " ";<br>            node.className = newClassName.trim();<br>        }<br>    }<br><br>    var getEditScripts = (function () {<br>        // 一个简单的Levenshtein distance算法<br>        //编辑距离就是用来计算从原串（s）转换到目标串(t)所需要的最少的插入，删除和替换的数目，<br>        //在NLP中应用比较广泛，如一些评测方法中就用到了（wer,mWer等），同时也常用来计算你对原文本所作的改动数。<br>        //http://www.cnblogs.com/pandora/archive/2009/12/20/levenshtein_distance.html<br>        //https://gist.github.com/982927<br>        //http://www.blogjava.net/phyeas/archive/2009/01/10/250807.html<br>        //通过levenshtein distance算法返回一个矩阵，matrix[y][x]为最短的编辑长度<br>        var getEditDistance = function(from, to, table){<br>            var matrix = [], fn = from.length, tn = to.length;<br>            // 初始化一个矩阵,行数为b,列数为a<br>            var i, j, td;<br>            for(i = 0; i &lt;= tn; i++){<br>                matrix[i] = [i];//设置第一列的值<br>                table &amp;&amp; table.insertRow(i)<br>            }<br>            for(j = 0; j &lt;= fn; j++){<br>                matrix[0][j] = j;//设置第一行的值<br>                if(table){<br>                    for(i = 0; i &lt;= tn; i++){<br>                        td = table.rows[i].insertCell(j);<br>                        if(isFinite(matrix[i][j])){<br>                            td.innerHTML = matrix[i][j];<br>                            td.className = "zero";<br>                        }<br>                    }<br>                }<br>            }<br>            // 填空矩阵<br>            for(i = 1; i &lt;= tn; i++){<br>                for(j = 1; j &lt;= fn; j++){<br>                    if( to[i-1] == from[j-1] ){<br>                        matrix[i][j] = matrix[i-1][j-1];//保留<br>                    } else {<br>                        matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, //更新<br>                            matrix[i][j-1] + 1, // 插入<br>                            matrix[i-1][j] + 1); //删除<br>                    }<br>                    if(table){<br>                        td = table.rows[i].cells[j];<br>                        td.innerHTML = matrix[i][j];<br>                    }<br>                }<br>            }<br>            $.log(matrix.join("\n"));<br>            return matrix;<br>        };<br>        //返回具体的编辑步骤<br>        var _getEditScripts = function(from, to, matrix, table){<br>            var x = from.length, y = to.length, scripts = [], _action;<br>            if(x == 0 || y == 0){//如果原数组为0,那么新数组的都是新增的,如果新数组为0,那么我们要删除所有旧数组的元素<br>                var n =  Math.max(x,y), action = x == 0 ? "add" : "delete";<br>                for( var i = 0; i &lt; n; i++ ){<br>                    scripts[scripts.length] = {<br>                        action: action,<br>                        x: i,<br>                        y: i<br>                    }<br>                }<br>            }else{<br>                while( 1 ){<br>                    var cur = matrix[y][x];<br>                    if( y == 0 &amp;&amp; x == 0){<br>                        break;<br>                    }<br>                    var left = matrix[y][x-1]<br>                    var diagon = matrix[y-1][x-1];<br>                    var top = matrix[y-1][x];<br>                    action = &quot;retain&quot;//top == left &amp;&amp; cur == diagon<br>                    var min = Math.min(top, diagon, left);<br>                    var td =  table &amp;&amp; (table.rows[y].cells[x]);<br>                    x--;<br>                    y--;<br>                    if( min &lt; cur ){<br>                        switch(min){<br>                            case top:<br>                                action = "add";<br>                                x++;<br>                                break;<br>                            case left:<br>                                action = "delete";<br>                                y++;<br>                                break;<br>                            case diagon:<br>                                action = "update";<br>                                if(_action){<br>                                    action = _action;<br>                                    _action = false;<br>                                }<br>                                break;<br>                        }<br>                    } else{<br>                        switch(min){<br>                            case top:<br>                                _action = "add";<br>                                x++;<br>                                break;<br>                            case left:<br>                                _action = "delete";<br>                                y++;<br>                                break;<br>                        }<br>                    }<br>                    if(table){<br>                        td.className = action;<br>                    }<br>                    scripts[scripts.length] = {<br>                        action:action,<br>                        x:x,<br>                        y:y<br>                    }<br>                }<br>            }<br>            scripts.reverse();<br>            return scripts<br>        }<br><br>        return function( old, neo, debug ){<br>            if(debug){<br>                debug = document.createElement("table");<br>                document.body.appendChild(debug);<br>                debug.className = "compare";<br>            }<br>            var matrix = getEditDistance( old, neo, debug );<br>            return _getEditScripts( old, neo, matrix, debug );<br>        }<br>    })();<br><br>    //normalizeJSON及其辅助方法与变量<br>    void function(){<br>        var restoreCapturedTokensRegex = /\@mass_token_(\d+)\@/g;<br>        function restoreTokens(string, tokens) {<br>            var prevValue = null;<br>            while (string != prevValue) { // Keep restoring tokens until it no longer makes a difference (they may be nested)<br>                prevValue = string;<br>                string = string.replace(restoreCapturedTokensRegex, function (match, tokenIndex) {<br>                    return tokens[tokenIndex];<br>                });<br>            }<br>            return string;<br>        }<br>        //https://github.com/SteveSanderson/knockout/wiki/Asynchronous-Dependent-Observables 伟大的东西<br>        //https://github.com/rniemeyer/knockout-kendo 一个UI库<br>        //https://github.com/mbest/js-object-literal-parse/blob/master/js-object-literal-parse.js<br>        function parseObjectLiteral(objectLiteralString) {<br>            var str = objectLiteralString.trim();<br>            if (str.length &lt; 3)<br>                return [];<br>            if (str.charAt(0) === "{")// 去掉最开始{与最后的}<br>                str = str.substring(1, str.length - 1);<br>            // 首先用占位符把字段中的字符串与正则处理掉<br>            var tokens = [];<br>            var tokenStart = null, tokenEndChar;<br>            for (var position = 0; position &lt; str.length; position++) {<br>                var c = str.charAt(position);//IE6字符串不支持[],开始一个个字符分析<br>                if (tokenStart === null) {<br>                    switch (c) {<br>                        case '"':<br>                        case "'":<br>                        case "/":<br>                            tokenStart = position;//索引<br>                            tokenEndChar = c;//值<br>                            break;<br>                    }//如果再次找到一个与tokenEndChar相同的字符,并且此字符前面不是转义符<br>                } else if ((c == tokenEndChar) &amp;&amp; (str.charAt(position - 1) !== &quot;\\&quot;)) {<br>                    var token = str.substring(tokenStart, position + 1);<br>                    tokens.push(token);<br>                    var replacement = "@mass_token_" + (tokens.length - 1) + "@";//对应的占位符<br>                    str = str.substring(0, tokenStart) + replacement + str.substring(position + 1);<br>                    position -= (token.length - replacement.length);<br>                    tokenStart = null;<br>                }<br>            }<br>            // 将{},[],()等括起来的部分全部用占位符代替<br>            tokenEndChar = tokenStart = null;<br>            var tokenDepth = 0, tokenStartChar = null;<br>            for (position = 0; position &lt; str.length; position++) {<br>                var c = str.charAt(position);<br>                if (tokenStart === null) {<br>                    switch (c) {<br>                        case "{": tokenStart = position; tokenStartChar = c;<br>                            tokenEndChar = "}";<br>                            break;<br>                        case "(": tokenStart = position; tokenStartChar = c;<br>                            tokenEndChar = ")";<br>                            break;<br>                        case "[": tokenStart = position; tokenStartChar = c;<br>                            tokenEndChar = "]";<br>                            break;<br>                    }<br>                }<br>                if (c === tokenStartChar)<br>                    tokenDepth++;<br>                else if (c === tokenEndChar) {<br>                    tokenDepth--;<br>                    if (tokenDepth === 0) {<br>                        var token = str.substring(tokenStart, position + 1);<br>                        tokens.push(token);<br>                        replacement = "@mass_token_" + (tokens.length - 1) + "@";<br>                        str = str.substring(0, tokenStart) + replacement + str.substring(position + 1);<br>                        position -= (token.length - replacement.length);<br>                        tokenStart = null;<br>                    }<br>                }<br>            }<br>            //拆解字段，还原占位符的部分<br>            var result = [];<br>            var keyValuePairs = str.split(",");<br>            for (var i = 0, j = keyValuePairs.length; i &lt; j; i++) {<br>                var pair = keyValuePairs[i];<br>                var colonPos = pair.indexOf(":");<br>                if ((colonPos &gt; 0) &amp;&amp; (colonPos &lt; pair.length - 1)) {<br>                    var key = pair.substring(0, colonPos);<br>                    var value = pair.substring(colonPos + 1);<br>                    result.push({<br>                        'key': restoreTokens(key, tokens),<br>                        'value': restoreTokens(value, tokens)<br>                    });<br>                } else {//到这里应该抛错吧<br>                    result.push({<br>                        'unknown': restoreTokens(pair, tokens)<br>                    });<br>                }<br>            }<br>            return result;<br>        }<br>        function ensureQuoted(key) {<br>            var trimmedKey = key.trim()<br>            switch (trimmedKey.length &amp;&amp; trimmedKey.charAt(0)) {<br>                case "'":<br>                case '"':<br>                    return key;<br>                default:<br>                    return "'" + trimmedKey + "'";<br>            }<br>        }<br>        // var e =  $.normalizeJSON("{aaa:111,bbb:{ccc:333, class:'xxx', eee:{ddd:444}}}");<br>        $.normalizeJSON = function (json, insertFields, extra) {//对键名添加引号，以便安全通过编译<br>            var keyValueArray = parseObjectLiteral(json),resultStrings = [] ,keyValueEntry, propertyToHook = [];<br>            for (var i = 0; keyValueEntry = keyValueArray[i]; i++) {<br>                if (resultStrings.length &gt; 0)<br>                    resultStrings.push(",");<br>                if (keyValueEntry['key']) {<br>                    var key = keyValueEntry['key'].trim();<br>                    var quotedKey = ensureQuoted(key), val = keyValueEntry['value'].trim();<br>                    resultStrings.push(quotedKey);<br>                    resultStrings.push(":");<br>                    //                    if(insertFields === true &amp;&amp; key === &quot;foreach&quot;){//特殊处理foreach<br>                    //                        var array = val.match($.rword);<br>                    //                        val = array.shift();<br>                    //                        if(array[0] === "as"){//如果用户定义了多余参数<br>                    //                            extra.$itemName = array[1];<br>                    //                            extra.$indexName = array[2];<br>                    //                        }<br>                    //                    }<br>                    if(val.charAt(0) == &quot;{&quot; &amp;&amp; val.charAt(val.length - 1) == &quot;}&quot;){<br>                        val = $.normalizeJSON( val );//逐层加引号<br>                    }<br>                    resultStrings.push(val);<br>                    if(insertFields == true){//用函数延迟值部分的执行<br>                        if (propertyToHook.length &gt; 0)<br>                            propertyToHook.push(", ");<br>                        propertyToHook.push(quotedKey + " : function() { return " + val + " }")<br>                    }<br>                } else if (keyValueEntry['unknown']) {<br>                    resultStrings.push(keyValueEntry['unknown']);//基于跑到这里就是出错了<br>                }<br>            }<br>            resultStrings = resultStrings.join("");<br>            if(insertFields == true){<br>                resultStrings += ' , "@mass_fields": {'+ propertyToHook.join("") + '}'<br>            }<br>            return "{" +resultStrings +"}";<br>        }<br>    }();<br><br>});<br><br>    <br><img src="http://www.cnblogs.com/rubylouvre/aggbug/2685951.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/rubylouvre/archive/2012/09/15/2685951.html">本文链接</a></p>