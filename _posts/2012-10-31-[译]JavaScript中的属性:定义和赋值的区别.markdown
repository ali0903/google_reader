---
layout: post
title:  "[译]JavaScript中的属性:定义和赋值的区别"
date:   2012-10-31 22:42:00
author: 紫云飞
categories: program
---

## [译]JavaScript中的属性:定义和赋值的区别
### by 紫云飞
### at 2012-10-31 22:42:00
### original <http://www.cnblogs.com/ziyunfei/archive/2012/10/31/2738728.html>

<p>原文:<a href="http://www.2ality.com/2012/08/property-definition-assignment.html">http://www.2ality.com/2012/08/property-definition-assignment.html</a></p><hr><p>你知道吗?定义一个属性和为一个属性赋值是有区别的.本文解释了两者之间的区别以及各自的作用影响.该话题来自于Allen Wirfs-Brock在es-discuss邮件列表中的一封<a href="https://mail.mozilla.org/pipermail/es-discuss/2012-July/024227.html">邮件</a>. <a name="more"></a></p><h3>1. 定义VS赋值<p><strong>定义(Definition).</strong>定义属性需要使用相应的函数,比如:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">Object.defineProperty(obj, "prop", propDesc)</div><p>如果obj没有prop这个自身属性,则该函数的作用是给obj添加一个自身属性prop并赋值,参数<tt>propDesc指定了</tt>该属性拥有的特性(可写性,可枚举性等).如果obj已经有了prop这个自身属性,则该函数的作用是修改这个已有属性的特性,当然也包括它的属性值.</p><p><strong>赋值(assignment).</strong>为一个属性赋值需要使用下面的表达式:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">obj.prop = value</div><p>如果obj已经有了prop这个自身属性,则该表达式的作用就是修改这个prop属性的值,反之,如果obj没有prop这个自身属性,则该表达式的操作结果就不一定了:首先会查找对象obj的原型链<a href="http://www.cnblogs.com/ziyunfei/#a1"><sup>[1]</sup></a>,如果原型链中的所有对象都没有名为prop的属性,则结果是在obj身上新建一个自身属性prop,新创建的属性拥有默认的属性特性,且把指定的value赋值给该属性.但如果<tt>obj的某个上层原型中上有一个名为prop的属性</tt>,那接下来的操作就复杂了,具体请看下面的3.2小节.</p><p><strong>2. 属性特性和内部属性</strong></p><p><strong>2.1. 多种类型的属性</strong></p><p>JavaScript中有三种类型的属性:</p><ul><li>命名数据属性(named data properties): 拥有一个确定的值的属性.这也是最常用的属性.</li><li>命名访问器属性(named accessor properties): 通过getter和setter进行读取和赋值的属性.</li><li>内部属性(internal properties): 由JavaScript引擎内部使用的属性,不能通过JavaScript代码直接访问到,不过可以通过一些方法间接的读取和设置.比如:每个对象都有一个内部属性[[Prototype]],你不能直接访问这个属性,但可以通过<tt>Object.getPrototypeOf()方法间接的读取到它的值</tt>.虽然内部属性通常用一个双中括号包围的名称来表示,但实际上这并不是它们的名字,它们是一种抽象操作,是不可见的,根本没有上面两种属性有的那种字符串类型的属性名.</li></ul><p><strong>2.2. 属性特性</strong></p><p>每个属性(property)都拥有4个特性(attribute).两种类型的属性一种有6种属性特性:</p><ul><li>命名数据属性特有的特性:<ul><li>[[Value]]: 属性的值.</li><li>[[Writable]]: 控制属性的值是否可以改变.</li></ul></li><li>命名访问器属性特有的特性:<ul><li>[[Get]]: 存储着getter方法.</li><li>[[Set]]: 存储着setter方法.</li></ul></li><li>两种属性都有的特性:<ul><li>[[Enumerable]]: 如果一个属性是不可枚举的,则在一些操作下,这个属性是不可见的,比如<tt>for...in和</tt><tt>Object.keys()</tt><a href="http://www.cnblogs.com/ziyunfei/#a1"><sup>[2]</sup></a>.</li><li>[[Configurable]]: 如果一个属性是不可配置的,则该属性的所有特性(除了[[Value]])都不可改变.</li></ul></li></ul><p><strong>2.3. 属性描述符</strong></p><p>属性描述符(property descriptor)可以将一个属性的所有特性编码成一个对象并返回.例如:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#000000">{<br>    value: </span>123<span style="color:#000000">,<br>    writable: </span><span style="color:#0000ff">false</span><span style="color:#000000"><br>}</span></div><p>属性描述符使用在下面的这些函数中:<tt>Object.defineProperty</tt>, <tt>Object.getOwnPropertyDescriptor</tt>, <tt>Object.create.如果省略了属性描述符对象中的某个属性</tt>,则该属性会取一个默认值:</p><table><tbody><tr><td><strong>属性名</strong></td><td><strong>默认值</strong></td></tr><tr><td><tt>value</tt></td><td><tt>undefined</tt></td></tr><tr><td><tt>get</tt></td><td><tt>undefined</tt></td></tr><tr><td><tt>set</tt></td><td><tt>undefined</tt></td></tr><tr><td><tt>writable</tt></td><td><tt>false</tt></td></tr><tr><td><tt>enumerable</tt></td><td><tt>false</tt></td></tr><tr><td><tt>configurable</tt></td><td><tt>false</tt></td></tr></tbody></table><p><strong>2.4. 内部属性</strong></p><p>下面列举几个所有对象都有的<a href="http://ecma-international.org/ecma-262/5.1/#sec-8.6.2">内部属性</a>:</p><ul><li>[[Prototype]]: 对象的原型.</li><li>[[Extensible]]: 对象是否可以扩展,也就是是否可以添加新的属性.</li><li>[[DefineOwnProperty]]: 定义一个属性的内部方法.下一节会详细解释.</li><li>[[Put]]: 为一个属性赋值的内部方法.下一节会详细解释.</li></ul><p><strong>3. 属性定义和属性赋值</strong></p><p><strong>3.1. 属性定义</strong></p><p>定义属性是通过内部方法来进行操作的:</p><blockquote>[[<a href="http://ecma-international.org/ecma-262/5.1/#sec-8.12.9">DefineOwnProperty</a>]] (P, Desc, Throw)</blockquote><p><tt>P是要定义的属性名称</tt>.参数<tt>Throw决定了在定义操作被拒绝的时候是否要抛出异常</tt>:如果<tt>Throw为</tt><tt>true,则抛出异常.否则</tt>,操作只会静默失败.当调用[[DefineOwnProperty]]时,具体会执行下面的操作步骤.</p><ul><li>如果<tt>this没有名为P的自身属性的话:如果this是可扩展的话,则创建P这个自身属性</tt>,否则拒绝.</li><li>如果<tt>this已经有了名为P的自身属性:则按照下面的步骤重新配置这个属性</tt>.</li><li>如果这个已有的属性是不可配置的,则进行下面的操作会被拒绝:<ul><li>将一个数据属性转换成访问器属性,反之亦然</li><li>改变[[Configurable]]或[[Enumerable]]</li><li>该变[[Writable]]</li><li>在[[Writable]]为<tt>false时</tt>改变[[Value]]</li><li>改变[[Get]]或[[Set]]</li></ul></li><li>否则,这个已有的属性可以被重新配置.</li></ul><p>如果<tt>Desc就是P属性当前的属性描述符,则该定义操作永远不会被拒绝</tt>.</p><p>定义属性的函数有两个:<tt>Object.defineProperty和</tt><tt>Object.defineProperties</tt>.例如:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">Object.defineProperty(obj, propName, desc)</div><p>在引擎内部,会转换成这样的方法调用:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">obj.[[DefineOwnProperty]](propName, desc, <span style="color:#0000ff">true</span>)</div><p><strong>3.2. 属性赋值</strong></p><p>为属性赋值是通过内部方法进行操作的:</p><blockquote>[[<a href="http://ecma-international.org/ecma-262/5.1/#sec-8.12.5">Put</a>]] (P, Value, Throw)</blockquote><p><tt>参数P以及</tt><tt>Throw和</tt>[[DefineOwnProperty]]方法中的参数表现的一样.在调用[[Put]]方法的时候,会执行下面这样的操作步骤.</p><ul><li>如果在原型链上存在一个名为<tt>P的只读属性(只读的数据属性或者没有setter的访问器属性),</tt>则拒绝.</li><li>如果在原型链上存在一个名为P的且拥有setter的访问器属性:则调用这个setter.</li><li>如果没有名为<tt>P的自身属性</tt>:则如果这个对象是可扩展的,就使用下面的操作创建一个新属性:<div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">this</span><span style="color:#000000">.[[DefineOwnProperty]](<br>    P,<br>    {<br>        value: Value,<br>        writable: </span><span style="color:#0000ff">true</span><span style="color:#000000">,<br>        enumerable: </span><span style="color:#0000ff">true</span><span style="color:#000000">,<br>        configurable: </span><span style="color:#0000ff">true</span><span style="color:#000000"><br>    },<br>    Throw<br>)</span></div>否则,如果这个对象是不可扩展的,则拒绝.</li><li>否则, 如果已经存在一个可写的名为<tt>P的自身属性</tt>.则调用:<div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">this</span>.[[DefineOwnProperty]](P, { value: Value }, Throw)</div>该操作只会更改<tt>P属性的值</tt>,其他的特性(比如可枚举性)都不会改变.</li></ul><p>赋值运算符(<tt>=</tt>)就是在调用[[Put]].比如:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">obj.prop = v;</div><p>在引擎内部,会转换成这样的方法调用:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">obj.[[Put]]("prop", v, isStrictModeOn)</div><p>isStrictModeOn对应着参数Throw.也就是说,赋值运算符只有在严格模式下才有可能抛出异常.[[Put]]没有返回值,但赋值运算符有.</p><p><strong>4. 作用及影响</strong></p><p>本节讲一下属性的定义操作和赋值操作各自的作用及影响.</p><p><strong>4.1. 赋值可能会调用原型上的setter,定义会创建一个自身属性</strong></p><p>给定一个空对象<tt>obj,他的原型</tt><tt>proto有一个名为</tt>foo的访问器属性.</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> proto =<span style="color:#000000"> {<br>    get foo() {<br>        console.log(</span>"Getter"<span style="color:#000000">);<br>        </span><span style="color:#0000ff">return</span> "a"<span style="color:#000000">;<br>    },<br>    set foo(x) {<br>        console.log(</span>"Setter: "+<span style="color:#000000">x);<br>    },<br>};<br></span><span style="color:#0000ff">var</span> obj = Object.create(proto);</div><p>那么,"在obj身上定义一个foo属性"和"为obj的foo属性赋值"有什么区别呢?</p><p>如果是定义操作的话,则会在obj身上添加一个自身属性foo:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; Object.defineProperty(obj, &quot;foo&quot;, { value: &quot;b&quot;<span style="color:#000000"> });<br></span>&gt;<span style="color:#000000"> obj.foo<br></span>'b'<br>&gt;<span style="color:#000000"> proto.foo<br>Getter<br></span>'a'</div><p>但如果为foo属性赋值的话,则意味着你是想改变某个已经存在的属性的值.所以这次赋值操作会转交给原型proto的foo属性的setter访问器来处理,下面代码的执行结果就能证明这一结论:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; obj.foo = &quot;b&quot;<span style="color:#000000">;<br>Setter: b<br></span>'b'</div><p>你还可以定义一个只读的访问器属性,办法是:只定义一个getter,省略setter.下面的例子中,<tt>proto2的</tt><tt>bar</tt>属性就是这样的只读属性,<tt>obj2继承了这个属性</tt>.</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">"use strict"<span style="color:#000000">;<br></span><span style="color:#0000ff">var</span> proto2 =<span style="color:#000000"> {<br>    get bar() {<br>        console.log(</span>"Getter"<span style="color:#000000">);<br>        </span><span style="color:#0000ff">return</span> "a"<span style="color:#000000">;<br>    },<br>};<br></span><span style="color:#0000ff">var</span> obj2 = Object.create(proto2);</div><p>开启严格模式的话,下面的赋值操作会抛出异常.非严格模式的话,赋值操作只会静默失败(不起任何作用,也不报错).</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; obj2.bar = &quot;b&quot;<span style="color:#000000">;<br>TypeError: obj.bar is read</span>-only</div><p>我们可以定义一个自身属性bar,遮蔽从原型上继承的bar属性:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; Object.defineProperty(obj2, &quot;bar&quot;, { value: &quot;b&quot;<span style="color:#000000"> });<br></span>&gt;<span style="color:#000000"> obj2.bar<br></span>'b'<br>&gt;<span style="color:#000000"> proto2.bar<br>Getter<br></span>'a'</div><p><strong>4.2. 原型链中的同名只读属性可能会阻止赋值操作,但不会阻止定义操作</strong></p><p>如果原型链中存在一个同名的只读属性,则无法通过赋值的方式在原对象上添加这个自身属性,必须使用定义操作才可以.这项限制是在ECMAScript 5.1中引入的<tt></tt>:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">"use strict"<span style="color:#000000">;<br></span><span style="color:#0000ff">var</span> proto =<span style="color:#000000"> Object.defineProperties(<br>    {},<br>    {<br>        foo: {  </span><span style="color:#008000">//</span><span style="color:#008000"> foo属性的特性:</span><br>            value: "a"<span style="color:#000000">,<br>            writable: </span><span style="color:#0000ff">false</span>,  <span style="color:#008000">//</span><span style="color:#008000"> 只读</span><br>            configurable: <span style="color:#0000ff">true</span>  <span style="color:#008000">//</span><span style="color:#008000"> 可配置</span><br><span style="color:#000000">        }<br>    });<br></span><span style="color:#0000ff">var</span> obj = Object.create(proto);</div><p><strong>赋值.</strong>赋值操作会导致异常:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; obj.foo = &quot;b&quot;;                 <span style="color:#008000">//</span><span style="color:#008000">译者注:貌似只有Firefox遵循了这个标准</span><br>TypeError: obj.foo is read-only</div><p>这貌似是个很奇怪的表现,原型上的属性居然可以影响到能否创建一个同名的自身属性 <sup><a href="http://www.cnblogs.com/ziyunfei/#a1">[3]</a></sup>.但是这样的表现是有道理的,因为另外一种形式的只读属性(只有getter的访问器属性)也是这样的表现,这样才能统一.</p><p><strong>定义.</strong>通过定义的方式,我们可以成功创建一个新的自身属性:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; Object.defineProperty(obj, &quot;foo&quot;, { value: &quot;b&quot;<span style="color:#000000"> });<br></span>&gt;<span style="color:#000000"> obj.foo<br></span>'b'<br>&gt;<span style="color:#000000"> proto.foo<br></span>'a'</div><p><strong>4.3.  赋值运算符不会改变原型链上的属性</strong></p><p>执行下面的代码,则<tt>obj会从</tt><tt>proto上继承到foo属性</tt>.</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> proto = { foo: "a"<span style="color:#000000"> };<br></span><span style="color:#0000ff">var</span> obj = Object.create(proto);</div><p>你不能通过为<tt>obj.foo赋值来改变</tt><tt>proto.foo的值</tt>.这种操作只会在obj上新建一个自身属性:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; obj.foo = &quot;b&quot;<span style="color:#000000">;<br></span>'b'<br>&gt;<span style="color:#000000"> obj.foo<br></span>'b'<br>&gt;<span style="color:#000000"> proto.foo<br></span>'a'</div><div><p>之所以会这样设计,是因为:原型身上的属性可以被继承该原型的所有后代所共享.如果想改变其中一个后代的某个继承属性,则会创建一个属于这个后代的自身属性.这就意味着:你可以做一些修改,但仅仅是某一个对象上的修改,不会影响其他的后代.从这个角度看,只读属性(只读的数据属性和只有getter的访问器属性)的这种表现就能说的通了: 阻止修改,通过阻止创建自身属性. 重写原型属性而不是修改它们的动机是什么呢?</p><ol><li>方法: 允许直接在原型身上修改原型的方法,但防止通过原型的后代上的意外操作而修改原型上的方法.</li><li>非方法的属性: 原型可以提供给它的后代一些默认存在的属性.通过操作某个后代,你只能遮蔽这些继承的属性,但无法真正的修改它们.这被认为是一种反面模式(anti-pattern),是不推荐的做法.更好的做法是把默认值赋给构造函数.</li></ol></div><p><strong>4.4. 只有通过定义操作,才能创建一个拥有指定特性的属性</strong></p><p>如果通过赋值操作创建了一个自身属性,则该属性始终拥有默认的特性.如果你想指定某个特性的值,必须通过定义操作.</p><p><strong>4.5. 对象字面量中的属性是通过定义操作添加的</strong></p><p>下面的代码将变量obj指向了一个对象字面量:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> obj =<span style="color:#000000"> {<br>    foo: </span>123<span style="color:#000000"><br>};</span></div><p>这样的语句在引擎内部,可能会被转换成下面两种操作方式中的一种.首先可能是赋值操作:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> obj = <span style="color:#0000ff">new</span><span style="color:#000000"> Object();<br>obj.foo </span>= 123;</div><p>其次,可能是个定义操作:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> obj = <span style="color:#0000ff">new</span><span style="color:#000000"> Object();<br>Object.defineProperties(obj, {<br>    foo: {<br>        value: </span>123<span style="color:#000000">,<br>        enumerable: </span><span style="color:#0000ff">true</span><span style="color:#000000">,<br>        configurable: </span><span style="color:#0000ff">true</span><span style="color:#000000">,<br>        writable: </span><span style="color:#0000ff">true</span><span style="color:#000000"><br>    }<br>});</span></div><p>到底是哪种呢?正确答案是第二种,因为第二种操作方式能够更好的表达出对象字面量的语义:创建新的属性.<tt>Object.create接受一个属性描述符作为第二个可选参数,也是这个原因</tt>.</p><p><strong>4.6. 方法属性</strong></p><p>可以通过定义操作新建一个只读的方法属性:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">"use strict"<span style="color:#000000">;<br></span><span style="color:#0000ff">function</span><span style="color:#000000"> Stack() {<br>}<br>Object.defineProperties(Stack.prototype, {<br>    push: {<br>        writable: </span><span style="color:#0000ff">false</span><span style="color:#000000">,<br>        configurable: </span><span style="color:#0000ff">true</span><span style="color:#000000">,<br>        value: </span><span style="color:#0000ff">function</span> (x) { <span style="color:#008000">/*</span><span style="color:#008000"> ... </span><span style="color:#008000">*/</span><span style="color:#000000"> }<br>    }<br>});</span></div><p>目的是为了防止在实例身上发生意外的赋值操作:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; <span style="color:#0000ff">var</span> s = <span style="color:#0000ff">new</span><span style="color:#000000"> Stack();<br><br></span>&gt; s.push = 5<span style="color:#000000">;<br>TypeError: s.push is read</span>-only</div><p>不过,由于<tt>push是可配置的</tt>,所以我们仍可以通过定义操作来为实例添加一个自身的push方法.</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">&gt; <span style="color:#0000ff">var</span> s = <span style="color:#0000ff">new</span><span style="color:#000000"> Stack();<br></span>&gt; Object.defineProperty(s, &quot;push&quot;<span style="color:#000000">,<br>      { value: </span><span style="color:#0000ff">function</span> () { <span style="color:#0000ff">return</span> "yes"<span style="color:#000000"> }})<br><br></span>&gt;<span style="color:#000000"> s.push()<br></span>'yes'</div><p>我们甚至可以通过定义操作来重新定义原型上的push方法:<tt>Stack.prototype.push</tt>.</p><p><strong>5. 结论</strong></p><p>我们经常会通过为属性赋值来给一个对象添加新的属性.本文解释了这样做是可能引发一些问题的.因此,最好要遵循下面的规则:</p><ol><li>如果你想创建一个新属性,则使用属性定义.</li><li>如果你想该变一个属性的值,则使用属性赋值.</li></ol><p>在评论中,medikoo提醒了我们使用属性描述符来创建属性可能会有点慢.我就经常通过为属性赋值来创建新属性,因为这样很方便.值得高兴的是,ECMAScript.next也许会把属性的定义操作变的既快又方便:已经存在一个“<a href="http://wiki.ecmascript.org/doku.php?id=strawman:define_properties_operator">定义属性的运算符</a>”的提案,可以作为<tt>Object.defineProperties的替代用法</tt>.由于属性定义和属性赋值之间的差别既很微妙,又很重要,所以这种改进应该会很受欢迎.</p><p><strong><a name="a1"></a>6. 参考</strong></p><ol><li><a href="http://www.2ality.com/2011/06/prototypes-as-classes.html">Prototypes as classes – an introduction to JavaScript inheritance</a></li><li><a href="http://www.2ality.com/2011/07/js-properties.html">JavaScript properties: inheritance and enumerability</a></li><li><a href="http://wiki.ecmascript.org/doku.php?id=strawman:fixing_override_mistake">Fixing the Read-only Override Prohibition Mistake</a> [ECMAScript wiki]</li></ol><img src="http://www.cnblogs.com/ziyunfei/aggbug/2738728.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/ziyunfei/archive/2012/10/31/2738728.html">本文链接</a></p></h3>