---
layout: post
title:  "JavaScript 项目优化总结"
date:   2013-01-18 23:04:07
author: 
categories: program
---

## JavaScript 项目优化总结
### by 
### at 2013-01-18 23:04:07
### original <http://kb.cnblogs.com/page/155286/>

<p>　　前端时间对公司已有项目JavaScript代码进行优化，本文的是对优化工作的一个总结，拿出来与大家分享。当然我的优化方式可能并不是最优的，或者说有些不对的地方，请指教。</p><p>　　<strong>JavaScript优化总结分为以下几点</strong></p><p align="center">优化前后对比</p><table style="width:664px;height:355px" border="1" cellspacing="0" cellpadding="0"><tbody><tr><td valign="top" width="284"><p align="center"><strong>优化前</strong></p></td><td valign="top" width="284"><p align="center"><strong>优化后</strong></p></td></tr><tr><td valign="top" width="284"><p>代码混乱，同样功能的函数重复出现在多个地方。如果需要修改实现，需要找到所有的地方。牵一发而动全身</p></td><td valign="top" width="284"><p>模块化，提取公共接口组织为库、结构清晰、方便代码重用、并且能够游戏防止变量污染问题。</p></td></tr><tr><td valign="top" width="284"><p>JavaScript文件未压缩，size比较大加载消耗网络耗时，阻塞页面渲染</p><p>　　 </p></td><td valign="top" width="284"><p>JavaScript公共库文件使用UglifyJS压缩：</p><ul><li>Size比较小优化了网络加载时间</li><li>压缩混淆了代码，在一定程度上保护代码</li></ul></td></tr><tr><td valign="top" width="284"><p>使用时需要加载多个单独的JavaScript文件，增加了http请求数降低性能</p></td><td valign="top" width="284"><p>对公共库合并压缩在减少size的同时，减少http请求数</p></td></tr><tr><td valign="top" width="284"><p>缺乏文档（让后面的开发者对已有功能不清楚，这在一定程度上造成前面说的，同样功能的函数重复出现在多个地方）</p></td><td valign="top" width="284"><p>公共库中每个类、函数、属性都有说明文档</p></td></tr></tbody></table><ul><li>模块化（类编程）：代码清晰、有效防止变量污染问题、代码重用方便扩展等；</li><li>JavaScript压缩混淆：减少size优化加载时间，混淆保护代码；</li><li>JavaScript文件合并：减少http请求优化网络耗时提升性能；</li><li>生成文档：方便公共库的使用，查找接口方便。</li></ul><p>　　<strong>模块化（类编程）</strong></p><p align="justify">　　对于静态类来说JavaScript实现比较简单，使用Object直接量就已经够用了；但是要创建实例化、可继承经典的类需要做一番工作。因为JavaScript是<strong>基于原型的（</strong><strong>prototype-based</strong><strong>）</strong>编程语言，并没有包含内置类的实现（它没有访问控制符，它没有定义类的关键字class，它没有支持继承的extend或冒号，它也没有用来支持虚函数的virtual等），但是我们通过JavaScript可以轻易地模拟出经典的类。</p><p>　　<strong>静态类</strong></p><p>　　根据宝宝JS公共接口的特性，它们不需要实例化，所以优化使用了该方式。下面以<strong>PetConfigParser</strong>为例介绍下实现方式：</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span><span style="color:#000000"> PetConfigParser;<br></span><span style="color:#0000ff">if</span> (!<span style="color:#000000">PetConfigParser) {<br>    PetConfigParser </span>=<span style="color:#000000"> {};<br>}<br> <br>(</span><span style="color:#0000ff">function</span><span style="color:#000000"> () {<br>    </span><span style="color:#008000">//</span><span style="color:#008000">private 变量、函数</span><br>    <span style="color:#008000">/*</span><span style="color:#008000">*<br>     * 宝宝所有配置字典，以【cate * 10000 + (lvl - 1) * 10 + dex - 1】为key<br>     * @attribute    petDic<br>     * @type {Object}<br>     * @private<br>     </span><span style="color:#008000">*/</span><br>    <span style="color:#0000ff">var</span> petDic = <span style="color:#0000ff">null</span>;  <span style="color:#008000">//</span><span style="color:#008000">宝宝字典</span><br> <br>    <span style="color:#008000">/*</span><span style="color:#008000">*<br>     * 根据__pet_config构建一个Object字典，以cate、dex、lvl组合作为key<br>     * @method buildPetDic<br>     * @private<br>     * @return {void}<br>     </span><span style="color:#008000">*/</span><br>    <span style="color:#0000ff">function</span><span style="color:#000000"> buildPetDic() {<br>        petDic </span>= <span style="color:#0000ff">new</span><span style="color:#000000"> Object();<br>        </span><span style="color:#0000ff">for</span> (<span style="color:#0000ff">var</span> item <span style="color:#0000ff">in</span><span style="color:#000000"> __pet_config) {<br>            </span><span style="color:#0000ff">var</span> lvl = parseInt(__pet_config[item]['lvl'<span style="color:#000000">]);<br>            </span><span style="color:#0000ff">var</span> dex = parseInt(__pet_config[item]['dex'<span style="color:#000000">]);<br>            </span><span style="color:#0000ff">var</span> cate = parseInt(__pet_config[item]['cate'<span style="color:#000000">]);<br>            </span><span style="color:#0000ff">var</span> key = cate * 10000 + (lvl - 1) * 10 +<span style="color:#000000"> dex;<br>            petDic[key] </span>=<span style="color:#000000"> __pet_config[item];<br>        }<br>    }<br> <br>    </span><span style="color:#008000">//</span><span style="color:#008000">public 接口</span><br> <br>    <span style="color:#008000">/*</span><span style="color:#008000">*<br>     * 根据宝宝id，读取__pet_config中对应宝宝的信息<br>     * @method getPetById<br>     * @param   {String/int} petId 宝宝id<br>     * @return  {Object} pet 宝宝的所有静态信息，如{id:"300003289", lvl:"1", dex:"2", price:"200", life:"2592000", cate:"3", name:"飞天小使等级1熟练2", intro:"", skill:"护身符", skill1_prob:"30", skill2_prob:"0"}<br>     </span><span style="color:#008000">*/</span><br>    <span style="color:#0000ff">if</span> (<span style="color:#0000ff">typeof</span> PetConfigParser.getPetById !== 'function'<span style="color:#000000">) {<br>        PetConfigParser.getPetById </span>= <span style="color:#0000ff">function</span><span style="color:#000000"> (petId) {<br>            </span><span style="color:#0000ff">var</span> pet = ("undefined" == <span style="color:#0000ff">typeof</span> (__pet_config)) ? <span style="color:#0000ff">null</span> : __pet_config["pet_" +<span style="color:#000000"> petId];<br>            </span><span style="color:#0000ff">return</span><span style="color:#000000"> pet;<br>        }<br>}<br>})();</span> </div><p>　　<strong>这种方式利用了JavaScript</strong><strong>匿名函数来创建私有作用域，这些私有作用域只能在内部访问</strong>。总结上述过程分为以下几个步骤：</p><p>　　1、定义一个全局的变量（<strong><em>var PetConfigParser</em></strong>），注意变量首字母大写与普通变量区别；</p><p>　　2、然后创建一个匿名函数并运行（ <strong><em>(function () {/*xxxx*/ })(); </em></strong>），在匿名函数内部创建局部变量和函数，它们只能在当前作用域中被访问到；</p><p>　　3、全局变量（<strong><em>var PetConfigParser</em></strong>）可以在任何地方访问到，在匿名函数内部操作<strong><em>PetConfigParser</em></strong>添加静态函数。</p><p>　　<strong>使用实例</strong>：</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">$(<span style="color:#0000ff">function</span><span> () {<br>        DialogManager.init();<br>        $(</span>'#showDialog').click(<span style="color:#0000ff">function</span><span style="color:#000000"> () {<br>            DialogManager.show(</span>"#msgBoxTest"， "#closeId"<span style="color:#000000">);<br>            </span><span style="color:#0000ff">return</span> <span style="color:#0000ff">false</span><span style="color:#000000">;<br>        });<br>        $(</span>'#cofirmBtn').click(<span style="color:#0000ff">function</span><span style="color:#000000"> () {<br>            DialogManager.hide();<br>            </span><span style="color:#0000ff">return</span> <span style="color:#0000ff">false</span><span style="color:#000000">;<br>        });<br>})</span></div><p><strong>　　实例类</strong></p><p>　　JavaScript实现经典的类，总结有三种方法：</p><ul><li>构造函数方式；</li><li>原型方式；</li><li>构造函数+原型的混合方式</li></ul><p>　　<strong>构造函数方式</strong></p><p>　　构造函数用来初始化实例对象的属性和值。任何JavaScript函数都可以用作构造函数，构造函数必须使用new运算符作为前缀来创建新的实例。</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> Person = <span style="color:#0000ff">function</span><span style="color:#000000"> (name) {<br>    </span><span style="color:#0000ff">this</span>.name =<span style="color:#000000"> name;<br>    </span><span style="color:#0000ff">this</span>.sayName = <span style="color:#0000ff">function</span><span style="color:#000000">(){<br>        alert(</span><span style="color:#0000ff">this</span><span style="color:#000000">.name);<br>    };<br>}<br> <br></span><span style="color:#008000">//</span><span style="color:#008000">实例化</span><br><span style="color:#0000ff">var</span> tyler = <span style="color:#0000ff">new</span> Person("tylerzhu"<span style="color:#000000">);<br></span><span style="color:#0000ff">var</span> saylor = <span style="color:#0000ff">new</span> Person("saylorzhu"<span style="color:#000000">);<br>tyler.sayName();<br>saylor.sayName();<br></span><span style="color:#008000">//</span><span style="color:#008000">检查实例</span><span style="color:#000000"><br>alert(tyler </span><span style="color:#0000ff">instanceof</span> Person); </div><p>　　构造函数方式跟传统的面向对象语言是不是很相识！只不过是class关键字用function替换了。</p><p>　　注意：不要省略new否则Person(“tylerzhu”) //==&gt;undefined。当使用new关键字来调用构造函数时，执行上下文（context）从全局对象（window）变成一个空的上下文，这个上下文代表了新生成的实例。因此，this关键子指向当前创建的实例。所以省略new时，没有进行上下文切换会在全局对象中查找name，没有找到而创建一个全局变量name返回undefined。</p><p>　　<strong>原型方式</strong></p><p>　　构造函数方式简单，但是存在一个浪费内存的问题。如上面的例子中实例化了两个对象tyler、saylor，表面上好像没什么问题，但是实际上对于每一个实例对象，sayName()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容申请内容。</p><p>　　alert(tyler. sayName == saylor. sayName) 输出 false！！！</p><p>　　<strong>Javascript</strong><strong>中每一个构造函数都有一个prototype</strong><strong>属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例共享</strong>。</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> Person = <span style="color:#0000ff">function</span><span style="color:#000000"> (name) {<br>    Person.prototype </span>=<span> name;<br>    Person.prototype.sayName </span>= <span style="color:#0000ff">function</span><span style="color:#000000">(){<br>        alert(</span><span style="color:#0000ff">this</span><span style="color:#000000">.name);<br>    }<br>}<br> <br></span><span style="color:#008000">//</span><span style="color:#008000">实例化</span><br><span style="color:#0000ff">var</span> tyler = <span style="color:#0000ff">new</span> Person("tylerzhu"<span style="color:#000000">);<br></span><span style="color:#0000ff">var</span> saylor = <span style="color:#0000ff">new</span> Person("saylorzhu"<span style="color:#000000">);<br>tyler.sayName();<br>saylor.sayName();<br> <br></span><span style="color:#008000">//</span><span style="color:#008000">检查实例</span><span style="color:#000000"><br>alert(tyler </span><span style="color:#0000ff">instanceof</span> Person); </div><p>　　这时tyler、saylor实例的sayName方法，都是同一个内存地址（指向prototype对象），因此原型方法更节省内存。</p><p>　　但是看 tyler.sayName(); saylor.sayName(); 两者输出，会看出问题 —— 它们都输出“saylorzhu”。因为原型所有属性都共享，只要一个实例改变其他的都会跟着改变，所以实例化对象saylor覆盖了tyler。</p><p>　　<strong>构造函数+原型的混合方式</strong></p><p>　　构造函数方式可以为同一个类的每一个对象分配不同的内存，这很适合写类的时候设置属性；但是设置方法的时候我们就需要让同一个类的不同对象共享同一个内存了，写方法用原型的方式最好。所以写类的时候需要把构造方法和原型两种方式混合着用（很多类库提供的创建类的方法或框架的写类方式本质上都是：构造函数+原型）。</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> Person = <span style="color:#0000ff">function</span><span style="color:#000000"> (name) {<br>    Person.prototype </span>=<span style="color:#000000"> name;<br>    Person.prototype.sayName </span>= <span style="color:#0000ff">function</span><span style="color:#000000">(){<br>        alert(</span><span style="color:#0000ff">this</span><span style="color:#000000">.name);<br>    }<br>} <br><br></span><span style="color:#008000">//</span><span style="color:#008000">实例化</span><br><span style="color:#0000ff">var</span> tyler = <span style="color:#0000ff">new</span> Person("tylerzhu"<span style="color:#000000">);<br></span><span style="color:#0000ff">var</span> saylor = <span style="color:#0000ff">new</span> Person("saylorzhu"<span style="color:#000000">);<br>tyler.sayName();<br>saylor.sayName();<br></span><span style="color:#008000">//</span><span style="color:#008000">检查实例</span><span style="color:#000000"><br>alert(tyler </span><span style="color:#0000ff">instanceof</span> Person); </div><p>　　这样即可通过构造函数构造不同name的人，对象实例也都共享sayName方法，不会造成内存浪费。</p><p>　　<strong>JavaScript压缩/合并</strong></p><p>　　JavaScript代码压缩混淆的意义：<strong>简单的说就是为了减小</strong><strong>js</strong><strong>文件大小，去掉多余的注释和换行缩进等，使得下载起来更快，提高用户体验</strong>。</p><p>　　JavaScript压缩工具有很多，我推荐使用jQuery现在使用的工具UglifyJS（jQuery以前也使用过多种压缩工具，如Packer），因为它压缩性能很好。</p><p>　　<em>“jQuery 1.5 </em><em>发布的时候 john resig </em><em>大神说所用的代码优化程序从Google Closure</em><em>切换到UglifyJS</em><em>，新工具的压缩效果非常令人满意”</em></p><p align="justify">　　下面是官方性能对比：We’re still a lot better than YUI in terms of compression, though slightly slower. We’re still a lot faster than Closure, and compression after gzip is comparable.</p><table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td valign="top" width="101"><p align="center"><strong>File</strong></p></td><td valign="top" width="75"><p align="center"><strong>UglifyJS</strong></p></td><td valign="top" width="97"><p align="center"><strong>UglifyJS</strong></p><p align="center"><strong>+gzip</strong></p></td><td valign="top" width="72"><p align="center"><strong>Closure</strong></p></td><td valign="top" width="75"><p align="center"><strong>Closure</strong></p><p align="center"><strong>+gzip</strong></p></td><td valign="top" width="73"><p align="center"><strong>YUI</strong></p></td><td valign="top" width="71"><p align="center"><strong>YUI</strong></p><p align="center"><strong>+gzip</strong></p></td></tr><tr><td valign="top" width="101"><p><strong>jquery-1.6.2.js</strong></p></td><td valign="top" width="75"><p>91001　　<strong>(0:01.59)</strong></p></td><td valign="top" width="97"><p>31896</p></td><td valign="top" width="72"><p>90678　　<strong>(0:07.40)</strong></p></td><td valign="top" width="75"><p>31979</p></td><td valign="top" width="73"><p>101527　　<strong>(0:01.82)</strong></p></td><td valign="top" width="71"><p>34646</p></td></tr><tr><td valign="top" width="101"><p><strong>paper.js</strong></p></td><td valign="top" width="75"><p>142023　　<strong>(0:01.65)</strong></p></td><td valign="top" width="97"><p>43334</p></td><td valign="top" width="72"><p>134301　　<strong>(0:07.42)</strong></p></td><td valign="top" width="75"><p>42495</p></td><td valign="top" width="73"><p>173383　　<strong>(0:01.58)</strong></p></td><td valign="top" width="71"><p>48785</p></td></tr><tr><td valign="top" width="101"><p>　　<strong>prototype.js</strong></p></td><td valign="top" width="75"><p>88544　　<strong>(0:01.09)</strong></p></td><td valign="top" width="97"><p>26680</p></td><td valign="top" width="72"><p>86955　　<strong>(0:06.97)</strong></p></td><td valign="top" width="75"><p>26326</p></td><td valign="top" width="73"><p>92130　　<strong>(0:00.79)</strong></p></td><td valign="top" width="71"><p>28624</p></td></tr><tr><td valign="top" width="101"><p><strong>thelib-full.js</strong></p></td><td valign="top" width="75"><p>251939　　<strong>(0:02.55)</strong></p></td><td valign="top" width="97"><p>72535</p></td><td valign="top" width="72"><p>249911　　<strong>(0:09.05)</strong></p></td><td valign="top" width="75"><p>72696</p></td><td valign="top" width="73"><p>258869　　<strong>(0:01.94)</strong></p></td><td valign="top" width="71"><p>76584</p></td></tr></tbody></table><p>　　<strong>Uglifyjs安装</strong></p><p>　　UglifyJS是基于 NodeJS 的Javascript语法解析/压缩/格式化工具，所以我们要安装NodeJS。</p><blockquote><p align="justify"><em>N</em><em>ode.js is a platform built on Chrome&#39;s JavaScript runtime for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices. </em></p></blockquote><p align="justify"><em>　　JavaScript</em><em>最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用</em><em>JavaScript</em><em>可以做什么，但并没有“说”太多关于</em><em>JavaScript</em><em>语言本身可以做什么。事实上，</em><em>JavaScript</em><em>是一门“完整”的语言：</em><em>它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。</em><em>Node.js</em><em>事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行</em><em>JavaScript</em><em>代码。</em></p><p align="justify"><em>　　要实现在后台运行</em><em>JavaScript</em><em>代码，代码需要先被解释然后正确的执行。</em><em>Node.js</em><em>的原理正是如此，它使用了</em><em>Google</em><em>的</em><em>V8</em><em>虚拟机（</em><em>Google</em><em>的</em><em>Chrome</em><em>浏览器使用的</em><em>JavaScript</em><em>执行环境），来解释和执行</em><em>JavaScript</em><em>代码。</em></p><p align="justify"><em>　　除此之外，伴随着</em><em>Node.js</em><em>的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。因此，</em><em>Node.js</em><em>事实上既是一个运行时环境，同时又是一个库。</em></p><p>　　Windows下面直接下载exe文件执行即可。（<a href="http://nodejs.org/"><span style="text-decoration:underline">http://nodejs.org/</span></a>）</p><p>　　C:\Users\tyler&gt;node -v v0.8.2</p><p>　　设置代理（公司网络不设置代理无法下载，外网环境不需要）</p><p>　　“npm，全称是&quot;node packagemanager&quot;，它是node包管理器，第三方的package全是通过npm去安装的。”</p><p>　　为npm设在代理：npm config set proxy=http://proxy.tencent.com:8080</p><p>　　为npm默认选择http方式，不选用https：npm config set registry <a href="http://registry.npmjs.org/"><span style="text-decoration:underline">http://registry.npmjs.org</span></a></p><p>　　npm安装uglify-js：npm –g install uglify-js</p><p>　　验证安装是否成功：C:\Users\tyler&gt;npm -v 1.1.36</p><p>　　<strong>UglifyJS使用</strong></p><p>　　<strong>uglifyjs [ </strong><strong>选项... ] [ </strong><strong>文件 ]</strong></p><p>　　文件参数应该放在选项后面，uglifyjs 会读取文件中的javascript代码进行处理。如果你不指定输出的文件名，那么他会把处理后的内容输出到命令行中。</p><p>　　支持的选项 ：</p><p>　　-b 或 --beautify - 输出格式化代码，当传入该参数，下面的附加选项用于更美观的控制格式化：</p><ul><li>-i N 或 --indent N - 缩进级别（空格数量）</li><li>-q 或 --quote-keys - 是否用引号引起字符串对象的键（默认只会引起不能被正确标志的键名）</li></ul><p>　　--ascii -默认 UglifyJS 不处理字符编码而直接输出 Unicode 字符，通过传入该参数将非ASCII编码的字符转化为\cXXXX的序列（输出总按照UTF8编码，但传入该选项能得到ASCII编码的输出）。</p><p>　　-nm 或 --no-mangle - 不改变变量名称</p><p>　　-ns 或 --no-squeeze - 不调用 ast_squeeze() 函数（该函数会做多种优化使得结果更小，可读性略有降低）</p><p>　　-mt 或 --mangle-toplevel - 在顶级作用域打乱变量名称（默认不开启）</p><p>　　--no-seqs - 当调用 ast_squeeze() 将会合并多个语句块为一个语句块，如 "a=10; b=20; foo()" 将被转换为 "a=10,b=20,foo()"</p><p>　　--no-dead-code - 默认 UglifyJS 将会删除不被用到的代码，传入该参数禁用此功能。</p><p>　　-nc 或 --no-copyright - 默认 uglifyjs 会在输出后的代码中添加版权信息等注释代码，传入该参数禁用此功能。</p><p>　　-o 文件名 或 --output 文件名 - 指定输出文件名，如果不指定，则打印到标准输出（STDOUT）</p><p>　　--overwrite - 如果传入的JS代码来自文件而不是标准输入，传入该参数，输出会覆盖该文件。</p><p>　　--ast - 传入该参数会得到抽象的语法树而不是Javascript，对调试或了解内部代码很有用。</p><p>　　-v 或 --verbose - 在标准错误输出一些信息（目前的版本仅输出操作用时）</p><p>　　--extra - 开启附加优化，这些优化并未得到全面的测试。</p><p>　　--unsafe - 开启其他附加优化，这些优化已知在特定情况下并不安全，目前仅支持：foo.toString() ==&gt; foo+””</p><p>　　--max-line-len （默认32K字节） - 在32K字节出增加换行符，传入0禁用此功能。</p><p>　　--reserved-names - 一些类库会依赖一些变量，该参数指定的名称不会被混淆掉，多个用逗号隔开</p><p>　　<strong>下面是我们使用uglifyjs</strong><strong>压缩，PetConfigParser.js</strong><strong>的例子：</strong></p><p>　　uglifyjs -nc -mt PetConfigParser.js &gt; PetConfigParser.min.js</p><p align="center">PetConfigParser.js压缩前后对比</p><table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td valign="top" width="61"><p align="center"><strong>压缩前</strong></p></td><td valign="top" width="506"> <img src="http://pic001.cnblogs.com/images/2012/24634/2012082715542090.jpg" alt=""></td></tr><tr><td valign="top" width="61"><p align="center"><strong>压缩后</strong></p></td><td valign="top" width="506"> <img src="http://pic001.cnblogs.com/images/2012/24634/2012082715542511.png" alt=""></td></tr></tbody></table><p>　　<strong>JavaScript文件合并</strong></p><p align="right"><em>规则1</em><em>——减少HTTP</em><em>请求（Minimize HTTP Requests</em><em>）</em></p><p align="right"><em>Yahoo</em><em>前端优化性能规则</em><em>[5]</em></p><p align="justify">　　只有10%～20%的最终用户响应时间花在接收请求的HTML文档上，剩下的80%～90%时间都花在HTML文档所引用的所有组件（图片、脚本、样式表、Flash等）进行的HTTP请求上。因此，改善响应时间最简单的办法就是减少组件数量并由此减少HTTP请求数。</p><p>　　<strong>对公共库合并压缩在减少size</strong><strong>的同时，减少http</strong><strong>请求优化网络耗时提升性能。</strong></p><p>　　<strong>文档生成</strong></p><p>　　YUIDoc 是一个基于 Node.js 的应用程序，用来根据 JavaScript 的注释中生成 API 文档，类似 JavaDoc、ASDoc，这也是当前 YUI 用来生成文档的工具。</p><p>　　<strong>YUIDoc安装与使用</strong></p><p>　　YUIDoc安装</p><p>　　与UglifyJS一样，YUIDoc也是基于Nodejs的一个应用程序，使用npm安装即可。</p><p>　　npm -g install yuidocjs.</p><p>　　校验安装是否成功</p><p>　　C:\Users\tyler&gt;yuidoc -v 0. 3.15</p><p>　　生成文档（一次性生成）</p><p>　　yuidoc .</p><p>　　一次性生成该目录及其子目录下所有JS的文档 默认在不配置的情况下会生成在当前目录的out目录中。</p><p>　　-o, --out &lt;directory path&gt; Path to put the generated files (defaults to ./out)</p><p>　　生成文档（实时生成）</p><p>　　YUIDoc还提供了一种实时文档生成的方式，有利于团队协作开发 比如在SVN上部署YUIDoc实时文档，递交到SVN的代码都会及时生成文档提供团队使用查阅</p><p>　　yuidoc --server</p><p>　　默认开放监听当前目录文件变动，开放3000端口 可以通过</p><p>　　http://127.0.0.1:3000/</p><p>　　来访问文档 如果3000端口被占用，也可以指定特定端口号</p><p>　　yuidoc --server 5000</p><p>　　来通过开放5000端口提供文档访问</p><p>　　<strong>YUIDoc标签</strong></p><p>　　要使用YUIDoc，那么所有注释都得安装YUIDoc的标准来，否则不能正确解析出文档。YUIDoc使用的标签和其它语言类同，比较容易理解。下面不详细说明每个标签，只列举几个例子，具体可参加官方文档。例如：</p><p>　　对PetConfigParser类进行注释：</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#000000">/**<br> * 宝宝配置文件解析，及提供查询宝宝配置相关的操作方法&lt;br/&gt;<br> * </span>1<span style="color:#000000">. getPetById 根据宝宝id获取对应宝宝的信息&lt;br/&gt;<br> * </span>2<span style="color:#000000">. getPetName 根据宝宝的id，读取宝宝信息，然后拼接出宝宝的名字，如3+10天蝎宝宝&lt;br/&gt;<br> * 等等&lt;br/&gt;<br> * @author tylerzhu<br> * @class PetConfigParser<br> * @static<br> */</span> </div><p>　　对类中的变量进行注释：</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#000000"><span style="color:#000000">/</span>**<br>* 宝宝所有配置字典，以【cate * </span>10000 + (lvl - 1) * 10 + dex - 1<span style="color:#000000">】为key<br>* @attribute    petDic<br>* @type {Object}<br>* @private<br>*/</span> </div><p>　　对类中函数进行注释：</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#000000">/**<br>* 根据宝宝id，读取__pet_config中对应宝宝的信息<br>* @method getPetById<br>* @param   {String/int} petId 宝宝id<br>* @return  {Object} pet 宝宝的所有静态信息，如{id:</span>"300003289"， lvl:"1"， dex:"2"， price:"200"， life:"2592000"， cate:"3"， name:"飞天小使等级1熟练2"， intro:""， skill:"护身符"， skill1_prob:"30"， skill2_prob:"0"<span style="color:#000000">}<br>*/</span> </div><p style="text-align:left" align="center">　　默认生成的文档样式如下：</p><p>　　<strong>参考链接、进一步阅读</strong></p><p>　　[1]NodeJS，<a href="http://nodejs.org/"><span style="text-decoration:underline">http://nodejs.org/</span></a></p><p>　　[2]UglifyJS，<a href="https://github.com/mishoo/UglifyJS/"><span style="text-decoration:underline">https://github.com/mishoo/UglifyJS/</span></a></p><p>　　[3]用UglifyJS解析/压缩/格式化你的Javascript，<a href="http://goo.gl/bwf8U"><span style="text-decoration:underline">http://goo.gl/bwf8U</span></a></p><p>　　[4]Yahoo前端优化性能规则，<a href="http://goo.gl/nfEBg"><span style="text-decoration:underline">http://goo.gl/nfEBg</span></a></p><p>　　[5]用YUIDoc文档化JavaScript代码，<a href="http://goo.gl/5RJxn"><span style="text-decoration:underline">http://goo.gl/5RJxn</span></a></p><p>　　[6]YUIDoc官方，<a href="http://yui.github.com/yuidoc/"><span style="text-decoration:underline">http://yui.github.com/yuidoc/</span></a></p>