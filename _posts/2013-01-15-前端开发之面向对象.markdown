---
layout: post
title:  "前端开发之面向对象"
date:   2013-01-15 13:38:50
author: 
categories: program
---

## 前端开发之面向对象
### by 
### at 2013-01-15 13:38:50
### original <http://kb.cnblogs.com/page/160908/>

<p>　　<strong>【一】 面向对象的基本概念</strong></p><p>　　面向对象的英文全称叫做Object Oriented，简称OO。OO其实包括OOA(Object Oriented Analysis，面向对象分析)、OOD(Object Oriented Design，面向对象设计)和OOP(Object Oriented Programming，面向对象的程序设计)。</p><p>　　通常所说的面向对象是指OOP, OOP是一种围绕真实世界的概念来组织模型的程序设计方法，它采用对象来描述问题空间的实体。在使用计算机解决问题时，<strong>对象是作为计算机模拟真实世界的一个抽象，一个对象就是一个物理实体或逻辑实体，它反映了系统为之保存信息和（或）与它交互的能力</strong>。使其具有自己的属性和行为， 从而简化对复杂事物的描述，更有利于工程的可维护性和扩展性。</p><p>　　OOP同结构化程序设计相比最大的区别就在于: 前者首先关心的是所要处理的数据，而后者首先关心的是功能。</p><p>　　<strong>【二】 面向对象三个基本特征</strong></p><p>　　封装 (Encapsulation) 将数据以及相关的操作组织在一起，成为独立的构件。外部无法直接访问这些封装了的数据，从而保证了这些数据的正确性。封装的目的是为了<strong>内部数据表现形式和实现细节的隐藏</strong>，信息隐藏是为了减少系统各部分间的依赖性，各部分间必须通过明确的通道传送信息，也就是对象间的接口.这样一来，隐藏了部分内部的细节，极大方便系统的开发，维护和扩展。</p><p>　　继承 (Inheritance) 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它<strong>提供了一种明确表述共性的方法</strong>。一个新类可以从现有的类中派生，这个过程称为类的继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。<strong>派生类可以从它的基类那里继承方法和实例变量</strong>，并且派生类可以修改或增加新的方法使之更适合特殊的需求。继承性很好地解决了软件的可重用性问题。</p><p>　　多态 (Polymorphism) 多态是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是允许类与类之间相同方法名的指针得以调用， 这样很好地<strong>解决了应用程序函数同名问题</strong>。实现多态，有二种方式，覆盖，重载。</p><p>　　<strong>【三】 Javascript 面向对象</strong></p><p>　　javascript本身是一种基于对象(object-based)的语言，我们日常编码过程中用到的所有东西几乎都是对象(Number, String, Boolean, etc.)。但是，相对于一些流行的面向对象语言(C++, C#, java)，它又不是一种真正的面向对象编程(OOP)语言，因为它的语法中没有class的概念。</p><p>　　Keyword: class, object, `this`, closure, constructor, prototype</p><p>　　几种对象封装的方法</p><ul><li>继承</li><li>多态体现</li></ul><p>　　<strong>之一、几种对象封装的方法</strong></p><p>　　<strong>1. 对象封装 – 原始模式</strong></p><p>　　假定我们把猫看成一个对象，它有”name”和”color”两个属性， “etc” 行为。</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> Cat =<span style="color:#000000"> {<br>    name: </span>''<span style="color:#000000"><br>    color: </span>''<span style="color:#000000">,<br>    eat: </span><span style="color:#0000ff">function</span><span style="color:#000000">() {}<br>};</span> </div><p>　　现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象。</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> eat() {<br>    console.log(</span>'I\'m eta fish'<span style="color:#000000">);<br>}<br></span><span style="color:#0000ff">var</span> cat1 = {name: 'Kitty', color: 'white'<span style="color:#000000">, eat: eat};<br></span><span style="color:#0000ff">var</span> cat2 = {name: 'Smokey', color: 'black'<span style="color:#000000">, eat: eat}; <br></span><span style="color:#008000">//</span><span style="color:#008000"> var cat3, cat4 ,...</span> </div><p>　　不方便创建多个实例对象，扩展性差， 实例(cat1, cat2)之间找不到联系。…</p><p>　　<strong>2. 对象封装 – 构造函数模式</strong></p><p>　　“构造函数”，就是一个普通函数，但是内部使用了 `this` 变量。对函数使用 `new` 运算符，就能生成实例，并且 `this` 变量会绑定在实例对象上。</p><p>　　使用构造器创建出来的对象会有一个 `constructor` 属性，指向它们的构造函数。</p><p>　　`Class` 只是一个模板，创建出来的来实例都是由模板生成。</p><p>　　比如，猫的原型对象现在可以这样写:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> Cat(name,color){<br></span><span style="color:#0000ff">    this</span>.name =<span style="color:#000000"> name;<br></span><span style="color:#0000ff">    this</span>.color =<span style="color:#000000"> color;<br>    </span><span style="color:#0000ff">this</span>.eat = <span style="color:#0000ff">function</span>() { console.log('eat fish'<span style="color:#000000">); };<br>}<br> <br></span><span style="color:#0000ff">var</span> cat1 = <span style="color:#0000ff">new</span> Cat('Kitty', 'black'<span style="color:#000000">);<br>console.log(cat1.name); </span><span style="color:#008000">//</span><span style="color:#008000"> Kitty</span><br>console.log(cat1 <span style="color:#0000ff">instanceof</span> Cat); <span style="color:#008000">//</span><span style="color:#008000"> TRUE</span><span style="color:#008000"><br>//</span><span style="color:#008000"> 这时 cat1 实例会自动含有一个 `constructor` 属性，指向它们的构造函数 `Cat`。</span><br> <br><span style="color:#0000ff">var</span> cat2 = Cat('Smokey', 'white'<span style="color:#000000">);<br>console.log(cat2); </span><span style="color:#008000">//</span><span style="color:#008000"> undefined</span> </div><p>　<strong>　3. 对象封装 – Prototype 模式</strong></p><p>　　`prototype` 是 `Function` 对象的一个属性，这个属性指向另一个对象。 这个对象的所有属性和方法，都会被构造函数的实例继承。</p><p>　　同时 `prototype` 又存在一个指向构造函数的引用 `constructor`，这样就成功的构成一个循环引用的原型链结构。</p><p>　　我们可以把那些不变的属性和方法，直接定义在 `prototype` 对象上， 节省内存开销。</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> Cat(name, color) {<br>    </span><span style="color:#0000ff">this</span>.name =<span style="color:#000000"> name;<br>    </span><span style="color:#0000ff">this</span>.color =<span style="color:#000000"> color;<br>}<br>Cat.prototype.type </span>= 'mammal'<span style="color:#000000">;<br>Cat.prototype.eat </span>= <span style="color:#0000ff">function</span>() { console.log('eat fish'<span style="color:#000000">); };<br> <br></span><span style="color:#0000ff">var</span> cat1 = <span style="color:#0000ff">new</span> Cat('Kitty', 'white'<span style="color:#000000">);<br></span><span style="color:#0000ff">var</span> cat2 = <span style="color:#0000ff">new</span> Cat('Smokey', 'black'<span style="color:#000000">);<br>console.log(cat1.type); </span><span style="color:#008000">//</span><span style="color:#008000"> mammal</span><br>console.log(cat1.eta === cat2.eta);     <span style="color:#008000">//</span><span style="color:#008000"> TRUE, same reference</span><br>console.log(cat1.constructor === Cat)   <span style="color:#008000">//</span><span style="color:#008000"> TRUE, from Person.prototype</span> </div><p>　　<strong>之二、继承 (Inheritance)</strong></p><p>　　将持有共性特点的属性或行为抽象出一个基本类， 可以按不同层次结构的业务分组抽象出多个基础类。</p><p>　　Cat, Bird</p><p style="text-align:center"><img src="http://pic001.cnblogs.com/images/2012/24634/2012102411055010.png" alt=""></p><p>　　<strong>1. 继承 – 构造函数绑定</strong></p><p>　　使用call或apply方法，将父对象的构造函数绑定在子对象上。</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> Animal() {<br>    </span><span style="color:#0000ff">this</span>.species = 'animal'<span style="color:#000000">;<br>    </span><span style="color:#0000ff">this</span>.sleep = <span style="color:#0000ff">function</span>() { console.log('I\'m sleep at night'<span style="color:#000000">); };<br>}<br> <br></span><span style="color:#0000ff">function</span><span style="color:#000000"> Cat(name, color) {<br>    </span><span style="color:#0000ff">this</span>.name =<span style="color:#000000"> name;<br>    </span><span style="color:#0000ff">this</span>.color =<span style="color:#000000"> color;<br>}</span> </div><p>　　让`Cat` 继承 `Animal` 的特性:</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#008000">/*</span><span style="color:#008000">* @class Cat </span><span style="color:#008000">*/</span><br><span style="color:#0000ff">function</span><span style="color:#000000"> Cat(name, color) {<br>    Animal.apply(</span><span style="color:#0000ff">this</span><span style="color:#000000">);<br>    </span><span style="color:#0000ff">this</span>.name =<span style="color:#000000"> name;<br>    </span><span style="color:#0000ff">this</span>.color =<span style="color:#000000"> color;<br>}<br></span><span style="color:#0000ff">var</span> cat1 = <span style="color:#0000ff">new</span> Cat('Kitty', 'white'<span style="color:#000000">);<br>cat1.sleep(); </span><span style="color:#008000">//</span><span style="color:#008000"> I am sleep at night</span> </div><p>　　<strong>2. 继承 – 原型链继承</strong></p><p>　　如果”猫”的prototype对象，指向一个Animal的实例，那么所有”猫”的实例，就能继承Animal了。</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#008000">/*</span><span style="color:#008000">* @class Cat </span><span style="color:#008000">*/</span><br><span style="color:#0000ff">function</span><span style="color:#000000"> Cat(name, color) {<br>    </span><span style="color:#0000ff">this</span>.name =<span style="color:#000000"> name;<br>    </span><span style="color:#0000ff">this</span>.color =<span style="color:#000000"> color;<br>}<br>Cat.prototype </span>= <span style="color:#0000ff">new</span><span style="color:#000000"> Animal;<br>Cat.prototype.eta </span>= <span style="color:#0000ff">function</span>() { console.log('fish is my delicious'); }; </div><p>　　它相当于完全删除了prototype 对象原先的值，然后赋予一个新值</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#008000">//</span><span style="color:#008000"> 任何一个prototype对象都有一个constructor属性，指向它的构造函数</span><br>Cat.prototype.constructor = Cat; <span style="color:#008000">//</span><span style="color:#008000"> fix prototype chains</span><br> <br><span style="color:#0000ff">var</span> cat = <span style="color:#0000ff">new</span> Cat('Kitty', 'fish'<span style="color:#000000">);<br>cat.eat();      </span><span style="color:#008000">//</span><span style="color:#008000"> fish is my delicious</span><br>cat.sleep();    <span style="color:#008000">//</span><span style="color:#008000"> I'm sleep at night'</span><br>console.log(cat <span style="color:#0000ff">instanceof</span> Cat);    <span style="color:#008000">//</span><span style="color:#008000"> TRUE</span><br>console.log(cat <span style="color:#0000ff">instanceof</span> Animal); <span style="color:#008000">//</span><span style="color:#008000"> TRUE</span> </div><p>　　需要创建父类实列来实现 `prototype` 继承</p><p>　　<strong>3. 继承 (Inheritance) – 利用空对象作为中介实现原型继承</strong></p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">var</span> F = <span style="color:#0000ff">function</span><span style="color:#000000">() {};<br>F.prototype </span>=<span style="color:#000000"> Animal.prototype;<br>Cat.prototype </span>= <span style="color:#0000ff">new</span><span style="color:#000000"> F();<br>Cat.prototype.constructor </span>= Cat; </div><p>　　我们将上面的方法，封装成一个函数，便于使用。</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#0000ff">function</span><span style="color:#000000"> extend(ctor, superctor, px) {<br>    </span><span style="color:#0000ff">if</span> (!superctor || !ctor) <span style="color:#0000ff">throw</span> Error('extend failed, verify dependencies'<span style="color:#000000">);<br>    </span><span style="color:#0000ff">var</span> F = <span style="color:#0000ff">function</span><span style="color:#000000">() {};<br>    F.prototype </span>=<span style="color:#000000"> superctor.prototype;<br>    ctor.prototype </span>= <span style="color:#0000ff">new</span><span style="color:#000000"> F();<br>    ctor.prototype.constructor </span>=<span style="color:#000000"> ctor;<br>    ctor.superclass </span>= superctor.prototype; <span style="color:#008000">//</span><span style="color:#008000"> cache super class proto reference.</span><br>    <span style="color:#0000ff">if</span> (px) { <span style="color:#008000">//</span><span style="color:#008000"> extend class implements</span><br>        <span>for</span> (<span style="color:#0000ff">var</span> k <span style="color:#0000ff">in</span><span style="color:#000000"> px) {<br>            </span><span style="color:#0000ff">if</span> (px.hasOwnProperty(k)) ctor.prototype[k] =<span style="color:#000000"> px[k];<br>        }<br>    }<br>    </span><span style="color:#0000ff">return</span><span style="color:#000000"> ctor;<br>}</span> </div><p>　　<strong>4 继承 – 借住工具方法实现继承</strong></p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#008000">/*</span><span style="color:#008000">* @class Mammal </span><span style="color:#008000">*/</span><span style="color:#000000"><br>extend(Cat, Animal, {<br>    eat: </span><span style="color:#0000ff">function</span><span style="color:#000000">() {<br>        Cat.superclass.eat.call(</span><span style="color:#0000ff">this</span>); <span style="color:#008000">//</span><span style="color:#008000"> call super method</span><br>        console.log('Also i like some ofther food, such as beef and more.'<span style="color:#000000">);<br>    }<br>});<br> <br></span><span style="color:#0000ff">var</span> cat = <span style="color:#0000ff">new</span> Cat('Smokey', 'fish'<span style="color:#000000">);<br>cat.sleep();<br>cat.eat();<br>console.log(cat </span><span style="color:#0000ff">instanceof</span><span style="color:#000000"> Animal);<br>console.log(cat </span><span style="color:#0000ff">instanceof</span> Cat); </div><p>　　<strong>之三、多态</strong></p><p>　　<strong>1. 多态 – 通过重写原型方法来实现方法重名调用</strong></p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><span style="color:#008000">/*</span><span style="color:#008000">* @class Cat </span><span style="color:#008000">*/</span><span style="color:#000000"><br>extend(Cat, Animal, {<br>    eat: </span><span style="color:#0000ff">function</span><span style="color:#000000">() {<br>        Cat.superclass.eat.call(</span><span style="color:#0000ff">this</span>); <span style="color:#008000">//</span><span style="color:#008000"> call super method</span><br>        console.log('Also i like some ofther food, such as beef and more.'<span style="color:#000000">);<br>    }<br>});</span> </div><p>　　<strong>2. 多态 (Polymorphism) – 原型继承 `prototype` 链上的方法、属性查找</strong></p><p><img style="display:block;margin-left:auto;margin-right:auto" src="http://pic001.cnblogs.com/images/2012/24634/2012102411055973.png" alt=""></p><p>　<strong>　【四】总结 Summary</strong></p><p>　　Constructor</p><p>　　Prototype</p><p>　　Inheritance</p>