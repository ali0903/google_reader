---
layout: post
title:  "JavaScript中__proto__与prototype的关系"
date:   2012-09-01 10:31:00
author: snandy
categories: program
---

## JavaScript中__proto__与prototype的关系
### by snandy
### at 2012-09-01 10:31:00
### original <http://www.cnblogs.com/snandy/archive/2012/09/01/2664134.html>

<p>这里讨论下对象的内部原型(<a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/proto">__proto__</a>)和构造器的原型（prototype）的关系。</p><p> </p><p><strong><strong>一、所有构造器/函数的__proto__都指向Function.prototype，它是一个空函数（Empty function）</strong></strong></p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">Number.__proto__ === Function.prototype  // true<br>Boolean.__proto__ === Function.prototype // true<br>String.__proto__ === Function.prototype  // true<br>Object.__proto__ === Function.prototype  // true<br>Function.__proto__ === Function.prototype // true <br>Array.__proto__ === Function.prototype   // true<br>RegExp.__proto__ === Function.prototype  // true<br>Error.__proto__ === Function.prototype   // true<br>Date.__proto__ === Function.prototype    // true<br></div><p> </p><p>JavaScript中有内置(build-in)构造器/对象共计12个（<a href="http://kangax.github.com/es5-compat-table/">ES5</a>中新加了JSON），这里列举了可访问的8个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。它们的__proto__是Object.prototype。如下</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">Math.__proto__ === Object.prototype  // true <br>JSON.__proto__ === Object.prototype  // true<br></div><p> </p><p>上面说的“所有构造器/函数”当然包括自定义的。如下</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">// 函数声明<br>function Person() {}<br>// 函数表达式<br>var Man = function() {}<br>console.log(Person.__proto__ === Function.prototype) // true<br>console.log(Man.__proto__ === Function.prototype)    // true<br></div><p> </p><p>这说明什么呢？</p><p>所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了Function.prototype的属性及方法。如length、call、apply、bind（ES5）。</p><p> </p><p>Function.prototype也是唯一一个typeof XXX.prototype为 “function”的prototype。其它的构造器的prototype都是一个对象。如下</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">console.log(typeof Function.prototype) // function<br>console.log(typeof Object.prototype)   // object<br>console.log(typeof Number.prototype)   // object<br>console.log(typeof Boolean.prototype)  // object<br>console.log(typeof String.prototype)   // object<br>console.log(typeof Array.prototype)    // object<br>console.log(typeof RegExp.prototype)   // object<br>console.log(typeof Error.prototype)    // object<br>console.log(typeof Date.prototype)     // object<br>console.log(typeof Object.prototype)   // object<br></div><p>　　</p><p>噢，上面还提到它是一个空的函数，alert(Function.prototype) 下看看。</p><p> </p><p>知道了所有构造器（含内置及自定义）的__proto__都是Function.prototype，那Function.prototype的__proto__是谁呢？</p><p> </p><p>相信都听说过JavaScript中函数也是一等公民，那从哪能体现呢？如下</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">console.log(Function.prototype.__proto__ === Object.prototype) // true<br></div><p>这说明所有的构造器也都是一个普通JS对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。</p><p> </p><p>最后Object.prototype的__proto__是谁？</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">Object.prototype.__proto__ === null  // true<br></div><p>已经到顶了，为null。</p><p> </p><p><strong><strong>二、所有对象的__proto__都指向其构造器的prototype</strong></strong></p><p>上面测试了所有内置构造器及自定义构造器的__proto__，下面再看看所有这些构造器的实例对象的__proto__指向谁？</p><p> </p><p>先看看JavaScript引擎内置构造器</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">var obj = {name: 'jack'}<br>var arr = [1,2,3]<br>var reg = /hello/g<br>var date = new Date<br>var err = new Error('exception')<br><br>console.log(obj.__proto__ === Object.prototype) // true<br>console.log(arr.__proto__ === Array.prototype)  // true<br>console.log(reg.__proto__ === RegExp.prototype) // true<br>console.log(date.__proto__ === Date.prototype)  // true<br>console.log(err.__proto__ === Error.prototype)  // true<br></div><p> </p><p>再看看自定义的构造器，这里定义了一个Person</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">function Person(name) {<br>this.name = name<br>}<br>var p = new Person('jack')<br>console.log(p.__proto__ === Person.prototype) // true<br></div><p>p是Person的实例对象，p的内部原型总是指向其构造器Person的prototype。</p><p> </p><p>每个对象都有一个constructor属性，可以获取它的构造器，因此以下打印结果也是恒等的</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">function Person(name) {<br>this.name = name<br>}<br>var p = new Person('jack')<br>console.log(p.__proto__ === p.constructor.prototype) // true<br></div><p> </p><p>上面的Person没有给其原型添加属性或方法，这里给其原型添加一个getName方法</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">function Person(name) {<br>this.name = name<br>}<br>// 修改原型<br>Person.prototype.getName = function() {}<br>var p = new Person('jack')<br>console.log(p.__proto__ === Person.prototype) // true<br>console.log(p.__proto__ === p.constructor.prototype) // true<br></div><p>可以看到p.__proto__与Person.prototype，p.constructor.prototype都是恒等的，即都指向同一个对象。</p><p> </p><p>如果换一种方式设置原型，结果就有些不同了</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">function Person(name) {<br>this.name = name<br>}<br>// 重写原型<br>Person.prototype = {<br>getName: function() {}<br>}<br>var p = new Person('jack')<br>console.log(p.__proto__ === Person.prototype) // true<br>console.log(p.__proto__ === p.constructor.prototype) // false<br></div><p>这里直接重写了Person.prototype（注意：上一个示例是修改原型）。输出结果可以看出p.__proto__仍然指向的是Person.prototype，而不是p.constructor.prototype。</p><p>这也很好理解，给Person.prototype赋值的是一个对象直接量{getName: function(){}}，使用对象直接量方式定义的对象其构造器（constructor）指向的是根构造器Object，Object.prototype是一个空对象{}，{}自然与{getName: function(){}}不等。如下</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">var p = {}<br>console.log(Object.prototype) // 为一个空的对象{}<br>console.log(p.constructor === Object) // 对象直接量方式定义的对象其constructor为Object<br>console.log(p.constructor.prototype === Object.prototype) // 为true，不解释 </div><p> </p><p>上面代码中用到的__proto__目前在IE6/7/8/9中都不支持。IE9中可以使用<a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf">Object.getPrototypeOf</a>(ES5)获取对象的内部原型。</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px">var p = {}<br>var __proto__ = Object.getPrototypeOf(p)<br>console.log(__proto__ === Object.prototype) // true<br></div><p>  </p><p>相关：</p><p><a href="http://www.cnblogs.com/snandy/archive/2011/03/23/1992080.html">JavaScript子类用Object.getPrototypeOf去调用父类方法</a></p><img src="http://www.cnblogs.com/snandy/aggbug/2664134.html?type=1" width="1" height="1" alt=""><p><a href="http://www.cnblogs.com/snandy/archive/2012/09/01/2664134.html">本文链接</a></p>