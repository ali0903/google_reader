---
layout: post
title:  "浅析node的buffer模块（三读取）"
date:   2013-05-08 15:37:41
author: snoopyxdy
categories: program
---

## 浅析node的buffer模块（三读取）
### by snoopyxdy
### at 2013-05-08 15:37:41
### original <http://snoopyxdy.blog.163.com/blog/static/601174402013480524058>

<div>最后我们看一下buffer的读取是如何进行的，buffer的读取主要包括以下几个api<div>1、buf = new Buffer()，然后就可以直接读取buf</div><div>2、buf.toString([encoding], [start], [end])<br><div>3、buf.toJSON()</div></div><div>4、buf[index]</div><div>5、buf.slice([start], [end])</div><div>6、<span style="line-height:22px">buf.readUInt8(offset, [noAssert])等其他read操作</span></div><div><span style="line-height:22px"><br></span></div><div><b><span style="line-height:22px">1、</span><span style="line-height:22px">buf = new Buffer() 和 </span><span style="line-height:22px">buf[index]</span></b></div><div>创建一个buf实例，会返回一个buf数组给这个实例，就像我们直接打印buf会出现以下内容：</div><div><pre><p></p><div><div>var buf = new Buffer(100)</div><div>console.log(buf)</div></div><div>//输出随机的一些16进制内存单元</div><div>&lt;Buffer 8b 42 0f 4d 8b 55 08 4c 39 50 ff 0f 85 61 00 00 00 48 3b 48 07 0f 83 26 01 00 00 48 8b d9 48 c1 fb 1d 48 8b 5c 18 0f 49 3b 5d b0 0f 84 10 01 00 00 48 8b ...&gt;</div><p></p></pre></div><div><span style="line-height:22px">通过 </span>Buffer::MakeFastBuffer 这个方法来关联起来的，我们看主要代码：</div><div><pre><p>Handle&lt;Value&gt; Buffer::MakeFastBuffer(const Arguments &amp;args) {<br>  HandleScope scope;<br><br>  if (!Buffer::HasInstance(args[0])) {<br>    return ThrowTypeError("First argument must be a Buffer");<br>  }<br><br>  Buffer *buffer = ObjectWrap::Unwrap&lt;Buffer&gt;(args[0]-&gt;ToObject());<br>  Local&lt;Object&gt; fast_buffer = args[1]-&gt;ToObject();;<br>  uint32_t offset = args[2]-&gt;Uint32Value();<br>  uint32_t length = args[3]-&gt;Uint32Value();<br><br>  // ..省略了一些验证代码<br>  </p><p>  //最主要是下面这句，将this关联索引属性<br>  fast_buffer-&gt;SetIndexedPropertiesToExternalArrayData(buffer-&gt;data_ + offset,<br>                                                       kExternalUnsignedByteArray,<br>                                                       length);<br><br>  return Undefined();<br>}</p></pre>这样我们的buf实例看起来就像是一个数组了</div><div><br></div><div><b>2、<span style="line-height:22px">buf.toString([encoding], [start], [end])</span></b></div><div><span style="line-height:22px">这个是我们读取buf最常用的方法，我们可以将一些字符串存入buf，然后使用toString方法将他们取出来。</span></div><div><div><pre><p></p><div>// toString(encoding, start=0, end=buffer.length)</div><div>Buffer.prototype.toString = function(encoding, start, end) {</div><div>  encoding = String(encoding || &#39;utf8&#39;).toLowerCase(); //将encoding参数小写</div><div><br></div><div>  if (typeof start !== &#39;number&#39; || start &lt; 0) { //将start参数合法化</div><div>    start = 0;</div><div>  } else if (start &gt; this.length) {</div><div>    start = this.length;</div><div>  }</div><div><br></div><div>  if (typeof end !== &#39;number&#39; || end &gt; this.length) { <span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">//将end参数合法化</span></div><div>    end = this.length;</div><div>  } else if (end &lt; 0) {</div><div>    end = 0;</div><div>  }</div><div><br></div><div>  start = start + this.offset; //加上偏移量，这个offset很重要，代表共享buffer的偏移</div><div>  end = end + this.offset;</div><div><br></div><div>  switch (encoding) {</div><div>    case &#39;hex&#39;:</div><div>      return this.parent.hexSlice(start, end);</div><div><br></div><div>    case &#39;utf8&#39;:</div><div>    case &#39;utf-8&#39;:</div><div>      return this.parent.utf8Slice(start, end); //我们主要看这个，utf8用的比较多</div><div><br></div><div>    case &#39;ascii&#39;:</div><div>      return this.parent.asciiSlice(start, end);</div><div><br></div><div>    case &#39;binary&#39;:</div><div>      return this.parent.binarySlice(start, end);</div><div><br></div><div>    case &#39;base64&#39;:</div><div>      return this.parent.base64Slice(start, end);</div><div><br></div><div>    case &#39;ucs2&#39;:</div><div>    case &#39;ucs-2&#39;:</div><div>    case &#39;utf16le&#39;:</div><div>    case &#39;utf-16le&#39;:</div><div>      return this.parent.ucs2Slice(start, end);</div><div><br></div><div>    default:</div><div>      throw new TypeError(&#39;Unknown encoding: &#39; + encoding);</div><div>  }</div><div>};</div><p></p></pre></div><div style="line-height:22px">C++代码</div></div><div><span style="line-height:22px"><div><br><pre><p></p><div>Handle&lt;Value&gt; Buffer::Utf8Slice(const Arguments &amp;args) {</div><div>  HandleScope scope;</div><div>  Buffer *parent = ObjectWrap::Unwrap&lt;Buffer&gt;(args.This());</div><div>  SLICE_ARGS(args[0], args[1])</div><div>  char *data = parent-&gt;data_ + start;</div><div>//static V8EXPORT Local&lt;String&gt; New (const char *data, int length=-1) V8手册上的说明</div><div>//分配一个新的string对象</div><div>  Local&lt;String&gt; string = String::New(data, end - start); //将char* 转为<span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">Local&lt;</span><span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">string&gt;</span></div><div>  return scope.Close(string);</div><div>}</div><p></p></pre></div><div>这样我们就拿到了utf-8格式的字符串了</div></span></div><div><span style="line-height:22px"><br></span></div><div><b><span style="line-height:22px">3、</span><span style="line-height:22px">buf.slice([start], [end])</span></b></div><div><span style="line-height:22px">这个是对buf进行剪切的功能，我们看下代码：</span></div><div><pre><p>// slice(start, end)<br>Buffer.prototype.slice = function(start, end) {<br>  var len = this.length; //合法性验证<br>  start = clamp(start, len, 0); //clamp函数也是做合法性验证的，会返回合适的start和end值<br>  end = clamp(end, len, len);<br>  return new Buffer(this.parent, end - start, start + this.offset); //最后slice是依靠重新创建一个buffer实例来完成剪切工作的<br>};</p></pre>然后可以参考buffer的构造函数来追踪slice的创建</div><div><br></div><div><b>4、总结</b></div><div><span style="line-height:22px">我们大致了解了buffer的工作机制之后，我们的日常工作有了一些注意，什么时候该用buffer，什么时候不该用，使用buffer应该注意哪些问题？</span></div><div><span style="line-height:22px"><b>1、什么时候该用buffer，什么时候不该用buffer</b></span></div><div><span style="line-height:22px">写入速度的测试：</span></div><div><pre><p>var string,string2,string3;<br>var bufstr,bufstr2,bufstr3;<br>var j;<br><br>console.time('write 100 string')<br>for(j=0;j&lt;1000;j++){<br>	var x = j+'';<br>	string += x;<br>}<br>console.timeEnd('write 100 string')<br><br>console.time('write 100 buffer')<br>bufstr = new Buffer(100)<br>for(j=0;j&lt;1000;j++){<br>	var x = j+'';<br>	bufstr.write(x,j);<br>}<br>console.timeEnd('write 100 buffer')<br><br><br>console.time('write 100000 string')<br>for(j=0;j&lt;100000;j++){<br>	var x = j+'';<br>	string2 += x;<br>}<br>console.timeEnd('write 100000 string')<br><br>console.time('write 100000 buffer')<br>bufstr2 = new Buffer(100000)<br>for(j=0;j&lt;100000;j++){<br>	var x = j+'';<br>	bufstr2.write(x,j);<br>}<br>console.timeEnd('write 100000 buffer')<br><br><span style="line-height:22px;font-family:Arial,Helvetica,sans-serif">console.time('write 1024*1024*10 string')</span><br>for(j=0;j&lt;1024*1024*10;j++){<br>	var x = j+'';<br>	string3 += x;<br>}<br>console.timeEnd('write 1024*1024*10 string')<br><br>console.time('write 1024*1024*10 buffer')<br>bufstr3 = new Buffer(1024*1024*10)<br>for(j=0;j&lt;1024*1024*10;j++){<br>	var x = j+'';<br>	bufstr3.write(x,j);<br>}<br>console.timeEnd('write 1024*1024*10 buffer')<br></p><div><br></div></pre></div><div><pre><p>write 100 string: 0ms<br>write 100 buffer: 6ms<br>write 100000 string: 37ms<br>write 100000 buffer: 150ms<br>write 1024*1024*10 string: 4262ms<br>write 1024*1024*10 buffer: 8904ms</p></pre>读取速度都不需要测试了，肯定string更快，buffer还需要toString()的操作。</div><div>所以我们在保存字符串的时候，该用string还是要用string，就算大字符串拼接string的速度也不会比buffer慢。</div><div>那什么时候我们又需要用buffer呢？没办法的时候，当我们保存非utf-8字符串，2进制等等其他格式的时候，我们就必须得使用了。</div><div><br></div><div><b>2、buffer不得不提的8KB</b></div><div>buffer著名的8KB载体，举个例子好比，node把一幢大房子分成很多小房间，每个房间能容纳8个人，为了保证房间的充分使用，只有当一个房间塞满8个人后才会去开新的房间，但是当一次性有多个人来入住，node会保证要把这些人放到一个房间中，比如当前房间A有4个人住，但是一下子来了5个人，所以node不得不新开一间房间B，把这5个人安顿下来，此时又来了4个人，发现5个人的B房间也容纳不下了，只能再开一间房间C了，这样所有人都安顿下来了。但是之前的两间房A和B都各自浪费了4个和3个位置，而房间C就成为了当前的房间。</div><div><br></div><div>具体点说就是当我们实例化一个新的Buffer类，会根据实例化时的大小去申请内存空间，如果需要的空间小于8KB，则会多一次判定，判定当前的8KB载体剩余容量是否够新的buffer实例，如果够用，则将新的buffer实例保存在当前的8KB载体中，并且更新剩余的空间。</div><div><br></div><div>之前我的博客中有模拟过一个比较严重的buffer内存泄露情况，所以一定要注意，就算只有1byte的buffer空间没释放掉，整个8KB的内存都不会被V8释放。</div><div><br></div><div><b>3、buffer字符串的连接</b></div><div>在我们接受post数据时，node是以流的形式发送上来的，会触发ondata事件，所以我们见到很多代码是这样写的：</div><div><pre><p> var http = require('http');<br> http.createServer(function (req, res) {<br>  <br>  var body = '';<br>  req.on('data',function(chunk){<br>	//console.log(Buffer.isBuffer(chunk))<br>	body +=chunk<br>  })<br>  req.on('end',function(){<br>	 console.log(body)<br>	 res.writeHead(200, {'Content-Type': 'text/plain'});<br>         res.end('Hello World\n');<br>  })<br>  <br> <br>}).listen(8124);<br><br>console.log('Server running at http://127.0.0.1:8124/');</p></pre>下面我们比较一下两者的性能区别：</div><div><pre><p>var buf = new Buffer(&#39;nodejsv0.10.4&amp;nodejsv0.10.4&amp;nodejsv0.10.4&amp;nodejsv0.10.4&amp;&#39;);<br><br>console.time('string += buf')<br>var s = '';<br>for(var i=0;i&lt;10000;i++){<br>	s += buf;<br>}<br>s;<br>console.timeEnd('string += buf')<br><br><br>console.time('buf concat')<br>var list = [];<br>var len=0;<br>for(var i=0;i&lt;10000;i++){<br>	list.push(buf);<br>	len += buf.length;<br>}<br>var s2 = Buffer.concat(list, len).toString();<br>console.timeEnd('buf concat')</p></pre>输出结果：</div><div><pre><p>string += buf: 15ms<br>buf concat: 8ms</p></pre>在1000次拼接过程中，两者的性能几乎相差一倍，而且当客户上传的是非UTF8的字符串时，直接+=还容易出现错误。</div><div><br></div><div><b>4、独享的空间</b></div><div>如果你想创建一个独享的空间，独立的对这块内存空间进行读写，有两种办法，1是实例化一个超过8KB长度的buffer，另外一个就是使用slowbuffer类。</div><div><br></div><div><b>5、buffer的释放</b></div><div>很遗憾，我们无法手动对buffer实例进行GC，只能依靠V8来进行，我们唯一能做的就是解除对buffer实例的引用。</div><div><br></div><div><b>6、快速刷掉buffer</b></div>最快的方法就是buffer.fill</div>