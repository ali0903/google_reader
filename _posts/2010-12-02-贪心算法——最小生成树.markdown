---
layout: post
title:  "贪心算法——最小生成树"
date:   2010-12-02 12:37:00
author: chinazhangjie
categories: program
---

## 贪心算法——最小生成树
### by chinazhangjie
### at 2010-12-02 12:37:00
### original <http://www.cnblogs.com/chinazhangjie/archive/2010/12/02/1894314.html>

<p><p>设G = (V,E)是无向连通带权图，即一个网络。E中的每一条边（v,w）的权为c[v][w]。如果G的子图G’是一棵包含G的所有顶点的树，则称G’为G的<span style="color:#ff0000">生成树</span>。生成树上各边权的总和称为<span style="color:#ff0000">生成树的耗费</span>。在G的所有生成树中，耗费最小的生成树称为G的<span style="color:#ff0000">最小生成树</span>。构造最小生成树的两种方法：<strong>Prim算法和Kruskal算法</strong>。</p>
<h2>一、最小生成树的性质</h2>
<p>设G = (V,E)是连通带权图，U是V的真子集。如果(u,v)∈E,且u∈U,v∈V-U,且在所有这样的边中，(u,v)的权c[u][v]最小，那么一定存在G的一棵最小生成树，它意(u,v)为其中一条边。这个性质有时也称为MST性质。</p>
<h2>二、Prim算法</h2>
<p>设G = (V,E)是连通带权图，V = {1,2,…,n}。构造G的最小生成树Prim算法的基本思想是：<span style="color:#0000ff">首先置S = {1}，然后，只要S是V的真子集，就进行如下的贪心选择：选取满足条件i ∈S,j ∈V – S,且c[i][j]最小的边，将顶点j添加到S中。这个过程一直进行到S = V时为止。</span>在这个过程中选取到的所有边恰好构成G的一棵最小生成树。</p>
<p>如下带权图：</p>
<p><img src="http://pic002.cnblogs.com/images/2010/153357/2010120212285861.jpg" alt=""></p>
<p><strong>生成过程</strong>：</p>
<p><strong><span style="color:#339966">1 -&gt; 3 : 1</span></strong></p>
<p><strong><span style="color:#339966">3 -&gt; 6 : 4</span></strong></p>
<p><strong><span style="color:#339966">6 -&gt; 4: 2</span></strong></p>
<p><strong><span style="color:#339966">3 -&gt; 2 : 5</span></strong></p>
<p><strong><span style="color:#339966">2 -&gt; 5 : 3</span></strong></p>
<p><strong>实现</strong>：</p>
<p> </p>
<div><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""><span>代码</span>
<div>
<pre><div><span style="color:#008000">/*</span><span style="color:#008000"> 主题：贪心算法——最小生成树（Prim）<br>* 作者：chinazhangjie<br>* 邮箱：chinajiezhang@gmail.com<br>* 开发语言： C++<br>* 开发环境： Virsual Studio 2005<br>* 时间: 2010.11.30<br></span><span style="color:#008000">*/</span><span style="color:#000000"><br><br>#include </span><span style="color:#000000">&lt;</span><span style="color:#000000">iostream</span><span style="color:#000000">&gt;</span><span style="color:#000000"><br>#include </span><span style="color:#000000">&lt;</span><span style="color:#000000">vector</span><span style="color:#000000">&gt;</span><span style="color:#000000"><br>#include </span><span style="color:#000000">&lt;</span><span style="color:#000000">limits</span><span style="color:#000000">&gt;</span><span style="color:#000000"><br></span><span style="color:#0000ff">using</span><span style="color:#000000"> </span><span style="color:#0000ff">namespace</span><span style="color:#000000"> std ;<br><br></span><span style="color:#0000ff">struct</span><span style="color:#000000"> TreeNode<br>{<br></span><span style="color:#0000ff">public</span><span style="color:#000000">:<br>    TreeNode (</span><span style="color:#0000ff">int</span><span style="color:#000000"> nVertexIndexA </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">, </span><span style="color:#0000ff">int</span><span style="color:#000000"> nVertexIndexB </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">, </span><span style="color:#0000ff">int</span><span style="color:#000000"> nWeight </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">)<br>        : m_nVertexIndexA (nVertexIndexA),<br>        m_nVertexIndexB (nVertexIndexB),<br>        m_nWeight (nWeight)<br>    { }<br></span><span style="color:#0000ff">public</span><span style="color:#000000">:<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> m_nVertexIndexA ;<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> m_nVertexIndexB ;<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> m_nWeight ;<br>} ;<br><br></span><span style="color:#0000ff">class</span><span style="color:#000000"> MST_Prim<br>{<br></span><span style="color:#0000ff">public</span><span style="color:#000000">:<br>    MST_Prim (</span><span style="color:#0000ff">const</span><span style="color:#000000"> vector</span><span style="color:#000000">&lt;</span><span style="color:#000000">vector</span><span style="color:#000000">&lt;</span><span style="color:#0000ff">int</span><span style="color:#000000">&gt;</span><span style="color:#000000"> </span><span style="color:#000000">&gt;&amp;</span><span style="color:#000000"> vnGraph) <br>    {<br>        m_nvGraph </span><span style="color:#000000">=</span><span style="color:#000000"> vnGraph ;<br>        m_nNodeCount </span><span style="color:#000000">=</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000">)m_nvGraph.size () ;<br>    }<br>    </span><span style="color:#0000ff">void</span><span style="color:#000000"> DoPrim ()<br>    {<br>        </span><span style="color:#008000">//</span><span style="color:#008000"> 是否被访问标志</span><span style="color:#008000"><br></span><span style="color:#000000">        vector</span><span style="color:#000000">&lt;</span><span style="color:#0000ff">bool</span><span style="color:#000000">&gt;</span><span style="color:#000000"> bFlag (m_nNodeCount, </span><span style="color:#0000ff">false</span><span style="color:#000000">) ;<br>        bFlag[</span><span style="color:#800080">0</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#0000ff">true</span><span style="color:#000000"> ;<br><br>        </span><span style="color:#0000ff">int</span><span style="color:#000000"> nMaxIndexA ;<br>        </span><span style="color:#0000ff">int</span><span style="color:#000000"> nMaxIndexB ;<br>        </span><span style="color:#0000ff">int</span><span style="color:#000000"> j </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000"> ;<br>        </span><span style="color:#0000ff">while</span><span style="color:#000000"> (j </span><span style="color:#000000">&lt;</span><span style="color:#000000"> m_nNodeCount </span><span style="color:#000000">-</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">) {<br>            </span><span style="color:#0000ff">int</span><span style="color:#000000"> nMaxWeight </span><span style="color:#000000">=</span><span style="color:#000000"> numeric_limits</span><span style="color:#000000">&lt;</span><span style="color:#0000ff">int</span><span style="color:#000000">&gt;</span><span style="color:#000000">::max () ;<br>            </span><span style="color:#008000">//</span><span style="color:#008000"> 找到当前最短路径</span><span style="color:#008000"><br></span><span style="color:#000000">            </span><span style="color:#0000ff">int</span><span style="color:#000000"> i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000"> ;<br>            </span><span style="color:#0000ff">while</span><span style="color:#000000"> (i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> m_nNodeCount) {<br>                </span><span style="color:#0000ff">if</span><span style="color:#000000"> (</span><span style="color:#000000">!</span><span style="color:#000000">bFlag[i]) {<br>                    </span><span style="color:#000000">++</span><span style="color:#000000"> i ;<br>                    </span><span style="color:#0000ff">continue</span><span style="color:#000000"> ;<br>                }<br>                </span><span style="color:#0000ff">for</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000"> j </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">; j </span><span style="color:#000000">&lt;</span><span style="color:#000000"> m_nNodeCount; </span><span style="color:#000000">++</span><span style="color:#000000"> j) {<br>                    </span><span style="color:#0000ff">if</span><span style="color:#000000"> (</span><span style="color:#000000">!</span><span style="color:#000000">bFlag[j] </span><span style="color:#000000">&amp;&amp;</span><span style="color:#000000"> nMaxWeight </span><span style="color:#000000">&gt;</span><span style="color:#000000"> m_nvGraph[i][j]) {<br>                        nMaxWeight </span><span style="color:#000000">=</span><span style="color:#000000"> m_nvGraph[i][j] ;<br>                        nMaxIndexA </span><span style="color:#000000">=</span><span style="color:#000000"> i ;<br>                        nMaxIndexB </span><span style="color:#000000">=</span><span style="color:#000000"> j ;<br>                    } <br>                }<br>                </span><span style="color:#000000">++</span><span style="color:#000000"> i ;<br>            }<br>            bFlag[nMaxIndexB] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#0000ff">true</span><span style="color:#000000"> ;<br>            m_tnMSTree.push_back (TreeNode(nMaxIndexA, nMaxIndexB, nMaxWeight)) ;<br>            </span><span style="color:#000000">++</span><span style="color:#000000"> j ;<br>        }<br>        </span><span style="color:#008000">//</span><span style="color:#008000"> 输出结果</span><span style="color:#008000"><br></span><span style="color:#000000">        </span><span style="color:#0000ff">for</span><span style="color:#000000"> (vector</span><span style="color:#000000">&lt;</span><span style="color:#000000">TreeNode</span><span style="color:#000000">&gt;</span><span style="color:#000000">::const_iterator ite </span><span style="color:#000000">=</span><span style="color:#000000"> m_tnMSTree.begin() ;<br>                ite </span><span style="color:#000000">!=</span><span style="color:#000000"> m_tnMSTree.end() ;<br>                </span><span style="color:#000000">++</span><span style="color:#000000"> ite ) {<br>            cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> (</span><span style="color:#000000">*</span><span style="color:#000000">ite).m_nVertexIndexA </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> </span><span style="color:#800000">"</span><span style="color:#800000">-&gt;</span><span style="color:#800000">"</span><span style="color:#000000"> <br>                </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> (</span><span style="color:#000000">*</span><span style="color:#000000">ite).m_nVertexIndexB </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> </span><span style="color:#800000">"</span><span style="color:#800000"> : </span><span style="color:#800000">"</span><span style="color:#000000"><br>                </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> (</span><span style="color:#000000">*</span><span style="color:#000000">ite).m_nWeight </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> endl ;<br>        }<br>    }<br></span><span style="color:#0000ff">private</span><span style="color:#000000">:<br>    vector</span><span style="color:#000000">&lt;</span><span style="color:#000000">vector</span><span style="color:#000000">&lt;</span><span style="color:#0000ff">int</span><span style="color:#000000">&gt;</span><span style="color:#000000"> </span><span style="color:#000000">&gt;</span><span style="color:#000000"> m_nvGraph ;    </span><span style="color:#008000">//</span><span style="color:#008000"> 无向连通图</span><span style="color:#008000"><br></span><span style="color:#000000">    vector</span><span style="color:#000000">&lt;</span><span style="color:#000000">TreeNode</span><span style="color:#000000">&gt;</span><span style="color:#000000">    m_tnMSTree ;    </span><span style="color:#008000">//</span><span style="color:#008000"> 最小生成树</span><span style="color:#008000"><br></span><span style="color:#000000">    </span><span style="color:#0000ff">int</span><span style="color:#000000">    m_nNodeCount ;<br>} ;<br><br></span><span style="color:#0000ff">int</span><span style="color:#000000"> main()<br>{<br>    </span><span style="color:#0000ff">const</span><span style="color:#000000"> </span><span style="color:#0000ff">int</span><span style="color:#000000"> cnNodeCount </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">6</span><span style="color:#000000"> ;<br>    vector</span><span style="color:#000000">&lt;</span><span style="color:#000000">vector</span><span style="color:#000000">&lt;</span><span style="color:#0000ff">int</span><span style="color:#000000">&gt;</span><span style="color:#000000"> </span><span style="color:#000000">&gt;</span><span style="color:#000000"> graph (cnNodeCount) ;<br>    </span><span style="color:#0000ff">for</span><span style="color:#000000"> (size_t i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">; i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> graph.size() ; </span><span style="color:#000000">++</span><span style="color:#000000"> i) {<br>        graph[i].resize (cnNodeCount, numeric_limits</span><span style="color:#000000">&lt;</span><span style="color:#0000ff">int</span><span style="color:#000000">&gt;</span><span style="color:#000000">::max()) ;<br>    }<br>    graph[</span><span style="color:#800080">0</span><span style="color:#000000">][</span><span style="color:#800080">1</span><span style="color:#000000">]</span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">6</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">0</span><span style="color:#000000">][</span><span style="color:#800080">2</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">0</span><span style="color:#000000">][</span><span style="color:#800080">3</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">5</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">1</span><span style="color:#000000">][</span><span style="color:#800080">2</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">5</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">1</span><span style="color:#000000">][</span><span style="color:#800080">4</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">3</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">2</span><span style="color:#000000">][</span><span style="color:#800080">3</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">5</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">2</span><span style="color:#000000">][</span><span style="color:#800080">4</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">6</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">2</span><span style="color:#000000">][</span><span style="color:#800080">5</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">4</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">3</span><span style="color:#000000">][</span><span style="color:#800080">5</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">2</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">4</span><span style="color:#000000">][</span><span style="color:#800080">5</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">6</span><span style="color:#000000"> ;<br>    <br>    graph[</span><span style="color:#800080">1</span><span style="color:#000000">][</span><span style="color:#800080">0</span><span style="color:#000000">]</span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">6</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">2</span><span style="color:#000000">][</span><span style="color:#800080">0</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">3</span><span style="color:#000000">][</span><span style="color:#800080">0</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">5</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">2</span><span style="color:#000000">][</span><span style="color:#800080">1</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">5</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">4</span><span style="color:#000000">][</span><span style="color:#800080">1</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">3</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">3</span><span style="color:#000000">][</span><span style="color:#800080">2</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">5</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">4</span><span style="color:#000000">][</span><span style="color:#800080">2</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">6</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">5</span><span style="color:#000000">][</span><span style="color:#800080">2</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">4</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">5</span><span style="color:#000000">][</span><span style="color:#800080">3</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">2</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">5</span><span style="color:#000000">][</span><span style="color:#800080">4</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">6</span><span style="color:#000000"> ;<br><br>    MST_Prim mstp (graph) ;<br>    mstp.DoPrim () ;<br>     </span><span style="color:#0000ff">return</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000"> ;<br>}</span></div></pre>
</div>
</div>
<p> </p>
<p> </p>
<h2>三、Kruskal算法</h2>
<p>当图的边数为e时，Kruskal算法所需的时间是O(eloge)。<span style="color:#ff0000">当e = Ω(n^2)时，Kruskal算法比Prim算法差；但当e = o(n^2)时，Kruskal算法比Prim算法好得多</span>。</p>
<p>给定无向连同带权图G = (V,E),V = {1,2,...,n}。Kruskal算法构造G的最小生成树的基本思想是：</p>
<p>（<span style="color:#0000ff">1）首先将G的n个顶点看成n个孤立的连通分支。将所有的边按权从小大排序。</span></p>
<p><span style="color:#0000ff">（2）从第一条边开始，依边权递增的顺序检查每一条边。并按照下述方法连接两个不同的连通分支：当查看到第k条边(v,w)时，如果端点v和w分别是当前两个不同的连通分支T1和T2的端点是，就用边(v,w)将T1和T2连接成一个连通分支，然后继续查看第k+1条边；如果端点v和w在当前的同一个连通分支中，就直接再查看k+1条边。这个过程一个进行到只剩下一个连通分支时为止。</span></p>
<p>此时，已构成G的一棵最小生成树。</p>
<p>Kruskal算法的<strong>选边过程</strong>：</p>
<p><strong><span style="color:#339966">1 -&gt; 3 : 1</span></strong></p>
<p><strong><span style="color:#339966">4 -&gt; 6 : 2</span></strong></p>
<p><strong><span style="color:#339966">2 -&gt; 5 : 3</span></strong></p>
<p><strong><span style="color:#339966">3 -&gt; 4 : 4</span></strong></p>
<p><strong><span style="color:#339966">2 -&gt; 3 : 5</span></strong></p>
<p><strong>实现</strong>：</p>
<p> </p>
<div><img src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt=""><img src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt=""><span>代码</span>
<div>
<pre><div><span style="color:#008000">/*</span><span style="color:#008000"> 主题：贪心算法之最小生成树(Kruskal算法)<br>* 作者：chinazhangjie<br>* 邮箱：chinajiezhang@gmail.com<br>* 开发语言：C++<br>* 开发环境：Visual Studio 2005<br>* 时间：2010.12.01<br></span><span style="color:#008000">*/</span><span style="color:#000000"><br><br>#include </span><span style="color:#000000">&lt;</span><span style="color:#000000">iostream</span><span style="color:#000000">&gt;</span><span style="color:#000000"><br>#include </span><span style="color:#000000">&lt;</span><span style="color:#000000">vector</span><span style="color:#000000">&gt;</span><span style="color:#000000"><br>#include </span><span style="color:#000000">&lt;</span><span style="color:#000000">queue</span><span style="color:#000000">&gt;</span><span style="color:#000000"><br>#include </span><span style="color:#000000">&lt;</span><span style="color:#000000">limits</span><span style="color:#000000">&gt;</span><span style="color:#000000"><br></span><span style="color:#0000ff">using</span><span style="color:#000000"> </span><span style="color:#0000ff">namespace</span><span style="color:#000000"> std ;<br><br></span><span style="color:#0000ff">struct</span><span style="color:#000000"> TreeNode<br>{<br></span><span style="color:#0000ff">public</span><span style="color:#000000">:<br>    TreeNode (</span><span style="color:#0000ff">int</span><span style="color:#000000"> nVertexIndexA </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">, </span><span style="color:#0000ff">int</span><span style="color:#000000"> nVertexIndexB </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">, </span><span style="color:#0000ff">int</span><span style="color:#000000"> nWeight </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">)<br>        : m_nVertexIndexA (nVertexIndexA),<br>        m_nVertexIndexB (nVertexIndexB),<br>        m_nWeight (nWeight)<br>    { }<br>    friend <br>    </span><span style="color:#0000ff">bool</span><span style="color:#000000"> </span><span style="color:#0000ff">operator</span><span style="color:#000000"> </span><span style="color:#000000">&lt;</span><span style="color:#000000"> (</span><span style="color:#0000ff">const</span><span style="color:#000000"> TreeNode</span><span style="color:#000000">&amp;</span><span style="color:#000000"> lth, </span><span style="color:#0000ff">const</span><span style="color:#000000"> TreeNode</span><span style="color:#000000">&amp;</span><span style="color:#000000"> rth) <br>    {<br>        </span><span style="color:#0000ff">return</span><span style="color:#000000"> lth.m_nWeight </span><span style="color:#000000">&gt;</span><span style="color:#000000"> rth.m_nWeight ;<br>    }<br><br></span><span style="color:#0000ff">public</span><span style="color:#000000">:<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> m_nVertexIndexA ;<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> m_nVertexIndexB ;<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000"> m_nWeight ;<br>} ;<br><br></span><span style="color:#008000">//</span><span style="color:#008000">  并查集</span><span style="color:#008000"><br></span><span style="color:#0000ff">class</span><span style="color:#000000"> UnionSet <br>{<br></span><span style="color:#0000ff">public</span><span style="color:#000000">:<br>    UnionSet (</span><span style="color:#0000ff">int</span><span style="color:#000000"> nSetEleCount)<br>        : m_nSetEleCount (nSetEleCount)<br>    {<br>        __init() ;<br>    }<br>    </span><span style="color:#008000">//</span><span style="color:#008000"> 合并i，j。如果i，j同在集合中，返回false。否则返回true</span><span style="color:#008000"><br></span><span style="color:#000000">    </span><span style="color:#0000ff">bool</span><span style="color:#000000"> Union (</span><span style="color:#0000ff">int</span><span style="color:#000000"> i, </span><span style="color:#0000ff">int</span><span style="color:#000000"> j)<br>    {<br>        </span><span style="color:#0000ff">int</span><span style="color:#000000"> ifather </span><span style="color:#000000">=</span><span style="color:#000000"> __find (i) ;<br>        </span><span style="color:#0000ff">int</span><span style="color:#000000"> jfather </span><span style="color:#000000">=</span><span style="color:#000000"> __find (j) ;<br>        </span><span style="color:#0000ff">if</span><span style="color:#000000"> (ifather </span><span style="color:#000000">==</span><span style="color:#000000"> jfather )<br>        {<br>            </span><span style="color:#0000ff">return</span><span style="color:#000000"> </span><span style="color:#0000ff">false</span><span style="color:#000000"> ;<br>            </span><span style="color:#008000">//</span><span style="color:#008000"> copy (m_nvFather.begin(), m_nvFather.end(), ostream_iterator&lt;int&gt; (cout, &quot; &quot;));<br>            </span><span style="color:#008000">//</span><span style="color:#008000"> cout &lt;&lt; endl ;</span><span style="color:#008000"><br></span><span style="color:#000000">        }<br>        </span><span style="color:#0000ff">else</span><span style="color:#000000"><br>        {<br>            m_nvFather[jfather] </span><span style="color:#000000">=</span><span style="color:#000000"> ifather ;<br>            </span><span style="color:#008000">//</span><span style="color:#008000"> copy (m_nvFather.begin(), m_nvFather.end(), ostream_iterator&lt;int&gt; (cout, &quot; &quot;));<br>            </span><span style="color:#008000">//</span><span style="color:#008000"> cout &lt;&lt; endl ;</span><span style="color:#008000"><br></span><span style="color:#000000">            </span><span style="color:#0000ff">return</span><span style="color:#000000"> </span><span style="color:#0000ff">true</span><span style="color:#000000"> ;<br>        }<br>        <br>    }<br><br></span><span style="color:#0000ff">private</span><span style="color:#000000">:<br>    </span><span style="color:#008000">//</span><span style="color:#008000"> 初始化并查集</span><span style="color:#008000"><br></span><span style="color:#000000">    </span><span style="color:#0000ff">int</span><span style="color:#000000"> __init()<br>    {<br>        m_nvFather.resize (m_nSetEleCount) ;<br>        </span><span style="color:#0000ff">for</span><span style="color:#000000"> (vector</span><span style="color:#000000">&lt;</span><span style="color:#0000ff">int</span><span style="color:#000000">&gt;</span><span style="color:#000000">::size_type i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000"> ;<br>            i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> m_nSetEleCount;<br>            </span><span style="color:#000000">++</span><span style="color:#000000"> i )<br>        {<br>            m_nvFather[i] </span><span style="color:#000000">=</span><span style="color:#000000"> static_cast</span><span style="color:#000000">&lt;</span><span style="color:#0000ff">int</span><span style="color:#000000">&gt;</span><span style="color:#000000">(i) ;<br>            </span><span style="color:#008000">//</span><span style="color:#008000"> cout &lt;&lt; m_nvFather[i] &lt;&lt; &quot; &quot; ;</span><span style="color:#008000"><br></span><span style="color:#000000">        }<br>        </span><span style="color:#008000">//</span><span style="color:#008000"> cout &lt;&lt; endl ;</span><span style="color:#008000"><br></span><span style="color:#000000">        </span><span style="color:#0000ff">return</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000"> ;<br>    }<br>    </span><span style="color:#008000">//</span><span style="color:#008000"> 查找index元素的父亲节点 并且压缩路径长度 </span><span style="color:#008000"><br></span><span style="color:#000000">    </span><span style="color:#0000ff">int</span><span style="color:#000000"> __find (</span><span style="color:#0000ff">int</span><span style="color:#000000"> nIndex)<br>    {<br>        </span><span style="color:#0000ff">if</span><span style="color:#000000"> (nIndex </span><span style="color:#000000">==</span><span style="color:#000000"> m_nvFather[nIndex])<br>        {<br>            </span><span style="color:#0000ff">return</span><span style="color:#000000"> nIndex;<br>        }<br>        </span><span style="color:#0000ff">return</span><span style="color:#000000">  m_nvFather[nIndex] </span><span style="color:#000000">=</span><span style="color:#000000"> __find (m_nvFather[nIndex]);<br>    }<br><br></span><span style="color:#0000ff">private</span><span style="color:#000000">:<br>    vector</span><span style="color:#000000">&lt;</span><span style="color:#0000ff">int</span><span style="color:#000000">&gt;</span><span style="color:#000000">                m_nvFather ;    </span><span style="color:#008000">//</span><span style="color:#008000"> 父亲数组</span><span style="color:#008000"><br></span><span style="color:#000000">    vector</span><span style="color:#000000">&lt;</span><span style="color:#0000ff">int</span><span style="color:#000000">&gt;</span><span style="color:#000000">::size_type m_nSetEleCount ;    </span><span style="color:#008000">//</span><span style="color:#008000"> 集合中结点个数</span><span style="color:#008000"><br></span><span style="color:#000000">} ;<br><br></span><span style="color:#0000ff">class</span><span style="color:#000000"> MST_Kruskal<br>{<br>    typedef priority_queue</span><span style="color:#000000">&lt;</span><span style="color:#000000">TreeNode</span><span style="color:#000000">&gt;</span><span style="color:#000000"> MinHeap ;<br></span><span style="color:#0000ff">public</span><span style="color:#000000">:<br>    MST_Kruskal (</span><span style="color:#0000ff">const</span><span style="color:#000000"> vector</span><span style="color:#000000">&lt;</span><span style="color:#000000">vector</span><span style="color:#000000">&lt;</span><span style="color:#0000ff">int</span><span style="color:#000000">&gt;</span><span style="color:#000000"> </span><span style="color:#000000">&gt;&amp;</span><span style="color:#000000"> graph) <br>    {<br>        m_nNodeCount </span><span style="color:#000000">=</span><span style="color:#000000"> static_cast</span><span style="color:#000000">&lt;</span><span style="color:#0000ff">int</span><span style="color:#000000">&gt;</span><span style="color:#000000">(graph.size ()) ;<br>        __getMinHeap (graph) ;<br>    }<br>    </span><span style="color:#0000ff">void</span><span style="color:#000000"> DoKruskal ()<br>    {<br>        UnionSet us (m_nNodeCount) ;<br>        </span><span style="color:#0000ff">int</span><span style="color:#000000"> k </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000"> ; <br>        </span><span style="color:#0000ff">while</span><span style="color:#000000"> (m_minheap.size() </span><span style="color:#000000">!=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000"> </span><span style="color:#000000">&amp;&amp;</span><span style="color:#000000"> k </span><span style="color:#000000">&lt;</span><span style="color:#000000"> m_nNodeCount </span><span style="color:#000000">-</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000">) <br>        {<br>            TreeNode tn </span><span style="color:#000000">=</span><span style="color:#000000"> m_minheap.top () ;<br>            m_minheap.pop () ;<br>            </span><span style="color:#008000">//</span><span style="color:#008000"> 判断合理性</span><span style="color:#008000"><br></span><span style="color:#000000">            </span><span style="color:#0000ff">if</span><span style="color:#000000"> (us.Union (tn.m_nVertexIndexA, tn.m_nVertexIndexB)) <br>            {<br>                m_tnMSTree.push_back (tn) ;<br>                </span><span style="color:#000000">++</span><span style="color:#000000"> k ;<br>            }<br>        }<br>        </span><span style="color:#008000">//</span><span style="color:#008000"> 输出结果</span><span style="color:#008000"><br></span><span style="color:#000000">        </span><span style="color:#0000ff">for</span><span style="color:#000000"> (size_t i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">; i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> m_tnMSTree.size() ; </span><span style="color:#000000">++</span><span style="color:#000000"> i) <br>        {<br>            cout </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> m_tnMSTree[i].m_nVertexIndexA </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> </span><span style="color:#800000">"</span><span style="color:#800000">-&gt;</span><span style="color:#800000">"</span><span style="color:#000000"><br>                </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> m_tnMSTree[i].m_nVertexIndexB </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> </span><span style="color:#800000">"</span><span style="color:#800000"> : </span><span style="color:#800000">"</span><span style="color:#000000"><br>                </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> m_tnMSTree[i].m_nWeight <br>                </span><span style="color:#000000">&lt;&lt;</span><span style="color:#000000"> endl ;<br>        }<br>    }<br><br></span><span style="color:#0000ff">private</span><span style="color:#000000">:<br>    </span><span style="color:#0000ff">void</span><span style="color:#000000"> __getMinHeap (</span><span style="color:#0000ff">const</span><span style="color:#000000"> vector</span><span style="color:#000000">&lt;</span><span style="color:#000000">vector</span><span style="color:#000000">&lt;</span><span style="color:#0000ff">int</span><span style="color:#000000">&gt;</span><span style="color:#000000"> </span><span style="color:#000000">&gt;&amp;</span><span style="color:#000000"> graph) <br>    {<br>        </span><span style="color:#0000ff">for</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000"> i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">; i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> m_nNodeCount; </span><span style="color:#000000">++</span><span style="color:#000000"> i) <br>        {<br>            </span><span style="color:#0000ff">for</span><span style="color:#000000"> (</span><span style="color:#0000ff">int</span><span style="color:#000000"> j </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">; j </span><span style="color:#000000">&lt;</span><span style="color:#000000"> m_nNodeCount; </span><span style="color:#000000">++</span><span style="color:#000000"> j) <br>            {<br>                </span><span style="color:#0000ff">if</span><span style="color:#000000"> (graph[i][j] </span><span style="color:#000000">!=</span><span style="color:#000000"> numeric_limits</span><span style="color:#000000">&lt;</span><span style="color:#0000ff">int</span><span style="color:#000000">&gt;</span><span style="color:#000000">::max()) <br>                {<br>                    m_minheap.push (TreeNode(i, j, graph[i][j])) ;<br>                }<br>            }<br>        }<br>    }<br></span><span style="color:#0000ff">private</span><span style="color:#000000">:<br>    vector</span><span style="color:#000000">&lt;</span><span style="color:#000000">TreeNode</span><span style="color:#000000">&gt;</span><span style="color:#000000">    m_tnMSTree ;<br>    </span><span style="color:#0000ff">int</span><span style="color:#000000">                    m_nNodeCount ;<br>    MinHeap                m_minheap ;<br>} ;<br><br><br></span><span style="color:#0000ff">int</span><span style="color:#000000"> main ()<br>{<br>    </span><span style="color:#0000ff">const</span><span style="color:#000000"> </span><span style="color:#0000ff">int</span><span style="color:#000000"> cnNodeCount </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">6</span><span style="color:#000000"> ;<br>    vector</span><span style="color:#000000">&lt;</span><span style="color:#000000">vector</span><span style="color:#000000">&lt;</span><span style="color:#0000ff">int</span><span style="color:#000000">&gt;</span><span style="color:#000000"> </span><span style="color:#000000">&gt;</span><span style="color:#000000"> graph (cnNodeCount) ;<br>    </span><span style="color:#0000ff">for</span><span style="color:#000000"> (size_t i </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">0</span><span style="color:#000000">; i </span><span style="color:#000000">&lt;</span><span style="color:#000000"> graph.size() ; </span><span style="color:#000000">++</span><span style="color:#000000"> i) <br>    {<br>        graph[i].resize (cnNodeCount, numeric_limits</span><span style="color:#000000">&lt;</span><span style="color:#0000ff">int</span><span style="color:#000000">&gt;</span><span style="color:#000000">::max()) ;<br>    }<br>    graph[</span><span style="color:#800080">0</span><span style="color:#000000">][</span><span style="color:#800080">1</span><span style="color:#000000">]</span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">6</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">0</span><span style="color:#000000">][</span><span style="color:#800080">2</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">0</span><span style="color:#000000">][</span><span style="color:#800080">3</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">3</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">1</span><span style="color:#000000">][</span><span style="color:#800080">2</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">5</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">1</span><span style="color:#000000">][</span><span style="color:#800080">4</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">3</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">2</span><span style="color:#000000">][</span><span style="color:#800080">3</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">5</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">2</span><span style="color:#000000">][</span><span style="color:#800080">4</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">6</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">2</span><span style="color:#000000">][</span><span style="color:#800080">5</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">4</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">3</span><span style="color:#000000">][</span><span style="color:#800080">5</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">2</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">4</span><span style="color:#000000">][</span><span style="color:#800080">5</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">6</span><span style="color:#000000"> ;<br>    <br>    graph[</span><span style="color:#800080">1</span><span style="color:#000000">][</span><span style="color:#800080">0</span><span style="color:#000000">]</span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">6</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">2</span><span style="color:#000000">][</span><span style="color:#800080">0</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">1</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">3</span><span style="color:#000000">][</span><span style="color:#800080">0</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">3</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">2</span><span style="color:#000000">][</span><span style="color:#800080">1</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">5</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">4</span><span style="color:#000000">][</span><span style="color:#800080">1</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">3</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">3</span><span style="color:#000000">][</span><span style="color:#800080">2</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">5</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">4</span><span style="color:#000000">][</span><span style="color:#800080">2</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">6</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">5</span><span style="color:#000000">][</span><span style="color:#800080">2</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">4</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">5</span><span style="color:#000000">][</span><span style="color:#800080">3</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">2</span><span style="color:#000000"> ;<br>    graph[</span><span style="color:#800080">5</span><span style="color:#000000">][</span><span style="color:#800080">4</span><span style="color:#000000">] </span><span style="color:#000000">=</span><span style="color:#000000"> </span><span style="color:#800080">6</span><span style="color:#000000"> ;<br><br>    MST_Kruskal mst (graph);<br>    mst.DoKruskal () ;<br>}</span></div></pre>
</div>
</div>
<p> </p>
<p><strong>参考书籍 《算法设计与分析（第二版）》  王晓东</strong></p>
<p><strong>授课教师 张阳教授</strong></p><img src="http://www.cnblogs.com/chinazhangjie/aggbug/1894314.html?type=1" width="1" height="1" alt=""><p>作者: <a href="http://www.cnblogs.com/chinazhangjie/">chinazhangjie</a> 发表于 2010-12-02 12:37 <a href="http://www.cnblogs.com/chinazhangjie/archive/2010/12/02/1894314.html">原文链接</a></p><p>评论: 2　<a href="http://www.cnblogs.com/chinazhangjie/archive/2010/12/02/1894314.html#pagedcomment">查看评论</a>　<a href="http://www.cnblogs.com/chinazhangjie/archive/2010/12/02/1894314.html#commentform">发表评论</a></p><hr><p>最新新闻：<br>· <a href="http://news.cnblogs.com/n/83238/">甲骨文总裁Larry Ellison爱对客户撒谎</a><span style="color:gray">(2010-12-02 22:57)</span><br>· <a href="http://news.cnblogs.com/n/83237/">美总务署将用Google云计算服务代替微软软件</a><span style="color:gray">(2010-12-02 22:57)</span><br>· <a href="http://news.cnblogs.com/n/83236/">Facebook CEO扎克伯格周日将亮相CBS节目</a><span style="color:gray">(2010-12-02 22:52)</span><br>· <a href="http://news.cnblogs.com/n/83235/">新华社与盛大网络签署全面战略合作协议</a><span style="color:gray">(2010-12-02 22:52)</span><br>· <a href="http://news.cnblogs.com/n/83234/">Chrome Canary 即将飞向 Mac 和 Linux 平台？</a><span style="color:gray">(2010-12-02 22:49)</span><br></p><p>编辑推荐：<a href="http://www.cnblogs.com/MichaelPeng/archive/2010/12/02/1893999.html">金山安全卫士代码批评</a><br></p><p>网站导航：<a href="http://www.cnblogs.com">博客园首页</a>  <a href="http://home.cnblogs.com/">我的园子</a>  <a href="http://news.cnblogs.com">新闻</a>  <a href="http://home.cnblogs.com/ing/">闪存</a>  <a href="http://home.cnblogs.com/group/">小组</a>  <a href="http://space.cnblogs.com/q/">博问</a>  <a href="http://kb.cnblogs.com">知识库</a></p></p>